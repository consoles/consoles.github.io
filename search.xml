<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈 HTTP</title>
      <link href="/2025/05/14/%E6%B5%85%E8%B0%88HTTP/"/>
      <url>/2025/05/14/%E6%B5%85%E8%B0%88HTTP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Etag 是 Entity Tag 的缩写，是内容缓存。</p></blockquote><h1 id="http-头"><a href="#http-头" class="headerlink" title="http 头"></a>http 头</h1><ul><li>If-Modified-Since：请求头中可以指定资源修改时间，服务器判断如果没有更改则返回 304 状态，并且不携带消息体，更改了则返回 200 携带上最新的资源。常用于缓存控制。</li><li>Retry-After：响应头中可以指示客户端在多久后再次尝试请求。通常和 503(Service Unavailable) 或者 429(Too Many Requests) 一起使用，但也可以与其他一些表示暂时性失败的状态码配合使用。这个头部字段可以帮助服务器进行流控，尤其在高负载或者服务器维护期间。</li><li>Via：报文经过代理或者网关的时候，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 以及电子邮件的 Received 首部的工作机制类似。首部 Via 不仅可以用于追踪报文的转发，还可以避免请求回环的发生，所以在经过代理的时候必须附加该首部。经常和 TRACE 方法一起使用，用于追踪报文的转发路径。</li></ul><h1 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h1><p>HTTP keep-alive 带来的一个好处是可以进行管线化(pipelining)发送请求 —— 不用等待响应就可以直接发送下一个请求，可以做到同时并行发送多个请求。</p><h1 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h1><p>客户端和服务器就响应的资源内容进行交涉，然后提供给客户端最适合的资源。内容协商会以响应资源的语言、字符集、编码等方式作为判断的基准。包含在请求头中的下列字段可以作为判断标准：Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Language。</p><h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>同一台服务器上可以运行多个网站（域名），例如 NGINX 可以配置多个 vhost。浏览器在访问网站的时候已经是 IP 了，换而言之 a.com 和 b.com 都在 1.2.3.4 这个地址上，浏览器请求的时候怎么知道访问的是哪个网站呢？这个时候就需要靠请求头中的 Host 字段了。<strong>请求头中的 Host 字段必须存在</strong>！</p><h1 id="网关和代理的区别"><a href="#网关和代理的区别" class="headerlink" title="网关和代理的区别"></a>网关和代理的区别</h1><p>代理通常只负责转发请求，不转换协议，通常用于访问控制、缓存加速、匿名访问等，典型代表室 NGINX 反向代理，shadowsocks；网关支持不同协议之间的转换(http -&gt; grpc)，常用于系统间集成、api 聚合、协议适配，典型应用有 API 网关、支付网关。</p><p>利用网关可以提高通信安全性，可以在客户端和网关之间的通信链路上加密以确保连接的安全。</p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Secure 表示仅在 https 协议下传输，HttpOnly 表示不能通过 JavaScript 访问（主要目的是为了防止 XSS 攻击）。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理学</title>
      <link href="/2025/04/30/%E7%AE%A1%E7%90%86%E5%AD%A6/"/>
      <url>/2025/04/30/%E7%AE%A1%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Stay Foolish, Stay Hungry.</p></blockquote><blockquote><p>故善者因之，其次利道之，其次教诲之，其次整齐之，最下者与之争。</p></blockquote><h1 id="如何调动早期员工的积极性和解决大锅饭问题"><a href="#如何调动早期员工的积极性和解决大锅饭问题" class="headerlink" title="如何调动早期员工的积极性和解决大锅饭问题"></a>如何调动早期员工的积极性和解决大锅饭问题</h1><p>一家成功公司的早期员工是非常宝贵的财富。他们一般是非常冒险的人，否则他们不会选择加入新开办的，甚至还没有投资的小公司，他们的技术和能力非常强，常常可以独当一面，因为早期的公司要求员工什么都得干。他们同时对新技术非常敏感，否则他们就不会在众多新兴公司中挑选中那些日后能成功的。但是他们也有弱点：他们虽然善于开创，但是却不善于或不愿意守成，而后者对于一家大公司的发展至关重要！他们做事快，但是不够精细，因为在公司规模小的时候，抢时间比什么都重要！一般在公司发展到一定阶段的时候，他们会和新的管理层发生冲突 —— 新的主管会觉得他们不好管。这就如同打江山的人未必能治理江山。这些员工很可能自己出去开公司。而即使留在公司的这些员工都已腰缠万贯，原先的动力也会大打折扣。因此，如何留住早期员工，并且调动他们的积极性，便成了每一个上市科技公司的难题。</p><p>另外，一家公司大到一定程度的时候，每个人的贡献就不容易体现过来，大锅饭现象几乎是全世界的通病。一些员工虽然有很好的想法，也懒得费功夫去推动它，因为自己多花几倍的时间和精力最多可能多得百分之几的奖金。偶尔出来一两个人试图推动一下也会遇到很大阻力。因此，有些员工一旦有了想法，宁愿自己出去创业，也不远贡献给所在的公司。</p><p>思科的这两个问题解决的很好。很像在大航海时代西班牙和葡萄牙对探险者的做法 —— 探险者和王室达成一种协议：一旦发现新的岛屿和陆地，则以王室的名义宣布这些土地归国王所有，同时国王封这些发现者为那片土地的总督，并授予征税权。思科的具体做法是：如果公司有人愿意自己创业，公司又觉得他们做的东西好，就让他们留在公司内部创业而不是到外面去折腾，而思科会作为投资者（而不再是管理者）来对待这些创业的人。一旦这些小公司成功了，思科有优先权把它们买回来，思科的地盘就得到扩大，而这些独立的小公司的创办者和员工又可以得到很高的回报；如果小公司没办好关门了，思科除了赔上一笔 VC 的钱，没有额外负担。这种做法不仅调动了各种员工，尤其是早期员工的积极性，也避免了这些员工将来成为自己的对手，或者加入对手阵营。</p><h1 id="小公司成功的几个要素"><a href="#小公司成功的几个要素" class="headerlink" title="小公司成功的几个要素"></a>小公司成功的几个要素</h1><ol><li>创始人。</li><li>好的团体和技术。</li><li>商业头脑，必须能找到能盈利的商业模型。</li><li>判断力和执行力。</li><li>外部环境。</li><li>运气（这恰恰是最重要的）。</li></ol><h1 id="管理学黑话"><a href="#管理学黑话" class="headerlink" title="管理学黑话"></a>管理学黑话</h1><p>先保证团队里有老中新 3 种人，然后按照学习能力和工作态度进行排序，拉拢一批，批判一批。请客，斩首，收下当狗。</p><h1 id="彼得定律"><a href="#彼得定律" class="headerlink" title="彼得定律"></a>彼得定律</h1><p>彼得在 20 世纪 70 年代，研究了美国数千个组织，包括政府部门、学校、企业等各种类型的组织后，发现，在一个成熟有效的组织中，当一个员工在其岗位能够出色完成工作，就会得到晋升，被提拔到更高一级职位。如果在这个职位，他能够继续出色完成工作，就会继续得到晋升，直到他晋升到某个职位以后，无法出色完成工作为止。</p><p>这是职场晋升的一般规则，看起来似乎也没什么，但是彼得在对这些得到晋升的人进行各种观察以后，得到一个结论：**在一个层级组织中，每个员工都会趋向于晋升到他所不能胜任的职位。**这就是彼得定律，事实上，我们根据晋升的一般规则，也能推导出这个定律。利用这个定律做进一步的推导，还能得到一个彼得定律的推论：**一个成熟的组织中，所有的职位都被不能够胜任它的人承担着。**这个推论也很好理解，每个人都会晋升到他不能胜任的职位，那么稳定下来以后，所有的职位都被不能胜任的人承担。不得不说这个结论实在是让人有点吃惊，但是却很好地解释了组织中的各种奇怪现象。</p><p>彼得进一步对这些不能胜任自己职位的人进行观察，发现当一个人位于他不能胜任的职位上时，他必须投入全部的精力才能有效完成工作，这个职位也被称作这个人的**彼得高地。**一个处于彼得高地的人，精疲力尽于他手头的工作，就无法再进行更进一步的思考和学习，他的个人能力提升和职业进步都将止步于此。所以，一个人在其职业生涯中能够晋升的最高职位，能够在专业技能上进化的最高阶段，依赖于他的专业能力和综合素养，依赖于他拥有的持续学习和专业训练的条件与环境。和他晋升的速度无关，有时候也许恰恰相反。</p><p>对公司而言，真正有价值的是你为公司解决了多少问题，而不是完成了多少工作，工作本身没有意义，解决问题才有意义。对于你自己而言，真正有价值的不是你获得了多快的晋升，多高的加薪，而是你获得了多少持续高强度训练的机会。而这两者，本质上是统一的。</p><p>所以，对自己未来有更多期待，更有进取心的工程师们，应该将精力更多放在发现企业中的各种问题并致力于去解决问题，在这个过程中，你将同步收获职场晋升和个人能力提升。</p><h1 id="亚马逊是如何解决交易的信用问题"><a href="#亚马逊是如何解决交易的信用问题" class="headerlink" title="亚马逊是如何解决交易的信用问题"></a>亚马逊是如何解决交易的信用问题</h1><p>亚马逊为每一笔交易买一笔保险，这样一旦出现了有意的欺诈行为和无意的商品丢失，保险公司将支付亚马逊的损失。</p><h1 id="社交软件的起源"><a href="#社交软件的起源" class="headerlink" title="社交软件的起源"></a>社交软件的起源</h1><p>用户早期去 Facebook 的原因就是去约炮(Young people need sex)。</p>]]></content>
      
      
      <categories>
          
          <category> 管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见家常菜做法</title>
      <link href="/2025/04/05/%E5%B8%B8%E8%A7%81%E5%AE%B6%E5%B8%B8%E8%8F%9C%E5%81%9A%E6%B3%95/"/>
      <url>/2025/04/05/%E5%B8%B8%E8%A7%81%E5%AE%B6%E5%B8%B8%E8%8F%9C%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="洋葱炒蛋"><a href="#洋葱炒蛋" class="headerlink" title="洋葱炒蛋"></a>洋葱炒蛋</h1><p>准备工作：</p><ol><li>3 个鸡蛋打到碗里，搅拌均匀</li><li>1 个洋葱切成丝</li><li>配菜少许青红椒切成丝</li></ol><p>准备料汁：</p><p>生抽 + 耗油 + 盐 + 鸡精 + 一勺淀粉 + 一勺清水</p><p>将料汁搅拌均匀，在碗里备用</p><p>烹饪过程：</p><ol><li>将锅烧热，加油适量，油开后加入蛋液，快速划熟划散后盛出备用</li><li>将洋葱丝和青红椒丝入锅，开大火翻炒 1 min，注意要加盐，否则会偏淡</li><li>倒入炒好的鸡蛋，淋上调好的料汁，大火随便翻炒几下入味即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美食 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nest.js学习</title>
      <link href="/2025/03/22/Nest-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/22/Nest-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>依赖注入是 Nest.js 的核心，使得开发者可以轻松管理应用程序中的依赖关系，提高代码的可测试性和可维护性。DI 是一种设计模式，它可以用来实现控制反转（IoC）—— 对象的创建和依赖关系的管理交给框架来处理而不是在代码中硬编码。</p><p>它的依赖注入主要有 3 个核心概念：</p><ol><li>Provider: 用于创建和管理的服务、仓库、工厂等的类，使用 <code>@Injectable</code> 装饰器进行标记，并可以在模块中注册。</li><li>Injection: 将提供者的实例自动传递给需要它们的类（如控制器、服务等）,通过构造函数注入来实现这一点。</li><li>Module: NestJS 应用程序的基本组织单元，每个模块可以包含多个提供者，并且可以在其他模块中导入和使用这些提供者。</li></ol><p>依赖注入的优势：</p><ol><li>解耦：类之间的依赖关系更加松散，减少了代码的耦合度，提高了代码的可维护性</li><li>可测试性：通过依赖注入，可以轻松在测试中替换依赖项，使用模拟对象进行单元测试</li><li>可拓展性：新功能可以通过添加新的提供者来实现，而不需要修改现有代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架-React</title>
      <link href="/2025/03/21/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/"/>
      <url>/2025/03/21/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-React/</url>
      
        <content type="html"><![CDATA[<p>组件是 React.js 的基础</p><p>next.js 默认使用 page.tsx 作为入口</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ -&gt; app/page.tsx</span><br><span class="line">/test -&gt; app/test/page.tsx</span><br></pre></td></tr></table></figure><h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p>useState 回调函数只有在第一次渲染的时候才会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> expensiveValue = <span class="title function_">computeExpensiveValue</span>(); <span class="comment">// 只会在首次渲染时执行</span></span><br><span class="line">  <span class="keyword">return</span> expensiveValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h1><p>请记住单向数据流。</p><ul><li>父组件 -&gt; 子组件：通过 props 属性传递</li><li>子组件 -&gt; 父组件：通过 props 传递<em>函数</em>，触发父组件中的状态更新</li></ul><p>在 vue 中父组件将 props 传递给子组件，子组件如果想要更改父组件中的值是通过抛出一个事件<code>$emit</code>通知父组件<code>v-on</code>来进行的。和原生 DOM 事件不一样，组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个全局状态管理方案。双向数据传递的方案可以使用 <code>v-model</code>。</p><p>react hooks 类似 vue 组合式函数。</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="类组件和函数式组件"><a href="#类组件和函数式组件" class="headerlink" title="类组件和函数式组件"></a>类组件和函数式组件</h2><p>按照组件的定义方式可以分为类组件和函数式组件。现在推荐使用函数式组件，代码写起来简洁，并且兼容类组件的所有特性，类组件是历史产物。</p><ul><li>纯函数：函数组件更容易编写纯函数（即相同的输入总是产生相同的输出，没有副作用）。</li><li>不可变性：通过 Hooks（如 useState）管理状态时，状态更新是不可变的，这有助于避免副作用。</li><li>组合性：函数组件可以更容易地组合和复用。</li></ul><p>React Hooks 是 React 16.8 引入的革命性特性，它允许你在函数组件中使用状态(state)和其他 React 特性，而无需编写 class 组件。</p><h2 id="客户端组件和服务端组件"><a href="#客户端组件和服务端组件" class="headerlink" title="客户端组件和服务端组件"></a>客户端组件和服务端组件</h2><p>组件默认是服务端组件，除非使用 <code>use client</code>。服务端组件是在服务器完成渲染的，不支持浏览器 API（window, document），不支持 React 状态和副作用。适合静态内容和数据密集型页面（在服务端组件完成数据库查询，不会被加载到客户端）；而客户端组件适合强交互和需要浏览器 API 的页面。</p><p>server components 才能是 async 的</p><blockquote><p>服务端组件是不是又回到了 JSP 时代？<br>服务端组件并不是简单地回到 JSP&#x2F;PHP 的时代，而是在现代前端生态的基础上，结合了服务器端渲染的优势。它提供了以下改进: 组件化开发：基于 React 的组件化模式；性能优化：支持代码拆分、懒加载、边缘计算等现代性能优化技术。</p></blockquote><h1 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h1><p>Vite：vue 作者开发，包含 2 部分：</p><ul><li>开发服务：服务于开发环境，ESM + HMR</li><li>构建指令：服务于生产环境，用 Rollup 打包</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/web-pack-tools.png" alt="Vite ESM打包器"></p><p>传统打包工具例如 webpack 需要提供一个 entry，在启动的时候需要加载所有，而 ESM 打包器这种概念类似于按需加载，启动速度和更新速度都比较快。Vite 将模块区分为依赖和源码 2 类，提升开发服务启动时间。</p><p>依赖：开发时不会变动纯 js，Vite 会使用 esbuild 预构建(golang 编写)依赖。<br>源码：通常为 JSX,CSS,Vue SFC 等，经常会被编辑，需要转换，基于路由拆分。</p><p>Vite 以原生 ESM 方式提供源码，让浏览器接管打包工作。</p><h1 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h1><p>全栈框架 Next.js + Remix 已经占了 React 生态的 50%，官方的 create-react-app 已经很久没有进行维护了。主流的前端框架都有一个对应的全栈框架 meta framework。Vue + Nuxt, servlet + servletKit。前端的未来就是全栈。前端必须要用 js，SSR 框架必须使用 nodejs（php，java 无法实现）。</p><h2 id="ServerAction"><a href="#ServerAction" class="headerlink" title="ServerAction"></a>ServerAction</h2><p>编写的函数是运行在服务端的，但是我们可以在客户端直接调用（就像调用本地函数一样），省去了在服务端对函数去包装 API 的这个过程。<code>use server</code> 标注的函数。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Parallel Routies：<code>@</code>插槽，并行关系，例如：导航<br>Intercepting Routies: 在当前页面下打开其他页面的路由，但是不会跳离当前页面的上下文<br>Api Router Handler<br>Loading</p><h2 id="文件路由"><a href="#文件路由" class="headerlink" title="文件路由"></a>文件路由</h2><p>app 是应用根目录，app 目录下的每个目录代表一级路由</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/nextjs-file-router.png" alt="文件路由"></p><p>上图中的 <code>src/app/dashboard/app/[app]</code> 最后的 <code>[app]</code> 表示动态路由（可以被变量替换）</p><p>layout 是可以被继承的，page 只有在当前对应的路由下才会生效。</p><h1 id="Tailwind-CSS"><a href="#Tailwind-CSS" class="headerlink" title="Tailwind CSS"></a>Tailwind CSS</h1><p>React 生态中一种常见样式的写法就是 Css in JS，最具有代表性的就是 stypled components,Emotion.js,Pandajs(几乎无运行时js)，特性：灵活、模块化；缺点是性能（动态计算，插入节点），SSR 不友好（服务端渲染 html，需要在客户端进行样式合并，会有各种情况发生）</p><p>另一种解决方案是原子化 css，最小化样式文件（只有用到才会打包），随着项目复杂度的提升，最终用到的 css 文件的增量会越来越少。突出问题类名过长，难以阅读。</p><p>提供了一些语义化的实用的类名：<code>bg-black/[.05]</code> 的意思：</p><ul><li><code>bg-black</code>：这部分表示背景颜色为黑色</li><li><code>/</code>：斜杠表示透明度(opacity)</li><li><code>[.05]</code>：方括号是任意值语法，允许任何自定义值，<code>.05</code> 表示透明度 5%</li></ul><p>冒号<code>:</code>有特殊的含义，用于表示修饰符。</p><ol><li><code>dark:</code> 暗色模式</li><li><code>hover:</code> 鼠标悬停</li><li><code>sm:</code> 响应式断点，小屏幕</li><li><code>focus:</code> 聚焦</li><li><code>active:</code> 激活</li></ol><p><code>hover:bg-red-500</code> 鼠标悬停的时候变为标准红色。数值的取值是 50-950，较小的数值趋向于白色，较大的值趋向于黑色，一般 200 才开始有明显变化。</p><h2 id="滤镜"><a href="#滤镜" class="headerlink" title="滤镜"></a>滤镜</h2><h3 id="基础滤镜"><a href="#基础滤镜" class="headerlink" title="基础滤镜"></a>基础滤镜</h3><p>blur-{amount} - 模糊效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blur-sm  <span class="comment">/* 小模糊 */</span></span><br><span class="line">blur     <span class="comment">/* 标准模糊 */</span></span><br><span class="line">blur-lg  <span class="comment">/* 大模糊 */</span></span><br></pre></td></tr></table></figure><p>brightness-{amount} - 亮度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brightness-<span class="number">50</span>  <span class="comment">/* 50%亮度 */</span></span><br><span class="line">brightness-<span class="number">100</span> <span class="comment">/* 正常亮度 */</span></span><br><span class="line">brightness-<span class="number">200</span> <span class="comment">/* 200%亮度 */</span></span><br></pre></td></tr></table></figure><p>contrast-{amount} - 对比度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contrast-<span class="number">0</span>    <span class="comment">/* 无对比度 */</span></span><br><span class="line">contrast-<span class="number">100</span>  <span class="comment">/* 正常对比度 */</span></span><br><span class="line">contrast-<span class="number">200</span>  <span class="comment">/* 高对比度 */</span></span><br></pre></td></tr></table></figure><h3 id="颜色处理"><a href="#颜色处理" class="headerlink" title="颜色处理"></a>颜色处理</h3><p>grayscale - 灰度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grayscale-<span class="number">0</span>  <span class="comment">/* 原色 */</span></span><br><span class="line">grayscale    <span class="comment">/* 完全灰度 */</span></span><br></pre></td></tr></table></figure><p>sepia - 褐色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sepia-<span class="number">0</span>  <span class="comment">/* 原色 */</span></span><br><span class="line">sepia    <span class="comment">/* 完全褐色 */</span></span><br></pre></td></tr></table></figure><p>invert - 反转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invert-<span class="number">0</span>  <span class="comment">/* 原色 */</span></span><br><span class="line">invert    <span class="comment">/* 完全反转 */</span></span><br></pre></td></tr></table></figure><h1 id="UI-组件"><a href="#UI-组件" class="headerlink" title="UI 组件"></a>UI 组件</h1><p>Shadcn &#x3D; Radix UI + Tailwind Css 样式，无需进行安装，直接生成到项目中，作为源码的一部分。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ul><li>key 可以帮助 React 识别列表中的每个元素，优化渲染性能，避免状态混乱。使用唯一标识符作为 key，避免使用索引。</li><li>使用 <a href="https://uppy.io/">uppy</a> 进行文件上传。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React.js </tag>
            
            <tag> Next.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈在线文档中的协同编辑</title>
      <link href="/2025/03/17/%E6%B5%85%E8%B0%88%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/"/>
      <url>/2025/03/17/%E6%B5%85%E8%B0%88%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p>这是我在面试一个后端 node.js 工程师的时候遇到的一个场景题目（公司是做 AI 知识库的，可能遇到这些问题）。</p><p>我当时回答了如下内容：</p><ol><li>每一篇文档有 id, 作者，内容，版本号, 状态(编辑中，已发布)</li><li>用户在进入页面的时候，会从 DB 中拉取最新的版本，编辑的时候会向服务器发送一个请求，这个时候服务器将状态改变为编辑中，同时将版本号加一，通知其他所有客户端。将这个改动记录到日志中，便于回档。</li><li>其他用户收到消息的时候重新渲染页面。</li></ol><p>这个结果的正确性应该是可以保证的，可以通过乐观锁的机制来保证旧版本不会覆盖新版本数据。问题是每次更新都是全量的，多客户端修改频繁，网络 IO, 频繁的 DB 修改都是问题。</p><p>抛开性能问题不谈？上面的方案有个核心问题：其他用户怎么看到当前用户的鼠标位置？</p><p>优化的一个方案就是只做增量修改，这方面可以联想到 rsync 的增量同步， git 中的 diff 算法。</p><p>下面搜索答案，其实业界有现成的算法</p><h1 id="OT-Operational-Transformation"><a href="#OT-Operational-Transformation" class="headerlink" title="OT (Operational Transformation)"></a>OT (Operational Transformation)</h1><p>广泛应用在 Goole Docs 等早期在线文档工具中。</p><p>核心思想：</p><ol><li>用户的每次操作(例如插入、删除)都会被转化为一个操作 (operation)。</li><li>操作在传输到服务器和其他客户端的时候，会根据其他用户的操作进行转换(transformation)，确保最终状态一致。</li></ol><p>优点：</p><ol><li>保证最终一致性（所有用户看到的内容相同）</li><li>支持高并发编辑</li></ol><p>缺点：</p><ol><li>实现复杂，尤其是处理冲突时需要复杂的转换逻辑</li><li>对服务器依赖非常大</li></ol><h1 id="CRDTs-Conflict-free-Replicated-Data-Types"><a href="#CRDTs-Conflict-free-Replicated-Data-Types" class="headerlink" title="CRDTs (Conflict-free Replicated Data Types)"></a>CRDTs (Conflict-free Replicated Data Types)</h1><p>CRDT 是一种分布式数据结构，近年来被广泛应用于实时协同编辑。</p><p>核心思想:</p><ol><li>每个用户的操作是独立的，并且可以通过数学规则合并，无需转换</li><li>所有操作都是可交换、可结合和幂等的，最终状态会自动收敛</li></ol><p>优点：</p><ol><li>去中心化，适合分布式系统</li><li>无需复杂的冲突解决逻辑</li></ol><p>缺点：</p><ol><li>内存占用高（需要存储所有操作的历史）</li><li>实现复杂度高</li></ol><h1 id="版本控制和冲突解决"><a href="#版本控制和冲突解决" class="headerlink" title="版本控制和冲突解决"></a>版本控制和冲突解决</h1><ul><li>版本号：每个操作附带一个版本号，用于确定操作的顺序</li><li>冲突检测：多个用户同时编辑同一部分内容的时候，系统会检测冲突并解决（如通过 OT 转换或者 CRDT 合并）</li><li>用户光标同步：显示其他用户的光标位置和编辑状态，避免冲突</li></ul><h1 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h1><ul><li>增量更新：只更新文档中发生变化的部分，而不是重新渲染整个文档。</li><li>协同光标：实时显示其他用户的光标和选择范围。</li><li>离线支持：允许用户在离线时继续编辑，并在重新连接时同步更改。</li></ul><h1 id="典型工作流程"><a href="#典型工作流程" class="headerlink" title="典型工作流程"></a>典型工作流程</h1><ol><li>用户 A 在文档中插入一段文字，操作被发送到服务器。</li><li>服务器将操作广播给其他在线用户（B、C）。</li><li>用户 B 和 C 的客户端根据 OT 或 CRDT 规则将操作应用到本地文档。</li><li>如果用户 B 和 C 同时编辑同一部分内容，系统会检测冲突并解决。</li><li>所有用户的文档状态最终保持一致。</li></ol><p>多人实时在线文档的核心算法包括 Operational Transformation (OT) 和 Conflict-free Replicated Data Types (CRDTs)，结合实时通信技术、版本控制和分布式架构，确保高效、一致和安全的协同编辑体验。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.zhihu.com/question/274573543">实现一个多人协作在线文档有哪些技术难点</a></li><li><a href="https://github.com/yjs/yjs">yjs</a></li><li><a href="https://www.imooc.com/article/344978">AI 写作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 https</title>
      <link href="/2025/03/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3https/"/>
      <url>/2025/03/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3https/</url>
      
        <content type="html"><![CDATA[<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="对称加密的局限性"><a href="#对称加密的局限性" class="headerlink" title="对称加密的局限性"></a>对称加密的局限性</h2><p>在对称加密（例如：AES）中，加&#x2F;解密使用相同的秘钥。这会带来 2 个问题：</p><ol><li><strong>秘钥分发问题</strong>：发送方和接受方必须通过某种安全方式共享秘钥。如果秘钥在传输时被截获，通信安全性就会被破坏。</li><li><strong>秘钥管理问题</strong>：如果有多对用户需要通信，每对用户都需要一个独立的秘钥，秘钥数量会随着用户规模急剧增加(10个用户需要 45 个秘钥， n*(n-1)&#x2F;2 )。</li></ol><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><ul><li><strong>公钥</strong>：公开分享，用于加密数据或者验证签名</li><li><strong>私钥</strong>：严格保密，用于解密数据或者生成签名</li></ul><p>公钥和私钥在数学上是相关的，但是从公钥推导出私钥在计算上是不可行的（基于大整数分解或者离散对数）。发送方使用接收方的公钥进行加密，接收方使用自己的私钥才能解密，因此不需要传递秘钥。</p><p>非对称加密的缺点是运算速度慢。</p><h3 id="为什么我们常常说公钥加密私钥解密"><a href="#为什么我们常常说公钥加密私钥解密" class="headerlink" title="为什么我们常常说公钥加密私钥解密"></a>为什么我们常常说公钥加密私钥解密</h3><p>其实<strong>公钥和私钥都能用来加密和解密</strong>。也就是说：同一对钥匙，公钥加密只能私钥解密，私钥加密只能公钥解密。那么我们平常为什么不说私钥加密呢？因为公钥是公开的，人手一份公钥，这不就等于没有加密么？因此在实践中，不用私钥进行加密。私钥的一般用途是签名。</p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2daaafd0-d6e0-11e9-ade4-13ccd89a2e5d.png" alt="RSA算法中的中间人攻击"></p><p>例如电信运营商的DNS劫持（或者HTTP劫持），篡改网页加入自己的广告，最好的解决方案是采用HTTPS协议（多了一个步骤SSL证书）。</p><blockquote><p>域名劫持：通过劫持掉域名的 DNS 解析结果，将 HTTP 请求劫持到特定 IP 上，使得客户端和攻击者的服务器建立 TCP 连接，而非和目标服务器直接连接，这样攻击者就可以对内容进行窃取或篡改。在极端的情况下甚至攻击者可能伪造目标网站页面进行钓鱼攻击。一般而言，用户上网的 DNS 服务器都是运营商分配的，所以，在这个节点上，运营商可以为所欲为。例如，访问 <a href="http://jiankang.qq.com/index.html">http://jiankang.qq.com/index.html</a> ，正常 DNS 应该返回腾讯的 ip，而 DNS 劫持后，会返回一个运营商的中间服务器 ip。访问该服务器会一致性的返回302，让用户浏览器跳转到预处理好的带广告的网页，在该网页中再通过 iframe 打开用户原来访问的地址。</p></blockquote><blockquote><p>HTTP劫持&#x2F;直接流量修改：在数据通路上对页面进行固定的内容插入，比如广告弹窗等。在这种情况下，虽然客户端和服务器是直接建立的连接，但是数据内容依然可能遭到野蛮破坏。例如在运营商的路由器节点上，设置协议检测，一旦发现是 HTTP 请求，而且是 html 类型请求，则拦截处理。后续做法往往分为 2 种，1 种是类似 DNS 劫持返回 302 让用户浏览器跳转到另外的地址，还有 1 种是在服务器返回的 HTML 数据中插入 js 或 dom 节点（广告）。</p></blockquote><h1 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h1><p>普通的 HTTP 协议存在 3 个问题：</p><ol><li>泄密。数据明文传输</li><li>篡改。例如植入广告</li><li>假冒。访问的站点是假网站，例如域名劫持、钓鱼网站</li></ol><p>解决泄密的问题可以使用加密。但是<strong>无论采用对称加密还是非对称加密都存在中间人攻击</strong>。对于对称加密，截获了秘钥就可以为所欲为；对于非对称加密，中间人在服务器发送公钥给客户端的时候将其替换为自己的公钥发送给客户端，客户端<strong>对公钥的真实性是毫无感知的</strong>，它下次发送数据的时候采用中间人的公钥进行加密，中间人拿到数据后用自己的私钥进行解密，然后可以修改客户端的数据，用自己的公钥加密后发送给服务器（同样服务器也不知道中间人是假的客户端）。<strong>对于服务器来说，中间人是真正的客户端；而对于客户端来说，中间人是真正的服务器</strong>。</p><p>为了解决中间人攻击，客户端在首次和服务器进行通信的时候，服务器需要展示自己的<strong>证书</strong>，<em>证明自己是真正的服务器</em>。证书是由权威机构（<strong>CA</strong>）颁发的、无法伪造的。客户端拿到证书后就需要验证证书的有效性，还可以拿到证书中服务器的公钥信息用于协商对称秘钥。</p><p>证书颁发了，那怎么防止证书在传输过程中不被篡改呢？万一中间人截获到数字证书，把公钥改成自己的，那岂不是仍然无法保证安全了？这个时候就需要<strong>数字签名</strong>了。</p><p>服务器在向 CA 申请证书的时候，CA 在颁发证书的同时会连同<strong>证书和证书的摘要</strong>（经过CA机构自己的私钥进行加密的）一同发送给服务器。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/get_certificate_from_ca.png" alt="申请证书的流程"></p><p>下图可以看到 CA 给服务器颁发证书的时候是有自己的专属“公章”的。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/effb7a00-d92a-11e9-a0b1-81bf37dbcb06.png" alt="CA 生成对证书生成摘要信息，用私钥进行加密得出数字签名"></p><p>下图所示是知乎的证书,采用了 2048 位的 RSA 算法：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ad5ec0c0-d92b-11e9-a0b1-81bf37dbcb06.png" alt="知乎的证书"></p><p>服务器在与客户端通信的时候，就会将数字证书和数字签名出示给客户端了。客户端拿到数字证书和数字签名后，先通过操作系统或者浏览器内置信任的CA机构找到对应CA机构的公钥对数字签名进行解密，然后采用同样的摘要算法计算数字证书的摘要，如果自己计算的摘要与服务器发来的摘要一致，则证书是没有被篡改过的！这样就防止了篡改！第三方拿不到CA机构的私钥，也就无法对摘要进行加密，如果是第三方伪造的签名自然也在客户端也就无法解密，这就防止了伪造！所以数字签名就是通过这种机制来保证数字证书被篡改和被伪造。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/digital_signature.png" alt="客户端和服务器协商秘钥的流程"></p><p>这里需要注意一点，一个是 CA 机构的公钥，内置在客户端，用来解密数字签名！另一个是目标服务器的公钥，在数字证书内容里，用来协商对称密钥！</p><p>其实 HTTPS 的出现就是结合了上面的手段:客户端请求服务器的证书（公钥），服务器返回证书，客户端拿到这个证书后校验（通过内置的CA），校验成功后生成一个随机数，然后使用公钥对随机数进行加密后发送，服务器收到后使用自己的私钥解密。接下来双方的通信都是基于该随机数的对称加密。</p><h1 id="HTTPS-的各个步骤"><a href="#HTTPS-的各个步骤" class="headerlink" title="HTTPS 的各个步骤"></a>HTTPS 的各个步骤</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/https_arch.png" alt="https 的各个阶段"></p><p>前置条件：服务器正确配置了数字证书（可以自己制作，也可以向组织申请）。自己颁发的证书需要客户端验证通过（地址栏警告，例如早期的 12306），才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。<strong>这套证书其实就是一对公钥和私钥</strong>（创建 https 服务器需要指定证书(公钥)和私钥）。</p><ol><li>客户端发起 HTTPS 请求。</li><li>服务器向客户端传送证书。这里的证书其实是密钥对中的公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</li><li>客户端验证证书，这部分工作是由客户端的 TLS 来完成的。如果证书校验不通过则弹出警告，提示证书存在问题；有效则生成一个随机数，使用证书（服务器公钥）对这个随机值进行加密。<ol><li><strong>验证证书链</strong>：检查证书是否由受信任的证书颁发机构(CA) 签发。客户端会逐层验证证书链(服务器证书-中间证书-根证书)，如果链中的任何一个证书无效或者不受信任，则验证失败。</li><li><strong>根证书信任库</strong>：浏览器&#x2F;OS 内置了一个受信任的根证书列表(Trust Store)。如果证书链的根证书不在信任列表中，则验证失败。</li><li><strong>验证有效期</strong>：证书已过期和尚未生效都验证失败。<code>[Not Before, Not After]</code></li><li><strong>验证域名</strong>：检查证书中的 SAN 或者 CN 是否和请求的域名匹配。</li><li><strong>检查证书是否吊销</strong>：通过证书吊销列表(CRL) 或者 OSCP(在线证书状态协议) 查询证书状态。</li><li><strong>签名验证</strong>：客户端使用证书链中的上级证书的公钥验证证书的签名。</li></ol></li><li>传送加密信息。这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li>服务端解密信息。服务端用私钥解密后，得到了客户端传过来的随机值。这个随机值就是对称加密的秘钥。</li><li>传输加密后的信息。服务器发送对称加密的内容</li><li>客户端解密信息。客户端用之前发送给服务器的秘钥进行解密</li></ol><h2 id="客户端对证书签名进行验证"><a href="#客户端对证书签名进行验证" class="headerlink" title="客户端对证书签名进行验证"></a>客户端对证书签名进行验证</h2><ul><li>证书的签名是由证书颁发机构（CA）使用自己的私钥对证书内容进行加密生成的。</li><li>客户端使用 CA 的公钥解密签名，得到证书的哈希值。</li><li>客户端重新计算证书内容（DER 编码部分，不包含签名部分）的哈希值（签名算法在证书中有），并与解密得到的哈希值进行对比。</li><li>如果两者一致，说明证书由未被篡改并且可信的 CA 签发。</li></ul><h1 id="针对-HTTPS-的一些实践"><a href="#针对-HTTPS-的一些实践" class="headerlink" title="针对 HTTPS 的一些实践"></a>针对 HTTPS 的一些实践</h1><h2 id="编写-https-服务器"><a href="#编写-https-服务器" class="headerlink" title="编写 https 服务器"></a>编写 https 服务器</h2><p>首先使用 openssl 生成证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout localhost-privkey.pem -out localhost-cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>out 指定证书文件（主要是公钥，还包含其他元数据，例如有效期、颁发者）, keyout 指定私钥文件，可以从证书文件中提取出公钥。我们可以<em>粗浅</em>认为 cert.pem 就是公钥。</p><p>接下来使用证书文件和私钥文件创建 HTTPS 服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.mjs</span></span><br><span class="line"><span class="keyword">import</span> https <span class="keyword">from</span> <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前文件路径</span></span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(__filename);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取证书和私钥</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;localhost-privkey.pem&#x27;</span>)),</span><br><span class="line">  <span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;localhost-cert.pem&#x27;</span>)),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 HTTPS 服务器</span></span><br><span class="line"><span class="keyword">const</span> server = https.<span class="title function_">createServer</span>(options, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello, HTTPS World!\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">443</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HTTPS server running on https://localhost:443&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来在浏览器中访问 <code>https://localhost:443</code>，就可以看到页面了。可以使用 curl 命令查看发送 https 请求的详细信息：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/curl-https.png" alt="使用curl查看发送 https 请求的详细信息"></p><h2 id="为什么-Charles-能够抓取-HTTPS-包"><a href="#为什么-Charles-能够抓取-HTTPS-包" class="headerlink" title="为什么 Charles 能够抓取 HTTPS 包"></a>为什么 Charles 能够抓取 HTTPS 包</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/charles-https.png" alt="使用 Charles 抓取 HTTPS 包"></p><p>HTTPS 抓包的原理还是挺简单的，简单来说，就是 Charles 作为“中间人代理”，拿到了服务器证书公钥和 HTTPS 连接的对称密钥，前提是<strong>客户端选择信任并安装Charles的CA证书</strong>，否则客户端就会“报警”并中止连接。这样看来，HTTPS 还是很安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 网络 </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2025/01/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2025/01/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>精确判断不存在，但是可能会<em>误判一个不在集合中的元素为存在</em>（即：假阳）</li><li>不支持删除元素（几个 hash 函数计算出来的下标可能别的 key 也用到了）</li></ul><p>总结来说就是：判断不存在的时候一定不存在，判断存在的时候大概率存在。</p><p>误判率可以通过调整参数来降低，但是无法完全消除。</p><h1 id="数据结构的组成"><a href="#数据结构的组成" class="headerlink" title="数据结构的组成"></a>数据结构的组成</h1><p>布隆过滤器由一个 bitSet 和一组 hash 函数组成，是一种空间效率非常高的概率算法和数据结构。在初始化的时候，bitSet 的每一位被初始化为 0，同时会定义一组 hash函数，例如有 3 组 hash 函数，hash1，hash2，hash3.</p><h1 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h1><p>当我们要写入一个值时，过程如下，以“jionghui”为例：</p><ol><li>首先将“jionghui”跟3组 Hash 函数分别计算，得到 bitSet 的下标为：1、7、10。</li><li>将 bitSet 的这3个下标标记为1。</li></ol><p>假设我们还有另外两个值：java 和 diaosi，按上面的流程跟 3组 Hash 函数分别计算，结果如下：</p><ul><li>java：Hash 函数计算 bitSet 下标为：1、7、11</li><li>diaosi：Hash 函数计算 bitSet 下标为：4、10、11</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/bloom-filter1.png" alt="布隆过滤器的写入流程"></p><h1 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h1><p>当我们要查询一个值时，过程如下，同样以“jionghui”为例：</p><ol><li>首先将“jionghui”跟3组 Hash 函数分别计算，得到 bitSet 的下标为：1、7、10</li><li>查看 bitSet 的这 3 个下标是否都为 1，如果这 3 个<em>下标不都为 1，则说明该值必然不存在</em>，如果这 3 个下标都为 1，只能说明<em>可能</em>存在，并不能说明一定存在</li></ol><p>其实上图的例子已经说明了这个问题了，当我们只有值“jionghui”和“diaosi”时，bitSet 下标为1的有：1、4、7、10、11。当我们又加入值“java”时，bitSet 下标为1的还是这5个，所以当 bitSet 下标为1的为：1、4、7、10、11 时，我们无法判断值“java”存不存在。</p><p>其根本原因是，不同的值在跟 Hash 函数计算后，可能会得到相同的下标，所以某个值的标记位，可能会被其他值给标上了。这也是为啥布隆过滤器只能判断某个值可能存在，无法判断必然存在的原因。但是反过来，如果该值根据Hash函数计算的标记位没有全部都为1，那么则说明必然不存在。</p><p>降低这种误判率的思路也比较简单：</p><ol><li>加大 bitSet 的长度，这样不同的值出现“冲突”的概率就降低了，从而误判率也降低。</li><li>提升 Hash 函数的个数，Hash 函数越多，每个值对应的 bit 越多，从而误判率也降低。</li></ol><h1 id="HashMap-和布隆过滤器"><a href="#HashMap-和布隆过滤器" class="headerlink" title="HashMap 和布隆过滤器"></a>HashMap 和布隆过滤器</h1><p>数据量小的时候使用 hashmap 一点问题也没有，而且没有误判，非常完美。但是当数据量上去之后布隆过滤器的空间优势非常明显，key 占用的空间越大，布隆过滤器的优势就越明显。</p><p>guava 中的布隆过滤器在默认情况下，误判率接近 3%，使用 5 个 hash 函数。</p><blockquote><p>空间和时间方面具有巨大优势，同时因为hash函数之间相互没有关系，方便由硬件来并行实现。布隆过滤器本身不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p></blockquote><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><ul><li>google 的分布式数据库 bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘 IO 的查找次数</li><li>squid 网页代理缓存服务器也使用了布隆过滤器</li><li>chrome 浏览器使用布隆过滤器加速安全浏览服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch 学习</title>
      <link href="/2024/05/29/PyTorch%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/29/PyTorch%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>入门容易，代码浅显易懂，动态图。 </p><h1 id="ML-中的一些专有名词"><a href="#ML-中的一些专有名词" class="headerlink" title="ML 中的一些专有名词"></a>ML 中的一些专有名词</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ml-bias-variance.png" alt="模型的偏差和方差"></p><ul><li>偏差(Bias): 模型在样本上的输出与真实值之间的误差 —— 模型本身的精确度</li><li>方差(Variance): 模型每一次的输出结果与模型输出期望之间的误差 —— 模型的稳定性</li></ul><h2 id="防止过拟合的方法"><a href="#防止过拟合的方法" class="headerlink" title="防止过拟合的方法"></a>防止过拟合的方法</h2><ul><li>补充数据集（数据增强）</li><li>减少模型参数</li><li>Dropout</li><li>Earlystopping</li><li>正则化 &amp; 稀疏化（模型结构变得更简单的一种手段）</li></ul><h2 id="防止欠拟合的方法"><a href="#防止欠拟合的方法" class="headerlink" title="防止欠拟合的方法"></a>防止欠拟合的方法</h2><ul><li>加大模型参数</li><li>减少正则化参数</li><li>更充分的训练</li></ul><p>在实际的 ML 中可能解决过拟合是更常见的需求。</p><h1 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h1><p>标量是 0 维张量，向量是 1 维张量，矩阵是 2 维张量。</p><h1 id="PCA-与特征值分解"><a href="#PCA-与特征值分解" class="headerlink" title="PCA 与特征值分解"></a>PCA 与特征值分解</h1><p>将 n 维特征映射到 k 维上（投影矩阵），这 k 维是全新的正交特征，也被称为主成分，是在原有的 n 维特征的基础上重新构造出来的 k 维特征。</p><p>PCA 算法的优化目标：</p><ul><li>降维后同一维度的方差最大</li><li>不同维度的相关性为 0</li><li>协方差矩阵</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Visdom: 提供了大多数科学计算的可视化工具，支持 PyTorch、Torch、Numpy</li><li>Torchvision: 独立于 PyTorch 的关于图片操作的一些方便的工具库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3学习</title>
      <link href="/2023/12/03/Python3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/03/Python3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>注意 py 中声明只有一个元素的元组的时候应该写成 <code>t = (1,)</code> 而不是 <code>(1)</code>。后者会被解释器解释为变量而非元组。</p><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><p>和 java 有着显著区别，python3 的类允许多继承。多继承带来了菱形问题(Diamond Problem):如果多个父类继承同一个基类，可能导致方法调用冲突。如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().method()  <span class="comment"># 调用 A.method()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().method()  <span class="comment"># 调用 A.method()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().method()  <span class="comment"># 按 MRO 调用 B → C → A</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.method() <span class="comment"># A C B D</span></span><br><span class="line"><span class="built_in">print</span>(D.__mro__) <span class="comment"># (D, B, C, A, object)</span></span><br></pre></td></tr></table></figure><p>Python 3 使用 C3 线性化算法（MRO）解决冲突。在上面的例子中：</p><ol><li>调用顺序：D → B → C → A（B 优先于 C，因为 class D(B, C) 里 B 在前）。</li><li>如果 B 没有 method()，则调用 C 的 method()。</li></ol><p>上面的例子中 A 虽然被继承了 2 次，但是并不存在调用多次的问题。</p><p>多继承可以很方便实现 mix-in 模式。</p><h1 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h1><p><code>__slots__</code>的目的是限制当前类所能拥有的属性，避免因为外部属性的操作导致类属性越来越难以管理。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, score</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="variable language_">self</span>.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="comment"># s.age = 10  # AttributeError: &#x27;Student&#x27; object has no attribute &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h1><p><code>__call__</code>方法可以让一个类的实例像函数一样被调用。当实例后面加括号时，就会调用 <code>__call__</code>方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, count = <span class="number">10</span></span>):</span><br><span class="line">        res = []</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">            res.append(a)</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> res    </span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">10</span>)) <span class="comment"># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>可以实现延迟计算：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_sum</span>(<span class="params">list_</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lazy_sum</span>():</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(list_)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">performance</span>(<span class="params">unit</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perf_decorator</span>(<span class="params">f</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            t1 = time.time()</span><br><span class="line">            r = f(*args, **kwargs)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            t = (t2 - t1) * <span class="number">1000</span> <span class="keyword">if</span> unit == <span class="string">&#x27;ms&#x27;</span> <span class="keyword">else</span> (t2 - t1)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;call &#123;&#125;() in &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(f.__name__, t, unit))</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> perf_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance(<span class="params"><span class="string">&#x27;ms&#x27;</span></span>)</span></span><br><span class="line"><span class="comment"># @performance(&#x27;s&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="comment"># sleep 1 second</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票投资从入门到放弃</title>
      <link href="/2023/09/26/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
      <url>/2023/09/26/%E8%82%A1%E7%A5%A8%E6%8A%95%E8%B5%84%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你的气质里藏着你读过的那些书</p></blockquote><h1 id="股票新手如何入门"><a href="#股票新手如何入门" class="headerlink" title="股票新手如何入门"></a>股票新手如何入门</h1><blockquote><p>不管是过去还是未来，赚取真正财富的唯一方式，仍然是天赋、勤俭、幸运，再加上艰苦的劳动。</p></blockquote><p>股票交易不是追求利润的游戏，而是管理和控制风险的游戏。</p><p>看一家企业的股票有没有投资价值，不单是看它有没有赚钱这么简单，还要看它是不是能稳定地持续赚钱呢，是不是越赚越多，是不是在持续增长。</p><h1 id="为什么投资股票很难学"><a href="#为什么投资股票很难学" class="headerlink" title="为什么投资股票很难学"></a>为什么投资股票很难学</h1><ul><li>过分高估短期回报。理性人都不应该过分高估自己的运气，想通过短线交易，连续多次获利是低概率、不现实的事情。越是短期，价格就会越呈现随机性和不可预测性。</li><li>赚一笔就走的心态。对股票带着一种赌一把的心态，而不是把它当成一门漫长持久的生意去用心经营。所以很难多人会出现杠杆交易来放大收益。</li><li>以为有预测市场的绝招。</li></ul><p>短期随机性，长期趋势性。100 天内的买进和卖出就是短线交易，低于 10 天的买进和卖出就是超短线交易了。</p><h1 id="财务分析"><a href="#财务分析" class="headerlink" title="财务分析"></a>财务分析</h1><h2 id="利润表"><a href="#利润表" class="headerlink" title="利润表"></a>利润表</h2><h3 id="营业收入高不等于产品卖得多"><a href="#营业收入高不等于产品卖得多" class="headerlink" title="营业收入高不等于产品卖得多"></a>营业收入高不等于产品卖得多</h3><p>利润表虽然是一张关于公司赚钱还是赔钱的报表？但是它上面的数字并不一定是现金。</p><p>很多公司都不是使用“现金收入”来记账的，而是采用“应计收入”。</p><p>应计收入：产品交付给客户后，客户不一定马上付款，而是几个月甚至半年后才付款。但是不管有没有收到款，会计师在处理这笔交易记账的时候，就提前计入到当期的营业收入中。</p><p>现金收入：只有客户交付货款现金后，才计入当期的营业收入中。</p><p>因此，利润表上的营业收入并不是 100% 的现金，而是提前预估的。万一因为产品质量问题客户要求退货或折价，在下一期的利润表中都会被更改。所以营业收入高不一定意味着产品卖得多。</p><h3 id="净利润高不等于企业赚得多"><a href="#净利润高不等于企业赚得多" class="headerlink" title="净利润高不等于企业赚得多"></a>净利润高不等于企业赚得多</h3><p>很多人看利润表往往只看“净利润”，就认为公司赚了多少钱。</p><p>从上面的应计收入我们可以知道，其实净利润也不等于现金，净利润也只是账面上的预估。另外，一些不良公司为了让账面漂亮，往往还会在净利润上做手脚搞假账。</p><p>一些不良公司，会制造一些“假交易”，在账面上抬高营业收入，或者在资产减损折旧费用上做手脚，从而变相抬高净利润。</p><p>因此，我们在看财报的时候，不能只看某一季或某一年，而是要看连续5年的报表，才能看出是否存在财务问题，推测出公司的真实状况。</p><p>所以，我们以后在被媒体上再看到“××公司营业额创新高”、“××公司净利创新高”等一类的新闻，千万不要被误导了。</p><h2 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h2><blockquote><p>资产负债表和损益表的一个区别在于，损益表是“时间段”的概念，比如一季报的损益表，指的是从 1&#x2F;1 至 3&#x2F;31 最后一天，这段时间是赚钱还是亏钱；而资产负债表是“当天余额”的概念，比如一季报的资产负债表，就是指 3&#x2F;31 最后一天结存的数字。</p></blockquote><p><strong>资产 &#x3D; 负债 + 股东权益</strong></p><p>打个比方，我买了一套房，房子就是我的“资产”。买房的钱从哪里来的呢？（资产的来源）其中 80% 是和银行借的按揭贷款，需要慢慢还的，这部分就是“负债”。还有 20% 是我自己攒的钱，那这部分钱就是“股东权益”。假如有一天，我把银行贷款还完了，那就没有负债了，房子这个资产，就完全 100% 属于我（股东权益）了。或者有一天，房子增值了 50 万，那么我（股东权益）相应的，也就增加了 50 万。</p><p>资产负债表中，是以资产变现的难易程度，由上到下排列的，越容易变现的资产排在前面，越难变现的资产排在后面。<strong>资产越容易变现，就说明它的流动性越高</strong>。一年内可以到期变现的资产，都归为流动资产。超过一年才可以变现，或者变现难度极大的资产，都归为非流动资产。</p><p><strong>一般而言，企业的流动资产当然越多越好，流动资产多，企业手头现金充裕，抵御经济风险的能力就越强。</strong></p><h3 id="错误的负债观念：以短支长"><a href="#错误的负债观念：以短支长" class="headerlink" title="错误的负债观念：以短支长"></a>错误的负债观念：以短支长</h3><p>有很多企业之所以破产，除了找不到客户外，一个最主要的原因，就是在财务管理中以短支长。这些企业，常为了方便贪一时之快，去借一些短期的高利贷或外债，去支付机械设备或厂房等长期投资。钱的来源是短期负债，但是用途却是长期资产，最终一定是偿还不起，发生财务危机，导致破产。就像我们使用的信用卡，本身算是短期负债，用它去超市购物，作为短期支出是可以的。但是很多人却用它去支付长期的生活所需（买车、买房），然后每个月又另外借钱还债，这就是一个以短支长的错误理财观念。</p><h3 id="正确的负债观念：以短支短，以长支长"><a href="#正确的负债观念：以短支短，以长支长" class="headerlink" title="正确的负债观念：以短支短，以长支长"></a>正确的负债观念：以短支短，以长支长</h3><p>不要等到缺钱的时候，才去借钱。银行都是晴天借伞，雨天收伞，当我们财务困难的时候，银行是不会借钱给我们的。一些中小企业往往抱怨银行贷款困难，才迫使转而寻求短期高利贷。所以正确的做法应该是，当我们财务状况良好的时候，就要多向银行借钱，以备不时之需的同时，累计良好的信用。</p><h3 id="企业如何分配利润盈余"><a href="#企业如何分配利润盈余" class="headerlink" title="企业如何分配利润盈余"></a>企业如何分配利润盈余</h3><p>公司经营得不错，赚了钱，利润分配常用的有以下几种：</p><ol><li>保留现金：保守点，以备不时之需</li><li>投资：增加设备，提高产能，扩大生产</li><li>并购：收购其他企业</li><li>还款：还清银行债务</li><li>分红：把利润分配给股东</li></ol><p>五种分配方式都没什么问题，而且作为投资者，更多的会选择第 5 项，分红。但事实上，很少有企业会把绝大部分利润用以分红。比较正确的做法是选择 1 和 4。首先把银行的到期债务还清，保持良好信誉，避免景气不佳时银行雨天收伞，借不到钱。然后，就是尽可能保留较多的现金。</p><p>一些效益高的优秀企业，手里都会留有大量的现金储备。例如，现金占总资产比例中，贵州茅台常年在 45% 以上；伊利股份为 35%；恒瑞医药为 30%。2008年的金融海啸，从大的时间周期看，实际上只是股市长期上涨中一个调整波动，但这一波动，全世界倒掉了数以万计的企业，倒闭的原因无一例外都是因为现金不足。手握现金，无论何时都可以买到想要的资产；但手握大量资产，却不一定能随时换成足够的现金，让公司存活下去。此外，手上有足够多的现金，财务财务状况良好时，可以向银行借到更多的长期贷款，做到以长支长。万一不幸今后财务状况不佳时，这笔以长支长，能让企业争取到缓冲的时间，度过财务危机。</p><p>经营企业是一个长期的过程，作为投资者，我们都不希望买入一直波动剧烈，随时可能倒闭的公司股票。而手中握有大量现金的企业，往往会比其他现金储备不足的企业经营得更稳健，活得更长。</p><h3 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h3><p>记录了企业的资金动向，钱从哪里来？用到了哪里去？这是了解企业经营状况最重要的一张表。现金流量表上的数值，则是用期末值减期初值作为结果，它不包含预估的数据，实打实的反映出现金是真的增加还是减少了，所以可以说是观察和了解企业最透明的一张报表。</p><blockquote><p>如果一家公司宣称获利，往往指的是净利润大于 0，而我们还要看营业活动现金流量是否也大于 0，才能确认它是不是真的获利。营业活动现金流量和净利润的变化趋势是否相同。如果趋势的相关度很高，说明公司的经营状况是稳定的；如果趋势南辕北辙，说明公司或许潜藏这很大问题。</p></blockquote><h1 id="有关股市的几个错误认知"><a href="#有关股市的几个错误认知" class="headerlink" title="有关股市的几个错误认知"></a>有关股市的几个错误认知</h1><h2 id="股市中蒸发的钱去哪里了"><a href="#股市中蒸发的钱去哪里了" class="headerlink" title="股市中蒸发的钱去哪里了"></a>股市中蒸发的钱去哪里了</h2><p>股市是虚拟资本。股市的行情上涨其实并不创造财富，只是后来进场的人愿意以更高的价格买进股票，所以会不断补充<em>再分配财富</em>。参见:<a href="https://www.zhihu.com/question/21595133">股市蒸发的钱都去哪里了</a> —— 钱没有凭空消失，只是换了口袋。</p><h2 id="A股中还存在庄家么"><a href="#A股中还存在庄家么" class="headerlink" title="A股中还存在庄家么"></a>A股中还存在庄家么</h2><p>A股中已经由庄家控制发展成了机构博弈，这也就是我们常说的主力（银行基金、社保基金、企业年金、私募、保险）。</p><h2 id="市盈率的陷阱"><a href="#市盈率的陷阱" class="headerlink" title="市盈率的陷阱"></a>市盈率的陷阱</h2><p>市盈率过低，一方面说明资本市场看衰其未来成长性前景（例如银行股），但一方面也有可能意味着股价被低估。苹果与谷歌和 facebook 相比，苹果市盈率低的过于明显了，其股价存在远低于其内在价值的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑</title>
      <link href="/2022/07/14/programming-pearls/"/>
      <url>/2022/07/14/programming-pearls/</url>
      
        <content type="html"><![CDATA[<h1 id="位图排序"><a href="#位图排序" class="headerlink" title="位图排序"></a>位图排序</h1><ul><li>输入：一个包含n个正整数的文件，其中每个正整数都小于n，在这里n &#x3D; 10^7，其中n个整数都是不可重复的。</li><li>输出：以升序排列的整数列表</li><li>约束：最多1MB内存，无限内存，时间最多几分钟，10s就可认为不需要优化了。</li></ul><p>思考：一个整数占用4字节，10^7的整数占用的内存是4*10^7.一次性读取到内存中显然是不可能的。所以我们可以使用10^7&#x2F;2^20 &#x3D; 39趟归并排序，也就需要40次的IO操作，IO无疑是瓶颈。</p><blockquote><p>我们可以使用10位长的字符串表示一个所有元素小于10的非负整数集合（集合3大特性），如：{1,2,3,5,8}可表示为：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0111010010</span> # 如果对应的位是<span class="number">1</span>表示处于该集合</span><br></pre></td></tr></table></figure><p>以上的方法非常巧妙，本来需要4个字节表示的数，仅仅通过一个位就实现了，空间瞬间剩下的几十倍，有不有？</p><p>这样就可以使用10^7个位表示10^7个整数，占用空间为10^7&#x2F;2^20 &#x3D; 9.53M。python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment"># 生成10^7个乱序整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">RANGE = <span class="number">10000000</span></span><br><span class="line">arr = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(RANGE)]</span><br><span class="line">random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;../test/input/bitSort.input&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">f.write(<span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;generator input file success!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/use/bin python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment"># 位排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.init set to empty</span></span><br><span class="line">RANGE = <span class="number">10000000</span></span><br><span class="line">arr = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(RANGE)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.insert each present elements into the set</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;../test/input/bitSort.input&#x27;</span>):</span><br><span class="line">num = <span class="built_in">int</span>(line)</span><br><span class="line">arr[num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.write sorted ouput</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;../test/output/bitSort.output&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(RANGE):</span><br><span class="line"><span class="keyword">if</span> arr[i] == <span class="number">1</span>:</span><br><span class="line">f.write(<span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;arrar is sorted and generator output file success! and take time:&#x27;</span> + <span class="built_in">str</span>(end - start) </span><br></pre></td></tr></table></figure><blockquote><p><em>位图数据结构</em>：描述了一个有限定义域内的稠密集合，其中每个元素最多出现1次并且没有和其他任何数据与该元素关联。</p></blockquote><h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><p>可以跳出局部最优解找到整体最优解<br>更快的运行速度<br>机器学习领域中许多算法都要用到随机的思想：随机森林，蒙特卡洛树</p><h1 id="数据规模的概念"><a href="#数据规模的概念" class="headerlink" title="数据规模的概念"></a>数据规模的概念</h1><p>在1秒内解决问题</p><p>N^2 处理10^4<br>N 处理10^8<br>NlogN 处理10^7</p><p>许多主流语言使用抛出异常的方式处理错误的，但是可能传统的返回值可能更好。抛出异常的主要好处是可以将业务代码和错误处理代码分开，但是无形中改变了控制流。</p><p>office软件如此臃肿的原因是它的文件格式本身就是一个文件系统，二进制表示。相比标准的html文档少了lexing（词法分析）和parser（解析）的过程，速度提高了几个数量级。</p><p>a&#x3D;i*5在C++中可能不是表示乘法的意思，因为可能运算符重载。等号和乘号都可能重载。</p><p>软件的原则：一个对象具有setter就一定需要提供getter。</p><p>标记清除垃圾回收算法基于有向图的多点可达性，能到达的对象被标记，从而回收不带标记的对象。对有向无环图进行dfs可以实现拓扑排序。而检测一个有向图中是否有环也可以用dfs。</p><p>java泛型擦除：早期的java没有泛型，所有的泛型将在运行时擦除。也就是说运行时List<Integer>和List<String>没有区别。C++中通过模板替换的方法实现泛型，java的泛型为了兼容老的系统，在运行时会将泛型擦除。也就是说在运行的时候：List,List<String>,List<Integer>没有区别。List<Integer>不是List<Object>，前者转后者需要List<Object> objList &#x3D; new ArrayList<Object>(intList)。</p><p>K路归并可以使用优先队列。</p><p>线程池由阻塞队列和线程两部分组成。</p><p>marker interface。一个空接口，例如序列化接口。</p><p>数据可靠性的保证：WAL机制（Write Ahead Log，数据过来之后先写日志）</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><blockquote><p>进程（正在运行的程序的实例）是资源分配的最小单位，线程是 CPU 调度的最小单位。</p></blockquote><p>进程和线程都是操作系统需要管理的 2 个对象。32 位和 64 位操作系统的区别就是在寻址空间。32 位操作系统 2^32&#x3D;4G, 则每个进程有4G 的可用内存空间，但是并不是代表分配给了 4G 内存。OS 是在程序和具体硬件之间的一个中间层次，我们在程序里看到的是各个进程自己的寻址空间，每个进程自己的内存都是独立的。但文件和网络句柄是所有进程共有的。OS 实际运行的是线程，进程只是线程的容器，线程里面有 3 个主要部分：调用栈（保存每次调用的参数和返回地址，函数内部的局部变量）、PC（程序计数器，下一条执行指令的地址，放在内存中，每个线程都各自有一个PC）和 TLS（Thread Local Storage,存放各个线程独有的数据）。现代计算机大多数是存储程序型的：数据和程序是存储在同一片内存中的，内存中既有所有的变量，又有程序，因此 PC 指针就是指向内存的。缓冲区溢出的漏洞实例：例如有个地方是输入用户名的，本来是用来存数据的地方，黑客把用户名输入得特别长（超过了我们为用户名分配的缓冲区，一直往后写写到存储程序的那部分内存中去了，从而黑客可以将他要运行的代码通过这种框植入进来，当然防止的方法是检查用户名长度不要超过缓冲区大小）</p><h2 id="存储体系"><a href="#存储体系" class="headerlink" title="存储体系"></a>存储体系</h2><p>计算机存储体系具有层次化。Google搜索之所以快的原因是它把大多数有用的网页放到了内存中，访问量非常低的才会放在硬盘中。OS是如何寻址的（给定一个地址，如何在层次性的存储结构中找到需要的数据）：寻址空间：每个进程的中指针能够取到的地址的范围，和我们机器上到底装了多少物理内存是无关的，每个进程有自己独立的寻址空间（32位对应4G，如果我们的电脑是16G内存但是装了32位的OS，每个进程最多只能用到4G，因为指针大小只有32位，只能访问4G内存。64位OS，寻址空间为10^19Bytes）。64位的JVM可以使用更大内存，需要重新编译。</p><p>在一个运行良好的程序中，我们需要的数据可以直接在物理内存中找到，从而复制到寄存器，但是如果物理内存使用量过多的话就会发生频繁分页（找到物理内存中长时间不用的数据，将虚拟内存（硬盘上）中的一个页放入物理内存），从而大幅降低系统性能。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/os-program-location.png" alt="程序寻址示意图"></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>用于维护发送方和接收方的缓冲区，解决TCP传输中网络不可靠的问题（丢包、重复包、包出错、包乱序）。在没有滑动窗口的前提下保证发送方到接收方的包每个都能收到并且能按次序，就需要发送方没法送一个包，接收方接收到之后返回一个确认包。这样网络的吞吐量会非常低。连续发送多个包而无需一个个确认，这样吞吐量虽然提高了，但是链路就变得不可靠了，所以依靠滑动窗口维护发送方和接收方的缓冲区。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架-Vue</title>
      <link href="/2022/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/"/>
      <url>/2022/04/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-Vue/</url>
      
        <content type="html"><![CDATA[<h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p>vue3 中只需要如下的代码即可实现表单联动：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> text = <span class="title function_">ref</span>(<span class="string">&#x27;default&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>content: &#123;&#123;text&#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下是一个响应式的简单实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> obj = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;content&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>).<span class="property">value</span> = newValue</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>).<span class="property">innerHTML</span> = newValue</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> obj.<span class="property">content</span> = e.<span class="property">target</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心是使用 <code>Object.defineProperty</code> 函数实现双向数据绑定，触发组件的重新渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">__fn</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察某个对象的所有属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">let</span> internalValue = obj[k]</span><br><span class="line">        <span class="keyword">let</span> funs = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, k, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// 记录是哪个函数在用我 =&gt; vue 依赖收集</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">global</span>.<span class="property">__fn</span>) &#123;</span><br><span class="line">                    funs.<span class="title function_">add</span>(<span class="variable language_">global</span>.<span class="property">__fn</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> internalValue</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">set</span>(<span class="params">v</span>)&#123;</span><br><span class="line">                internalValue = v</span><br><span class="line">                <span class="comment">// 自动调用依赖该属性的函数</span></span><br><span class="line">                <span class="comment">// 执行用过我的函数 =&gt; vue 派发更新</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> funs) &#123;</span><br><span class="line">                    <span class="title function_">fn</span>()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">autorun</span> = fn =&gt; &#123;</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">__fn</span> = fn</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">__fn</span> = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>, obj.<span class="property">age</span>)</span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;重新渲染 name&#x27;</span>,obj.<span class="property">name</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">autorun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;重新渲染 age&#x27;</span>,obj.<span class="property">age</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br></pre></td></tr></table></figure><h1 id="Vue-2-0-和-3-0-的区别"><a href="#Vue-2-0-和-3-0-的区别" class="headerlink" title="Vue 2.0 和 3.0 的区别"></a>Vue 2.0 和 3.0 的区别</h1><ol><li>移除了过滤器，推荐使用计算属性和方法。</li></ol><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p><code>router-view</code> 相当于占位的作用，<code>router-link</code> 中匹配的路由内容会在 <code>router-view</code> 中显示。通常将 <code>router-view</code> 放在 <code>keep-alive</code> 中。我们常见的有下面的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 类型体操</title>
      <link href="/2022/04/02/Typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"/>
      <url>/2022/04/02/Typescript%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>愿你的努力被世界看到！</p></blockquote><p>优先使用接口（<code>interface</code>）定义对象结构，类型别名（<code>type</code>）用于联合类型或复杂类型。</p><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>在 py 中元组是固定类型，固定长度的，但是在 ts 中只固定了类型，仍然通过 <code>push</code> 等方法来改变（设计如此）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t</span>:[<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line"><span class="comment">// t[0] = &#x27;yes&#x27; // 报错</span></span><br><span class="line"><span class="comment">// t[2] = 4 // 报错</span></span><br><span class="line">t.<span class="title function_">push</span>(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// t.push(false) // 报错，不兼容 boolean </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t) <span class="comment">// [ 1, &#x27;content&#x27;, 100 ]</span></span><br></pre></td></tr></table></figure><p>ts 4.0 新增加了命名元组，可以增强代码的可读性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名元组</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserRecord</span> = [<span class="attr">id</span>: <span class="built_in">number</span>, <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">email</span>: <span class="built_in">string</span>, <span class="attr">createdAt</span>: <span class="title class_">Date</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">users</span>: <span class="title class_">UserRecord</span>[] = [</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;&lt;EMAIL&gt;&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;&lt;EMAIL&gt;&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;&lt;EMAIL&gt;&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [id, name, email, createdAt] <span class="keyword">of</span> users) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(id, name, email, createdAt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h1><p>不保证类型，但是能保证类型安全。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">r</span>:<span class="built_in">unknown</span> = <span class="number">1</span></span><br><span class="line">r = <span class="number">2</span></span><br><span class="line">r = <span class="literal">false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br><span class="line"><span class="comment">// r() 报错</span></span><br><span class="line"><span class="comment">// console.log(r.toString()) // 报错</span></span><br></pre></td></tr></table></figure><p>如果使用 <code>any</code> 上面的代码就不会报错。<code>unknown</code> 需要做进一步的判断：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">r</span>:<span class="built_in">unknown</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// unknown 类型不能直接调用，需要判断类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> r === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title function_">r</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="never"><a href="#never" class="headerlink" title="never"></a>never</h1><p><code>never</code> 表示永远不存在的值的类型，比如抛出异常或者死循环。表示永远不存在的值的类型，是任何类型的子类型，可以赋值给任何类型，除 <code>never</code> 本身外，没有类型可以赋值给 <code>never</code>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：never可以赋值给任何类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="built_in">string</span> = a; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：其他类型不能赋值给never</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">never</span> = <span class="number">123</span>; <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throwError</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">whileTrue</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用于类型保护中的穷尽检查：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span> | <span class="string">&quot;triangle&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params"><span class="attr">shape</span>: <span class="title class_">Shape</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span> ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="comment">// 如果Shape类型扩展但忘记处理新类型，这里会报错</span></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">exhaustiveCheck</span>: <span class="built_in">never</span> = shape;</span><br><span class="line">      <span class="keyword">return</span> exhaustiveCheck;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><p>在定义函数的时候推荐将函数的参数和返回值单独用一个 type 来进行定义，这样函数的定义可以做到复用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fun</span> = <span class="function">(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fun1</span>: <span class="title class_">Fun</span> = <span class="function">() =&gt;</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fun3</span>: <span class="title class_">Fun</span> = <span class="function">() =&gt;</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h1><p>虽然 type 也能完成定义，但是在定义对象类型或者类的结构的时候 interface 更适合。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type Obj = &#123; a: string, b: boolean &#125;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Obj</span> &#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">boolean</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj1</span>: <span class="title class_">Obj</span> = &#123;<span class="attr">a</span>:<span class="string">&#x27;hello&#x27;</span>, <span class="attr">b</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a>type 和 interface 的区别</h1><p>交叉类型 <code>&amp;</code>，联合类型 <code>|</code></p><table><thead><tr><th>特性</th><th>interface</th><th>type</th></tr></thead><tbody><tr><td>本质</td><td>结构定义</td><td>类型别名</td></tr><tr><td>扩展方式</td><td>可使用 <code>extends</code> 关键字扩展</td><td>一般不能直接扩展，但可通过交叉类型<code>&amp;</code>间接扩展</td></tr><tr><td>重名处理</td><td>重名时会自动合并声明</td><td>重名会报错</td></tr><tr><td>与类的关系</td><td>可被类实现</td><td>不能被类实现</td></tr><tr><td>支持类型</td><td>主要用于对象类型，不支持联合类型和交叉类型</td><td>支持联合类型和交叉类型</td></tr></tbody></table><p>实际开发的共识是：type 和 interface 都能用的时候用 interface。</p><h1 id="索引类型和映射类型"><a href="#索引类型和映射类型" class="headerlink" title="索引类型和映射类型"></a>索引类型和映射类型</h1><p>对象的属性（key）叫做索引。映射类型就是使用已有类型创建新类型（通过操作符）。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">price</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Products</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的 id 只是一个占位 </span></span><br><span class="line">    [<span class="attr">id</span>: <span class="built_in">number</span>]: <span class="title class_">Product</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">products</span>: <span class="title class_">Products</span> = &#123;</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;nick&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;adidas&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>:<span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见操作符</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Keys</span> = keyof <span class="title class_">Product</span> <span class="comment">// &#x27;name&#x27; | &#x27;price&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Tp</span> = <span class="keyword">typeof</span> products[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="条件类型和工具类型"><a href="#条件类型和工具类型" class="headerlink" title="条件类型和工具类型"></a>条件类型和工具类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数返回值：string 类型返回 1， number 类型返回 0</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReType</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，函数的参数和返回值是外部传入的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Func</span>&lt;T&gt; = <span class="function">(<span class="params"><span class="attr">a</span>: T</span>) =&gt;</span> <span class="title class_">ReType</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">fun1</span>: <span class="title class_">Func</span>&lt;<span class="built_in">string</span>&gt; = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a 是 string 类型，同时返回值只能是 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fun2</span>: <span class="title class_">Func</span>&lt;<span class="built_in">number</span>&gt; = <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// a 是 number 类型，同时返回值只能是 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型编程的-4-个范式"><a href="#类型编程的-4-个范式" class="headerlink" title="类型编程的 4 个范式"></a>类型编程的 4 个范式</h2><ol><li>访问性修饰工具：Partial, Required, Readonly</li><li>结构工具：Pick，Omit，Record</li><li>集合工具类型：NonNullable，Exclude</li><li>模式匹配工具类型：ReturnType</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈架构</title>
      <link href="/2022/03/18/%E6%B5%85%E8%B0%88%E6%9E%B6%E6%9E%84/"/>
      <url>/2022/03/18/%E6%B5%85%E8%B0%88%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>架构设计需要遵循下面的原则：</p><ul><li><ol><li>平衡的艺术：时间、质量、成本等商业目标</li></ol></li><li><ol start="2"><li>演进原则：最小闭环、能用、适当冗余设计</li></ol></li></ul><p>如果是代码量多达几十万行的大中型项目，团队里几十个人如果不今年新年更系统拆分，开发测试效率都非常低下，非常难以维护。分布式拆分之后可以大幅度提升开发效率，各个模块可以单独部署。但是分布式系统也带来了一些复杂的技术挑战：</p><p>一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>大部分的系统，是要进行多轮拆分的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等吧。</p><p>但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。</p><p>扯深了实在很深，所以这里先给大家举个例子，你自己感受一下，核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆。你根据自己负责系统的例子，来考虑一下就好了。</p><h1 id="分布式-ID-生成器"><a href="#分布式-ID-生成器" class="headerlink" title="分布式 ID 生成器"></a>分布式 ID 生成器</h1><h2 id="数据库自增-ID"><a href="#数据库自增-ID" class="headerlink" title="数据库自增 ID"></a>数据库自增 ID</h2><p>插入一条记录，生成一个 ID。优点：1. 复用了 DB 的能力，无需额外代码; 2. 全局唯一；3. 绝对自增；4. ID 步长确定。在业务早期，并发量小，追求快速实现的时候完全够用。</p><p>缺点：DB 中数据量太多，生成 ID 的性能完全取决于 DB 的插入性能，高并发 DB 会扛不住。<br>解决方案：1. DB 只保留 MAX ID; 2. 性能差可以增加 1 层服务层，采用批量生成的方式减低 DB 写压力。</p><p>id-service 的具体实现：</p><ol><li>SELECT MAX(id) FROM t_id, 例如：max_id &#x3D; 100</li><li>批量生成一批 id 放入 id-service 内存, 并将 max_id 写回 DB（使用 <code>UPDATE t_id SET id = 200 WHERE id = 100</code> 乐观锁保证只有一个 service 能成功写入，失败的进程需要重试）</li></ol><p>分配 ID 的整体性能就提升了 100 倍。</p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>常用的有以下 5 种实现方案：</p><h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><p>所谓的 XA 方案，即：两阶段提交，有一个<strong>事务管理器</strong>的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说<strong>某个系统内部如果出现跨多个库</strong>的这么一个操作，是<strong>不合规</strong>的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求<strong>每个服务只能操作自己对应的一个数据库</strong>。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过<strong>调用别的服务的接口</strong>来实现，绝对不允许交叉访问别人的数据库。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/b4a8c5d0-e34c-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>全称：Try,Confirm,Cancle。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong>。</li><li>Confirm 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong>。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要<strong>进行补偿</strong>，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个<strong>事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了</strong>，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟<strong>钱</strong>相关的，跟钱打交道的，<strong>支付、交易</strong>相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/715d5600-e34d-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h2 id="可靠消息最终一致性"><a href="#可靠消息最终一致性" class="headerlink" title="可靠消息最终一致性"></a>可靠消息最终一致性</h2><p>直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。大概意思如下：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会<strong>自动定时轮询</strong>所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li></ol><p>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/87a3e450-e34e-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h2 id="最大努力通知"><a href="#最大努力通知" class="headerlink" title="最大努力通知"></a>最大努力通知</h2><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><p>最佳实践:特别严格的场景，用的是 TCC 来保证强一致性；然后其他的一些场景基于阿里的 RocketMQ 来实现分布式事务。</p><h1 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h1><p>常用的解决方案有 2 种：</p><ul><li>基于 redis 的 session 共享</li><li>使用 JWT 存储用户身份，再从 DB 或者 cache 中获取其他信息。这样无论请求分配到哪个服务器都无所谓。</li></ul><h1 id="如何实现一个-RPC-框架"><a href="#如何实现一个-RPC-框架" class="headerlink" title="如何实现一个 RPC 框架"></a>如何实现一个 RPC 框架</h1><ol><li>服务要去注册中心注册，所以要有个服务注册中心，保留各个服务的信息，可以用 ZK</li><li>消费者需要去注册中心上拿到对应的服务信息</li><li>向机器发起请求可以采用负载均衡算法，比如最简单的轮询</li><li>服务器接收到序列化请求后调用对应的代码返回数据并序列化数据发给客户端</li><li>客户端反序列化得到 RPC 的结果</li></ol><h1 id="跨公网调用，第三方接口超时，怎么优化"><a href="#跨公网调用，第三方接口超时，怎么优化" class="headerlink" title="跨公网调用，第三方接口超时，怎么优化"></a>跨公网调用，第三方接口超时，怎么优化</h1><h2 id="异步代理法"><a href="#异步代理法" class="headerlink" title="异步代理法"></a>异步代理法</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/arch-proxy.png" alt="异步代理法"></p><p>如上图所示：增加 async-proxy 向业务方屏蔽“本地实时”和“远程”调用。由 async-proxy 定期维护远程结果缓存到本地。典型的场景就是：通过 openid 获取用户基本信息。优点是：公网抖动、第三方接口超时并不影响内部接口。不足：本地的不是最新数据（很多业务是可以接受数据延迟的）。</p><h2 id="主备切换法"><a href="#主备切换法" class="headerlink" title="主备切换法"></a>主备切换法</h2><p>非独享的第三方服务可以有多个供应商备份。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/arch-backup.png" alt="主备切换法"></p><p>例如：发送短信可以同时接入阿里云和腾讯云。</p><h2 id="异步调用法"><a href="#异步调用法" class="headerlink" title="异步调用法"></a>异步调用法</h2><p>先直接返回第三方处理成功，业务成功后进行通知。</p><h1 id="如何保证-DB-和-Cache-的缓存双写一致"><a href="#如何保证-DB-和-Cache-的缓存双写一致" class="headerlink" title="如何保证 DB 和 Cache 的缓存双写一致"></a>如何保证 DB 和 Cache 的缓存双写一致</h1><p>解决缓存和 DB 一致性的问题，常见的解决方案有下面的 4 种：</p><ol><li>先修改 DB，后更新缓存</li><li>先更新缓存，后修改 DB</li><li>先修改 DB，后删除缓存</li><li>先删除缓存，后修改 DB</li></ol><p>1-3 这 3 种方案都有同一个问题：当第一步成功执行，第二步未执行的时候（例如：停电），DB 和缓存的数据就不一致了！方案 4 相比起来更好 —— 但是依然存在<em>并发保存旧值的情况</em>！</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/db-cache-consistent.png" alt="先删缓存，后改DB的并发保存旧值情况"></p><p>最终解决方案是：消息队列 + 延迟双删。</p><p>MQ 有消息确认机制，可以保证我们在执行完第一步之后，即使出现掉电重启的情况，依然可以执行后续的流程。</p><p>延迟双删的具体流程如下：</p><ol><li>删除缓存</li><li>更新 DB</li><li>延迟一会(500ms-1s)再删除缓存</li></ol><p>最后一次延迟删除缓存的原因是，为了避免上面因为并发问题导致保存旧值的情况发生，所以会延迟一段时间之后再进行删除操作。这样即使有并发问题，也能最大限度的解决保存旧值的情况，因为是延迟之后删除的，所以即使因为并发问题保存了旧值，但延迟一段时间之后旧值就会被删除，那么这样就自然而然的保证了数据库和缓存的最终一致性。</p><h1 id="如何解决时钟回拨问题"><a href="#如何解决时钟回拨问题" class="headerlink" title="如何解决时钟回拨问题"></a>如何解决时钟回拨问题</h1><p>雪花算法要求系统时钟必须是单调递增的，如果系统时钟发生回拨（时间逆流），可能导致生成的 ID 重复。<a href="https://github.com/baidu/uid-generator">百度 UidGenerator 框架</a>中解决了时间回拨的问题，并且解决方案比较经典:</p><p>UidGenerator 的每个实例中，都维护一个本地时钟缓存，用于记录当前时间戳。这个本地时钟会定期与系统时钟进行同步，如果检测到系统时钟往前走了（出现了时钟回拨），则将本地时钟调整为系统时钟。</p><blockquote><p>UidGenerator 是百度开源的一个分布式唯一 ID 生成器，它是基于 Snowflake 算法的改进版本。与传统的 Snowflake 算法相比，UidGenerator 在高并发场景下具有更好的性能和可用性。</p></blockquote><h1 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h1><p>Paxos 基于“少数服从多数”(Quorum 机制)，通过“请求阶段”和“批准阶段”在不确定的环境下，解决了单个“提案”的共识问题。</p><p>Raft 算法属于“强领导者”(Strong Leader) 模型，领导者负责所有的写入操作，它是整个系统的写瓶颈。解决方案是使用哈希算法将数据划分成多个独立的分片。</p><blockquote><p>Raft 是 Re{liable|picated|dundant} And Fault-Tolerant 的缩写。即：可靠、复制、冗余和容错。</p></blockquote><p>Paxos 算法理解起来十分难懂，理论描述和实际工程实践之间存在巨大鸿沟，最终实现的系统往往建立在一个尚未完全证明的算法基础之上。</p><p>Raft 算法是分布式系统领域的首选共识算法。</p><h1 id="谈谈重构"><a href="#谈谈重构" class="headerlink" title="谈谈重构"></a>谈谈重构</h1><p>屎山代码出现的根本原因是：需求变动频繁，没空优化，导致代码能跑就行，所以应该时不时按下暂停键，给时间进行代码优化，优化的时候开启检查工具。</p><p>行业陈规认为：良好的设计必须在开始编程之前完成，因为一旦开始编码，设计只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此，我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生变化。由于预先做好良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。</p><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><blockquote><p>重构的唯一目的是让我们开发更快，用更少的工作量创造更大的价值。</p></blockquote><p>第一次做某件事的时候只管去做，第二次做类似的事情的时候会产生反感，但是无论如何还是可以去做；第三次再做类似的事情，就应该重构了。—— 事不过三，三则重构。</p><p>长久以来人们认为编写软件是一个累加的过程：要添加新功能，就应该增加新代码。但是往往添加新功能最快的方法就是先修改已有的代码，让新功能很容易被加入。</p><p>重构的目的不在于将代码库打磨得闪闪发光，而是纯粹的经济角度出发的考量 —— 添加新功能更快，修复 bug 更快。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链学习</title>
      <link href="/2022/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>BTC 对标黄金（总量限制），而 ETH 无限量，几乎所有的 DAPP 都放在 ETH 上。ETH 上的程序被称为智能合约，是代码和数据（状态）的集合。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>Gas:通过以太币账户发起一个交易（普通交易或者部署、运行一个合约），矿工收取的相应的工作量费用。</p><p>GameFi:Game + Finance，是 区块链游戏 与 去中心化金融（DeFi） 的结合体，玩家可以通过玩游戏赚取加密货币或NFT等数字资产，实现“边玩边赚”（Play-to-Earn, P2E）。</p><p>BSC：是币安智能链，是币安生态的底层公链，是 BNB 的生态链，BSC 上的 DAPP 与 ETH 上的 DAPP 互通，交易费用远低于以太坊。</p><h1 id="Layer2"><a href="#Layer2" class="headerlink" title="Layer2"></a>Layer2</h1><p>ETH 主网 15-30 TPS。</p><p>区块链扩展技术，通过在以太坊等主链（Layer 1）之上构建第二层网络，大幅提升交易速度并降低手续费，同时继承主链的安全性。工作原理：</p><ol><li>交易打包：用户交易在 Layer 2 网络内快速处理（如每秒数千笔）。</li><li>数据压缩：将多笔交易压缩成一条证明（如 Rollup 技术）。</li><li>主链锚定：定期将交易数据或状态提交到 Layer 1（如以太坊），确保安全性。</li></ol><p>Layer 1（主链）像银行总行，负责最终结算。Layer 2 像分行或支付宝，处理日常交易，定期与总行对账。</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dapp </tag>
            
            <tag> eth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 踩坑</title>
      <link href="/2021/08/21/nginx%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/08/21/nginx%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>NGINX 是 CPU 亲和的，把每个 worker 进程固定在一个 CPU 上执行(<code>worker_cpu_affinity</code> 配置)，减少切换 CPU 的 cache miss，获得更好的性能。绑定 CPU 核心可以减少上下文切换，但过度绑定可能导致负载不均衡, 建议在高负载场景下使用，普通场景可以省略。</p><p>处理静态资源效率高的原因是采用了 sendFile 工作机制：文件从硬盘上读取到网络传输的过程不经过用户空间，也就是常说的零拷贝机制：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8aa42180-f381-445d-ab51-41309189e6bf.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2fb12272-8c90-468c-95c7-320fdf3c0ed7.png" alt="image.png"></p><h1 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h1><p>主要是区分合法请求和非法请求，常用的解决方案有以下几种：</p><ol><li>基于http_refer防盗链配置模块</li></ol><h1 id="url-重写"><a href="#url-重写" class="headerlink" title="url 重写"></a>url 重写</h1><p>网站维护的时候将所有页面重定向到维护页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^(.*)$ /pages/maintain.html</span><br></pre></td></tr></table></figure><p>301和302的区别：301是永久重定向，客户端会缓存重定向后的地址（即使服务器关闭也能跳转到对应的地址），302请求每次都会访问服务器。所以做重定向的时候最好选择302,301如果跳转的链接改了是无法及时更新的。</p><p>https优化：</p><ol><li>激活keepalive长连接</li><li>设置ssl session缓存</li></ol><blockquote><p>所有的压缩算法对文本的压缩效率是最高的</p></blockquote><h1 id="nginx-调优"><a href="#nginx-调优" class="headerlink" title="nginx 调优"></a>nginx 调优</h1><p>文件描述符修改</p><p>&#x2F;etc&#x2F;security&#x2F;limits.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对用户配置</span></span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535 </span><br></pre></td></tr></table></figure><p>soft和hard的区别，soft只是警告，而hard是会强制拒绝的。 </p><h1 id="基于-nginx-lua-的防火墙"><a href="#基于-nginx-lua-的防火墙" class="headerlink" title="基于 nginx+lua 的防火墙"></a>基于 nginx+lua 的防火墙</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8e78b467-618e-4789-bd37-408d1c8e3433.png" alt="image.png"></p><p><a href="https://github.com/loveshell/ngx_lua_waf">https://github.com/loveshell/ngx_lua_waf</a></p><h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ul><li>http_stub_status_module:监控服务器运行状态</li><li>http_sub_module：http内容替换</li><li>http_access_module:基于ip的访问控制</li><li>http_auth_basic_module:基于用户的信任登录</li><li>http_secure_link_module:给服务器文件链接添加时间戳和校验码，从而保护服务器文件不被任意下载盗用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 踩坑</title>
      <link href="/2021/08/16/golang%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/08/16/golang%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><p>可以按照特定的规则执行逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">kb</span><br><span class="line">mb</span><br><span class="line">gb</span><br><span class="line">tb</span><br><span class="line">pb</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 1 1024 1048576 1099511627776 1125899906842624</span></span><br><span class="line">fmt.Println(b,kb,mb,tb,pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go中的slice本身没有数据，是对底层array的view。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span> <span class="params">(value <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum:=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(value <span class="type">int</span>)</span></span><span class="type">int</span>  &#123;</span><br><span class="line">sum += value</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">adder:=adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 0 1 3 6 10 15 21 28 36 45</span></span><br><span class="line">fmt.Println(adder(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码使用闭包保存了状态(有一个自由变量)，正宗的函数式编程长这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iAddr <span class="function"><span class="keyword">func</span> <span class="params">(<span class="type">int</span>)</span></span> (<span class="type">int</span>,iAddr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">(base <span class="type">int</span>)</span></span> iAddr &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">(v <span class="type">int</span>)</span></span> (<span class="type">int</span>,iAddr) &#123;</span><br><span class="line"><span class="keyword">return</span> base + v,adder(base + v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">add:=adder(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 0 1 3 6 10 15 21 28 36 45</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">int</span></span><br><span class="line">s,add = add(i)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的闭包例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契生成器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a,b := <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a,b = b,a + b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> intGen <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span></span> intGen &#123;</span><br><span class="line">a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现read接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g intGen)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">next := g()</span><br><span class="line"><span class="keyword">if</span> next &gt; <span class="number">10000</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, io.EOF</span><br><span class="line">&#125;</span><br><span class="line">s := fmt.Sprintf(<span class="string">&quot;%d\n&quot;</span>, next)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> incorrect if p is too small!</span></span><br><span class="line"><span class="keyword">return</span> strings.NewReader(s).Read(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFileContents</span><span class="params">(reader io.Reader)</span></span> &#123;</span><br><span class="line">scanner := bufio.NewScanner(reader)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> f intGen = fibonacci()</span><br><span class="line">printFileContents(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="资源管理和错误处理"><a href="#资源管理和错误处理" class="headerlink" title="资源管理和错误处理"></a>资源管理和错误处理</h1><p>defer调用可以确保在函数结束的时候被调用，它是一个栈。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;print too many&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ go run main.go</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// panic: print too many</span></span><br></pre></td></tr></table></figure><p>recover可以在defer中调用，可以接收panic的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// &quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">r:= <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">// type assert</span></span><br><span class="line"><span class="keyword">if</span> err, ok := r.(<span class="type">error</span>);ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error occured:&quot;</span>,err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;I dont&#x27;t know what to do: %v&quot;</span>, r))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：Error occured: this is an error</span></span><br><span class="line"><span class="comment">// panic(errors.New(&quot;this is an error&quot;))</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输出：Error occured: runtime error: integer divide by zero</span></span><br><span class="line"><span class="comment">// a:=5</span></span><br><span class="line"><span class="comment">// b:=0</span></span><br><span class="line"><span class="comment">// fmt.Println(a / b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// panic: 123 [recovered]</span></span><br><span class="line">    <span class="comment">//     panic: I dont&#x27;t know what to do: 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">// main.tryRecover.func1()</span></span><br><span class="line"><span class="comment">// C:/Users/Administrator/Desktop/blog-source/source/main.go:15 +0x105</span></span><br><span class="line"><span class="comment">// panic(0x4b0a20, 0x4ea298)</span></span><br><span class="line"><span class="comment">// c:/go/src/runtime/panic.go:969 +0x176</span></span><br><span class="line"><span class="comment">// main.tryRecover()</span></span><br><span class="line"><span class="comment">// C:/Users/Administrator/Desktop/blog-source/source/main.go:27 +0x65</span></span><br><span class="line"><span class="comment">// main.main()</span></span><br><span class="line"><span class="comment">// C:/Users/Administrator/Desktop/blog-source/source/main.go:31 +0x27</span></span><br><span class="line"><span class="comment">// exit status 2</span></span><br><span class="line"><span class="comment">// re panic ： 因为123不是error类型</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tryRecover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>go采用表格驱动测试：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7e93bf34-758a-4284-a87a-111f71743a0a.png" alt="image.png"></p><p>分离了测试数据和测试逻辑。虽然其他语言也能做，但是<strong>go语言的语法使得表格测试更容易实现</strong>。因为表格实现起来比较容易。</p><h1 id="goroutine-channel"><a href="#goroutine-channel" class="headerlink" title="goroutine &amp; channel"></a>goroutine &amp; channel</h1><p>io操作会切换协程，纯CPU操作不会进行协程的切换，这意味着如果一个协程不主动交出控制权的话就会一直占用CPU资源：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a[<span class="number">100000</span>] <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i]++</span><br><span class="line"><span class="comment">// runtime.Gosched()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码后cpu会跑满，可以使用<code>runtime.Gosched()</code>可以手动交出控制权。</p><p>channel是goroutine和goroutine的交互，发了数据没人收的话是会死锁的！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">c:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将1，2送入channel</span></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从channel中读取</span></span><br><span class="line">n:= &lt;-c</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure><p>正确的channel使用姿势应该长下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">c:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这一段代码要放在向channel中输入数据之前</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">n:= &lt;-c</span><br><span class="line"><span class="comment">// 可能只打印 1,2,3,4中的前几个，因为可能函数调用已经完成</span></span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将1，2送入channel</span></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">c &lt;- <span class="number">3</span></span><br><span class="line">c &lt;- <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel具有方向性，即可以使用<code>&lt;-</code>或者<code>-&gt;</code>定义一个只能输入或者输出的channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="keyword">chan</span> &lt;- <span class="type">int</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n:= <span class="keyword">range</span>(c)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d received %c \n&quot;</span>,id, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> channels [<span class="number">5</span>]<span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">channels[i] = createWorker(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// createWorker 方法创建的channel具有方向性，只能向channel中发数据，如果试图从channel中读取数据将会报错</span></span><br><span class="line"><span class="comment">// n := &lt;- channels[i]</span></span><br><span class="line">channels[i] &lt;- <span class="string">&#x27;a&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">channels[i] &lt;- <span class="string">&#x27;A&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Worker 0 received a</span></span><br><span class="line"><span class="comment">// Worker 0 received A</span></span><br><span class="line"><span class="comment">// Worker 2 received c</span></span><br><span class="line"><span class="comment">// Worker 3 received d</span></span><br><span class="line"><span class="comment">// Worker 1 received b</span></span><br><span class="line"><span class="comment">// Worker 4 received e</span></span><br><span class="line"><span class="comment">// Worker 1 received B</span></span><br><span class="line"><span class="comment">// Worker 3 received D</span></span><br></pre></td></tr></table></figure><p>make的第二个参数可以创建创建channel的缓冲区，对提升性能有帮助。</p><blockquote><p>不要通过共享内存来通信，而是需要通过通信来共享内存。</p></blockquote><p>上面的例子中由于我们开启了5个goroutine来并发执行，为了让goroutine有机会执行，最后进行了1ms的延迟，这样其实是非常不好的！因为我们不能确定程序能在1ms内全部处理完。对上面的代码稍加改造：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span>&#123;</span><br><span class="line">in <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">done <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="type">int</span>,c <span class="keyword">chan</span> <span class="type">int</span>,done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n:= <span class="keyword">range</span>(c)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d received %c \n&quot;</span>,id, n)</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="type">int</span>)</span></span> worker &#123;</span><br><span class="line">w := worker&#123;</span><br><span class="line">in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">done: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> doWork(id,w.in,w.done)</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">5</span>]worker</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">workers[i] = createWorker(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1个1个等</span></span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;a&#x27;</span> + i</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;A&#x27;</span> + i</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会输出以下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker 0 received a</span><br><span class="line">Worker 1 received b</span><br><span class="line">Worker 2 received c</span><br><span class="line">Worker 3 received d</span><br><span class="line">Worker 4 received e</span><br><span class="line">Worker 0 received A</span><br><span class="line">Worker 1 received B</span><br><span class="line">Worker 2 received C</span><br><span class="line">Worker 3 received D</span><br><span class="line">Worker 4 received E</span><br></pre></td></tr></table></figure><p>按顺序从小写字母打印到大写字母，程序是顺序执行。有没有什么办法提高程序并行度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">5</span>]worker</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">workers[i] = createWorker(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先并发打印小写</span></span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;a&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再并发打印大写</span></span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;A&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码提高了并发度，小写字母并发打印，大写字母并发打印，这样一般来说也满足要求了，有没有方法所有任务一起并发？很自然会写出下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">5</span>]worker</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">workers[i] = createWorker(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;a&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;A&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&lt;-worker.done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，我们会发现并发打印完小写字母后出现了死锁的报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Worker 4 received e</span><br><span class="line">Worker 0 received a</span><br><span class="line">Worker 3 received d</span><br><span class="line">Worker 1 received b</span><br><span class="line">Worker 2 received c</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>比较容易的解决方法是改造doWorker，将向外输出done放在一个goroutine中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="type">int</span>,c <span class="keyword">chan</span> <span class="type">int</span>,done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n:= <span class="keyword">range</span>(c)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d received %c \n&quot;</span>,id, n)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123; done &lt;- <span class="literal">true</span> &#125; ()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对于等待多任务，golang本身提供了系统库级别的支持<code>sync.waitGroup</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span>&#123;</span><br><span class="line">in <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">wg *sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(id <span class="type">int</span>,c <span class="keyword">chan</span> <span class="type">int</span>,wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n:= <span class="keyword">range</span>(c)&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Worker %d received %c \n&quot;</span>,id, n)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorker</span><span class="params">(id <span class="type">int</span>,wg *sync.WaitGroup)</span></span> worker &#123;</span><br><span class="line">w := worker&#123;</span><br><span class="line">in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>),</span><br><span class="line">wg:wg,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> doWork(id,w.in,wg)</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">5</span>]worker</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">workers[i] = createWorker(i,&amp;wg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;a&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i,worker := <span class="keyword">range</span>(workers) &#123;</span><br><span class="line">worker.in &lt;- <span class="string">&#x27;A&#x27;</span> + i</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用select进行调度"><a href="#使用select进行调度" class="headerlink" title="使用select进行调度"></a>使用select进行调度</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generator</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">out:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>)) *  time.Millisecond)</span><br><span class="line">out &lt;- i</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> c1,c2 = generator(),generator()</span><br><span class="line">tm := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n := &lt;- c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;receive from c1:&quot;</span>,n)</span><br><span class="line"><span class="keyword">case</span> n := &lt;- c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;receive from c2:&quot;</span>,n)</span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line"><span class="comment">// 等待数据太慢</span></span><br><span class="line">fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;- tick:</span><br><span class="line">fmt.Println(<span class="string">&quot;this will print every seconds&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;- tm:</span><br><span class="line"><span class="comment">// 计时器终止后退出程序</span></span><br><span class="line">fmt.Println(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">receive from c2: 0</span><br><span class="line">receive from c1: 0</span><br><span class="line">receive from c1: 1</span><br><span class="line">receive from c2: 1</span><br><span class="line">this will <span class="built_in">print</span> every seconds</span><br><span class="line">receive from c2: 2</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line">receive from c1: 2</span><br><span class="line">receive from c2: 3</span><br><span class="line">this will <span class="built_in">print</span> every seconds</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line">receive from c1: 3</span><br><span class="line">this will <span class="built_in">print</span> every seconds</span><br><span class="line">receive from c1: 4</span><br><span class="line">receive from c1: 5</span><br><span class="line">receive from c2: 4</span><br><span class="line">receive from c2: 5</span><br><span class="line">receive from c2: 6</span><br><span class="line">receive from c1: 6</span><br><span class="line">this will <span class="built_in">print</span> every seconds</span><br><span class="line"><span class="built_in">timeout</span></span><br><span class="line">receive from c2: 7</span><br><span class="line">this will <span class="built_in">print</span> every seconds</span><br><span class="line"><span class="built_in">bye</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 设计模式</title>
      <link href="/2021/03/31/design-pattern-in-js/"/>
      <url>/2021/03/31/design-pattern-in-js/</url>
      
        <content type="html"><![CDATA[<blockquote><p>心游于艺，道不远人</p></blockquote><h1 id="变继承关系为组合关系"><a href="#变继承关系为组合关系" class="headerlink" title="变继承关系为组合关系"></a>变继承关系为组合关系</h1><h2 id="State-模式"><a href="#State-模式" class="headerlink" title="State 模式"></a>State 模式</h2><p>继承描述了 is-a 的关系，子类可以继承父类的成员变量和函数，也可以修改父类的成员变量和函数。使用设计模式来实现代码复用，而不是使用继承实现代码复用。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/StatePattern.png" alt="State设计模式"></p><p>它的核心思想是<strong>通过改变对象的内部状态来改变对象的行为，而无需修改对象本身的类结构。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engineer</span> <span class="keyword">implements</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;写代码&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">implements</span> <span class="title class_">Role</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;开会&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类（Employee）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Role role; <span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRole</span><span class="params">(Role role)</span> &#123; <span class="built_in">this</span>.role = role; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; role.doWork(); &#125; <span class="comment">// 行为委托给状态对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">emp.setRole(<span class="keyword">new</span> <span class="title class_">Engineer</span>());</span><br><span class="line">emp.doWork(); <span class="comment">// 输出 &quot;写代码&quot;</span></span><br><span class="line"></span><br><span class="line">emp.setRole(<span class="keyword">new</span> <span class="title class_">Manager</span>());</span><br><span class="line">emp.doWork(); <span class="comment">// 输出 &quot;开会&quot;</span></span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>java 中有一个 Runnable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现 LoggingRunnable，TransactionRunnable?</p><p>原始的 CodingTask 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CodingTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writing code&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 抛出运行时异常防止异常被吞没</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种不太好的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LoggingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task started at &quot;</span> + LocalTime.now());</span><br><span class="line">        doRun();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task done at &quot;</span> + LocalTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TransactionRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin transaction.&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldRollback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doRun();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            shouldRollback = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldRollback) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;rollback&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodingTask</span> <span class="keyword">extends</span> <span class="title class_">LoggingRunnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writing code&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 抛出运行时异常防止异常被吞没</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CodingTask</span>().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码虽然实现了功能，但是 CodingTask 的定义却变得不是很明朗：</p><ul><li>CodingTask 从字面意思上是任务，原始的 CodingTask 实现了 Runnable 接口含义更明确</li><li>引入了另外一个前提，凡是在使用 CodingTask 的地方必须记录日志 </li><li>如果我们现在不想要 CodingTask 记录日志了，而是当做一个 Transaction 处理，就必须修改代码让 CodingTask 继承 TransactionRunnable 抽象类</li><li>如果 CodingTask 要同时完成记录日志和启用事务，由于单继承的局限性，上面的代码无法做到（即使支持多继承，由于 LoggingRunnable 和 TransactionRunnable 都有 doRun，到底调用哪个也是很复杂的）</li><li>run 方法比 doRun 具有更好的语义</li></ul><p>装饰器模式可以解除上述耦合：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/DecoratorPattern.png" alt="装饰器模式"></p><blockquote><p>类里面的成员要么是 public 的，要么是 private 的，如果遇到 protected 要反思下是否进行了正确建模。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoggingRunnable</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task started at &quot;</span> + LocalTime.now());</span><br><span class="line">        runnable.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task done at &quot;</span> + LocalTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransactionRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionRunnable</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin transaction.&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shouldRollback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            shouldRollback = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (shouldRollback) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;rollback&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodingTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;writing code&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CodingTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodingTask</span>();</span><br><span class="line"></span><br><span class="line">        task.run(); <span class="comment">// 单独run</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LoggingRunnable</span>(task).run(); <span class="comment">// 记录日志,run</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LoggingRunnable</span>(<span class="keyword">new</span> <span class="title class_">TransactionRunnable</span>(task)).run(); <span class="comment">// 记录日志,开启事务,run</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，每个类各司其职，但是可以通过嵌套灵活组装。里层的逻辑装饰了外层逻辑。java 流就使用了装饰器模式。</p><p>一种<em>快速出错</em>的常规编程实践提倡一旦出错就立刻抛出异常，使错误的定位更加容易（这和忽略错误并将异常推迟到以后处理的方式截然相反）。</p><h1 id="模拟接口"><a href="#模拟接口" class="headerlink" title="模拟接口"></a>模拟接口</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interface</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, methods</span>) &#123;</span><br><span class="line">        <span class="title function_">assert</span>(name, <span class="string">&#x27;接口名不能为空&#x27;</span>);</span><br><span class="line">        <span class="title function_">assert</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(methods) &amp;&amp; methods.<span class="title function_">every</span>(<span class="function"><span class="params">m</span> =&gt;</span> <span class="keyword">typeof</span> m === <span class="string">&#x27;string&#x27;</span>), <span class="string">&#x27;请检查方法名数组&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">methods</span> = methods;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">ensureImplements</span>(<span class="params">obj, ...interfaces</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> inter <span class="keyword">of</span> interfaces) &#123;</span><br><span class="line">            <span class="keyword">const</span> clazz = inter.<span class="property">constructor</span>;</span><br><span class="line">            <span class="keyword">const</span> className = clazz.<span class="property">name</span>;</span><br><span class="line">            assert.<span class="title function_">equal</span>(clazz, <span class="title class_">Interface</span>, <span class="string">`<span class="subst">$&#123;className&#125;</span>必须通过new Interface生成`</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> methodName <span class="keyword">of</span> inter.<span class="property">methods</span>) &#123;</span><br><span class="line">                assert.<span class="title function_">equal</span>(<span class="keyword">typeof</span> obj[methodName], <span class="string">&#x27;function&#x27;</span>, <span class="string">`<span class="subst">$&#123;className&#125;</span>没有实现呢<span class="subst">$&#123;methodName&#125;</span>方法`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i1 = <span class="keyword">new</span> <span class="title class_">Interface</span>(<span class="string">&#x27;map&#x27;</span>, [<span class="string">&#x27;zoomIn&#x27;</span>, <span class="string">&#x27;zoomOut&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> i2 = <span class="keyword">new</span> <span class="title class_">Interface</span>(<span class="string">&#x27;show&#x27;</span>, [<span class="string">&#x27;show&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock instance</span></span><br><span class="line"><span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="title function_">zoomIn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;map zoom in&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">zoomOut</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Interface</span>.<span class="title function_">ensureImplements</span>(map, i1, i2);</span><br><span class="line">map.<span class="title function_">zoomIn</span>();</span><br></pre></td></tr></table></figure><h1 id="作用域、嵌套函数和闭包"><a href="#作用域、嵌套函数和闭包" class="headerlink" title="作用域、嵌套函数和闭包"></a>作用域、嵌套函数和闭包</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">        a *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="title function_">foo</span>(); <span class="comment">// 指向函数bar</span></span><br><span class="line"><span class="keyword">let</span> ret = <span class="title function_">baz</span>(); <span class="comment">// 20</span></span><br><span class="line">ret = <span class="title function_">baz</span>(); <span class="comment">// 40</span></span><br><span class="line"><span class="keyword">debugger</span></span><br><span class="line"><span class="keyword">var</span> blat = <span class="title function_">foo</span>(); <span class="comment">// balt指向另一个bar</span></span><br><span class="line">ret = <span class="title function_">blat</span>(); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">debugger</span></span><br></pre></td></tr></table></figure><p>上述代码中，返回的对 bar 函数的引用被赋值给变量 baz，bar 函数虽然是在 foo 函数外部，但是依然能够访问变量 a，这是因为 js 中的作用域是词法的。函数是运行在定义它们的作用域中（foo 内部的作用域），而不是运行在调用它们的作用域中。只要 bar 被定义在 foo 中，它就能访问在 foo 中定义的所有变量，即使 foo 的执行已经结束。这是一个闭包的例子，在 foo 返回之后它的作用域就被保存下来，但是只有它返回的那个函数能够访问这个作用域。上面的例子中，baz 和 blat 各有这个作用域及a的一个副本，而且只有它们自己能够对其进行修改。<em>返回一个内嵌函数是创建闭包最常用的手段</em>。</p><p>通过闭包，我们可以实现私有变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">newISBN</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> isbn;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setISBN</span> = <span class="keyword">function</span>(<span class="params">newISBN</span>) &#123;</span><br><span class="line">        isbn = newISBN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getISBN</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> isbn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// constructor code</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setISBN</span>(newISBN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">commonMethod</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中私有变量通过闭包进行封装可以实现防止无意中修改了变量中的属性。用这种方式创建对象有 2 个弊端：</p><ol><li>新的对象的私有属性和方法都需要占用额外的内存（一般的创建对象所有的方法都存储在原型对象中，内存中只存储一份）</li><li>不利于派生子类，不能访问父类的私有属性和方法</li></ol><p>ES6 提供的 Reflect 可以实现真正的属性私有化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">priavateProp</span>(<span class="params">obj, filter</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">obj, prop</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="title function_">filter</span>(prop))&#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(obj, prop)</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">          val = val.<span class="title function_">bind</span>(obj)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">obj, prop, val</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_">filter</span>(prop))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`cannot set property <span class="subst">$&#123;prop&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, prop, val)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">has</span>(<span class="params">obj, prop</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">filter</span>(prop) ? <span class="literal">false</span> : <span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">filter</span>( <span class="function"><span class="params">prop</span> =&gt;</span> !<span class="title function_">filter</span>(prop))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有属性过滤器 </span></span><br><span class="line"><span class="comment">// 规则：以 _ 为开头的属性都是私有属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">prop</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> prop.<span class="title function_">indexOf</span>(<span class="string">&#x27;_&#x27;</span>) === <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">_private</span>: <span class="string">&#x27;private property&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;public name&#x27;</span>,</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 内部访问私有属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">_private</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">priavateProp</span>(o, filter)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)  <span class="comment">// Proxy &#123;_private: &quot;private property&quot;, name: &quot;public name&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">_private</span>  <span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(p) <span class="comment">// &quot;&#123;&quot;name&quot;:&quot;public name&quot;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能内部访问私有属性</span></span><br><span class="line">p.<span class="title function_">say</span>()  <span class="comment">//  private property</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_private&#x27;</span> <span class="keyword">in</span> p)   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能遍历到私有属性 </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(p)  <span class="comment">// [&quot;name&quot;, &quot;say&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有属性不能赋值</span></span><br><span class="line">p.<span class="property">_private</span> = <span class="string">&#x27;000&#x27;</span>  <span class="comment">// Uncaught Error: cannot set property _private</span></span><br></pre></td></tr></table></figure><h2 id="使用闭包实现-AOP"><a href="#使用闭包实现-AOP" class="headerlink" title="使用闭包实现 AOP"></a>使用闭包实现 AOP</h2><p>在 js 中实现 AOP 通常是将一个函数“动态织入”到另一个函数中，具体的实现技术可以通过拓展 <code>Function.prototype</code> 来做到这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beforeFn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    beforeFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afterFn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret = self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    afterFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;do work&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func = doWork</span><br><span class="line">  .<span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before fn&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">after</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after fn&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"><span class="comment">// before fn</span></span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line"><span class="comment">// after fn</span></span><br></pre></td></tr></table></figure><p>以上的代码中，<code>before</code> 和 <code>after</code> 方法都返回一个函数（对原函数进行加工之后的新函数）, 在实际调用的时候 <code>before</code> 和 <code>after</code> 的调用顺序是可以互换的；真正的函数也不存在 2 次调用，因为新函数都是对原函数进行了包装。</p><p>以先进行 before 调用为例，返回的新函数(假设 fnBefore)就是打印 <code>before fn</code> + 执行 <code>doWork</code>，在进行 <code>after</code> 调用的时候，返回的新函数就是 fnBefore + 打印 <code>after fn</code>。即每次调用都是新包装了一层，不存在多次调用的问题。</p><p>使用 AOP 的方式来给函数添加职责，也是 js 语言中一种非常特别和巧妙的装饰者模式实现，这种装饰模式在实际的开发中非常有用！</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="克隆函数和原型式继承"><a href="#克隆函数和原型式继承" class="headerlink" title="克隆函数和原型式继承"></a>克隆函数和原型式继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create(obj) 的简化版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = obj =&gt; &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;    <span class="comment">// 1. 创建一个空构造函数</span></span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = obj; <span class="comment">// 2. 将其原型指向传入的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();    <span class="comment">// 3. 返回一个空对象，但原型链指向 `obj`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的对象没有属性，但是可以通过原型链访问 <code>obj</code> 的方法和属性。</p><p>类似于 <code>Object.create</code> 的早期实现（ES5 之前）。它的核心思想是:<strong>基于现有对象创建新对象，并可以扩展或修改其属性和方法</strong>。</p><p>原型链继承比类式继承更能节省内存。原型链查找的方式创建的对象使得所有克隆出来的对象共享每个属性和方法的唯一一份实例，只有在直接设置了某个克隆出来的对象的属性和方法的时候，情况才会有所变化。与此同时，在类式继承中创建的每一个对象在内存中都有自己的一份属性（和私有方法）的副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`name = <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,age = <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">clone</span>(<span class="title class_">Person</span>); <span class="comment">// 创建Person对象的一个副本，然后改变其中的一些方法</span></span><br><span class="line">s.<span class="property">showAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;;</span><br><span class="line">s.<span class="title function_">init</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">14</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">show</span>()); <span class="comment">// name = 张三,age = 14</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">showAge</span>()); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><ul><li>s 的原型是 Person，所以可以调用 init 和 show</li><li>可以动态添加新方法（如 showAge），而不会影响 Person</li></ul><p>用这种方法创建的对象往往有较高的内存使用效率，因为它们会共享那些未被改写的属性和方法。那些包含数组和或者对象类型的成员的克隆会有一些麻烦的地方。但是这个问题可以通过一个方法来解决。</p><h2 id="多继承与-mixin"><a href="#多继承与-mixin" class="headerlink" title="多继承与 mixin"></a>多继承与 mixin</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Util</span> = &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> output = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">            output.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;<span class="variable language_">this</span>[key]&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age, courses</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">courses</span> = courses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：givingClass为带有方法的普通对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">receivingClass, givingClass</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> methodName <span class="keyword">in</span> givingClass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!receivingClass.<span class="property"><span class="keyword">prototype</span></span>[methodName]) &#123;</span><br><span class="line">            receivingClass.<span class="property"><span class="keyword">prototype</span></span>[methodName] = givingClass[methodName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mixin</span>(<span class="title class_">Student</span>, <span class="title class_">Util</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;张三丰&#x27;</span>, <span class="number">83</span>, [<span class="string">&#x27;太极拳&#x27;</span>, <span class="string">&#x27;乾坤大罗伊&#x27;</span>]);</span><br><span class="line"><span class="keyword">const</span> str = s.<span class="title function_">show</span>();</span><br></pre></td></tr></table></figure><blockquote><p>用一些代码来拓展一个类有时候比继承一个类更加适合，这可以轻松解决类中的重复代码问题。</p></blockquote><p>上面的代码可以将工具函数混入到类的原型中实现多继承，注意混入的类不能是 ES6 的 class 而是一个普通对象。因为 ES6 中定义的实例方法是不可枚举的。</p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>惰性单例：在需要的时候才创建对象实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createSingle = <span class="title function_">getSingle</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&#x27;single&#x27;</span>);    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> single1 = <span class="title function_">createSingle</span>();</span><br><span class="line"><span class="keyword">var</span> single2 = <span class="title function_">createSingle</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>一种用来把浏览器差异封装到运行期间内动态进行设置的技术。例如 XHR 对象在早期的 IE 中是 ActiveX 对象。如果不采用这种技术，每次调用这个方法的时候浏览器嗅探代码会再次运行，严重缺乏效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">XHRFactory</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> standard = &#123;</span><br><span class="line">        <span class="title function_">createXHR</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> activeXNew = &#123;</span><br><span class="line">        <span class="title function_">createXHR</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Msxml2.XMLHTTP&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> activeXOld = &#123;</span><br><span class="line">        <span class="title function_">createXHR</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> testObj;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        testObj = standard.<span class="title function_">createXHR</span>();</span><br><span class="line">        <span class="keyword">return</span> standard;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testObj = activeXNew.<span class="title function_">createXHR</span>();</span><br><span class="line">            <span class="keyword">return</span> activeXNew;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                testObj = activeXOld.<span class="title function_">createXHR</span>();</span><br><span class="line">                <span class="keyword">return</span> activeXOld;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;no xhr object found in this enviroment&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面的代码之所以有效的原因是：在脚本加载时一次性确定特定浏览器的代码。这样一来初始化完成之后每种浏览器只会执行针对它的 js 代码。在使用分之的时候需要在内存（分支计数需要多创建对象）和时间之间做一个权衡。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些策略对象中间的某一个进行计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">sub</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">mul</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> calc = <span class="keyword">function</span> (<span class="params">a, b, method</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> strategies[method](a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calc</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;add&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calc</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;sub&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calc</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;mul&#x27;</span>));</span><br></pre></td></tr></table></figure><p>使用策略模式可以消除原程序中大片的条件分支。所有和计算相关的逻辑不再放在 Context 中，而是分布在各个策略对象中。Context 本身并没有计算的能力，而是把这个职责委托给了各个策略对象。每个策略对象负责的算法被封装在对象内部。当我们对这些策略对象发出“计算”请求的时候他们会返回不同的结果，这正是<em>对象多态性</em>的体现，也是<em>它们可以相互替换</em>的目的。替换 Context 中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果。</p><h2 id="使用策略模式完成表单校验"><a href="#使用策略模式完成表单校验" class="headerlink" title="使用策略模式完成表单校验"></a>使用策略模式完成表单校验</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="title function_">notEmpty</span>(<span class="params">value, errMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">minLength</span>(<span class="params">value, length, errMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span> &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">isMobile</span>(<span class="params">value, errMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.<span class="title function_">test</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = []; <span class="comment">// 保存检验规则</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">dom, rule, errMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ary = rule.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="comment">// 把校验的步骤用空函数包装起来并且放入 cache</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> straegy = ary.<span class="title function_">shift</span>();</span><br><span class="line">      ary.<span class="title function_">unshift</span>(dom.<span class="property">value</span>);</span><br><span class="line">      ary.<span class="title function_">push</span>(errMsg);</span><br><span class="line">      <span class="keyword">return</span> strategies[straegy].<span class="title function_">apply</span>(dom, ary);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">valid</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> validFn <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">cache</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> msg = <span class="title function_">validFn</span>();</span><br><span class="line">      <span class="keyword">if</span> (msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> regForm = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#reg&quot;</span>);</span><br><span class="line">  regForm.<span class="property">onsubmit</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> validator = <span class="keyword">new</span> <span class="title class_">Validator</span>();</span><br><span class="line"></span><br><span class="line">    validator.<span class="title function_">add</span>(regForm.<span class="property">username</span>, <span class="string">&quot;notEmpty&quot;</span>, <span class="string">&quot;用户名不能为空&quot;</span>);</span><br><span class="line">    validate.<span class="title function_">add</span>(regForm.<span class="property">password</span>, <span class="string">&quot;minLength:6&quot;</span>, <span class="string">&quot;密码长度不能小于 6 位&quot;</span>);</span><br><span class="line">    validator.<span class="title function_">add</span>(regForm, phone, <span class="string">&quot;isMobile&quot;</span>, <span class="string">&quot;手机号格式不正确&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> errMsg = validator.<span class="title function_">valid</span>();</span><br><span class="line">    <span class="keyword">if</span> (errMsg) &#123;</span><br><span class="line">      <span class="comment">// 未通过校验则阻止表单提交</span></span><br><span class="line">      <span class="title function_">alert</span>(errMsg);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以仅仅通过“配置”的方式就可以完成一个表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式方便一致到其他项目中。</p><h1 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h1><p>运用共享技术来有效支持大量细粒度对象。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toyota</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;丰田&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Audi</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;奥迪&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;宝马&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inters = [<span class="string">&#x27;wash&#x27;</span>, <span class="string">&#x27;run&#x27;</span>, <span class="string">&#x27;repair&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> clazz <span class="keyword">of</span> [<span class="title class_">Toyota</span>, <span class="title class_">Audi</span>, <span class="variable constant_">BMW</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> inter <span class="keyword">of</span> inters) &#123;</span><br><span class="line">        clazz.<span class="property"><span class="keyword">prototype</span></span>[inter] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> -&gt; <span class="subst">$&#123;inter&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 汽车接口，包含洗车、运行、维修接口</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Car</span> = <span class="keyword">new</span> <span class="title class_">Intercafe</span>(<span class="string">&#x27;Car&#x27;</span>, inters);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">makeCar</span>(<span class="params">model</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> car;</span><br><span class="line">        <span class="keyword">switch</span> (model) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;toyota&#x27;</span>:</span><br><span class="line">                car = <span class="keyword">new</span> <span class="title class_">Toyota</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;audi&#x27;</span>:</span><br><span class="line">                car = <span class="keyword">new</span> <span class="title class_">Audi</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;bmw&#x27;</span>:</span><br><span class="line">                car = <span class="keyword">new</span> <span class="title function_">BMW</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Intercafe</span>.<span class="title function_">ensureImplements</span>(car, <span class="title class_">Car</span>); <span class="comment">// 确保对象实现了汽车接口</span></span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarShop</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sellCar</span>(<span class="params">model</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> car = <span class="title class_">CarFactory</span>.<span class="title function_">makeCar</span>(model);</span><br><span class="line">        car.<span class="title function_">wash</span>();</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中将创建对象的工作转交给一个外部对象，因为创建对象的方式可能存在变化。</p><blockquote><p>接口在工厂模式中起着很重要的作用。如果不对对象进行类型检查以确保实现了必须的方法，工厂模式所带来的所处也所剩无几。创建对象并且对它们一视同仁。</p></blockquote><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>工厂方法和简单工厂的区别在于不是使用另外一个来来创建对象，而是使用一个子类。工厂是将一个成员对象推迟到子类中进行的类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AjaxHandler</span> = <span class="keyword">new</span> <span class="title class_">Intercafe</span>(<span class="string">&#x27;AjaxHandler&#x27;</span>, [<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;createXhr&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">createXhr</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params">method, url, callback, postVars</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="variable language_">this</span>.<span class="title function_">createXhr</span>();</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            xhr.<span class="property">status</span> === <span class="number">200</span> ? callback.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>, xhr.<span class="property">responseXML</span>) : callback.<span class="title function_">failure</span>(xhr.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (method !== <span class="string">&#x27;POST&#x27;</span>) postVars = <span class="literal">null</span>;</span><br><span class="line">        xhr.<span class="title function_">send</span>(postVars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createXhr</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> methods = [</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); &#125;,</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Msxml2.XMLHTTP&#x27;</span>); &#125;,</span><br><span class="line">            <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>); &#125;</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> method <span class="keyword">of</span> methods) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title function_">method</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">createXhr</span> = method; <span class="comment">// memoize the method</span></span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;SimpleHandler：Can not create an xhr object.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueHandler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SimpleHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">requestInProcess</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">retryDelay</span> = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">advanceQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">requestInProcess</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> req = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">request</span>(req.<span class="property">method</span>, req.<span class="property">url</span>, req.<span class="property">callback</span>, req.<span class="property">postVars</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params">method, url, callback, postVars, override</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">requestInProcess</span> &amp;&amp; !override) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(&#123; method, url, callback, postVar &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">requestInProcess</span> = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="variable language_">this</span>.<span class="title function_">createXhr</span>();</span><br><span class="line">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                    callback.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>, xhr.<span class="property">responseXML</span>)</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">advanceQueue</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    callback.<span class="title function_">failure</span>(xhr.<span class="property">status</span>);</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="variable language_">this</span>.<span class="title function_">request</span>(method, url, callback, postVars, <span class="literal">true</span>);</span><br><span class="line">                    &#125;, <span class="variable language_">this</span>.<span class="property">retryDelay</span> * <span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (method !== <span class="string">&#x27;POST&#x27;</span>) postVars = <span class="literal">null</span>;</span><br><span class="line">            xhr.<span class="title function_">send</span>(postVars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OfflineHandler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SimpleHandler</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">storedRequests</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params">method, url, callback, postVars</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">XhrManager</span>.<span class="title function_">isOffline</span>()) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">storedRequests</span>.<span class="title function_">push</span>(&#123; method, url, callback, postVar &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// online的时候使用父类发送xhr</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">flushStoredRequests</span>();</span><br><span class="line">            <span class="variable language_">super</span>.<span class="title function_">request</span>(method, url, callback, postVars);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">flushStoredRequests</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> req <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">storedRequests</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>.<span class="title function_">request</span>(req.<span class="property">method</span>, req.<span class="property">url</span>, req.<span class="property">callback</span>, req.<span class="property">postVars</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">XhrManager</span> = &#123;</span><br><span class="line">    <span class="title function_">createXhrHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> xhr;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isOffline</span>()) &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> <span class="title class_">OfflineHandler</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isHighLatency</span>()) &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> <span class="title class_">QueueHandler</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            xhr = <span class="keyword">new</span> <span class="title class_">SimpleHandler</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Intercafe</span>.<span class="title function_">ensureTmplements</span>(xhr, <span class="title class_">AjaxHandler</span>);</span><br><span class="line">        <span class="keyword">return</span> xhr;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">isOffline</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">    <span class="title function_">isHighLatency</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述 createXhr 中 memoize 技术，复杂的设置代码只会在首次调用的时候执行一次，此后就只有针对当前浏览器的代码会被执行。</p><p>上面的工厂方法模式可以根据网络条件创建专门的请求对象：OfflineHandler 会在用户离线的时候把请求缓存起来，而 QueueHandler 会在发起新的请求之前确保所有请求都已经成功处理，如果请求失败后还支持指定时间间隔后重试这个请求，直到成功为止。</p><p>现在我们只需要使用<code>XhrManager.createXhrHandler</code>这个工厂方法而不需要实例化特定的类了。</p><p>工厂方法模式的好处在于消除对象间的耦合，通过工厂方法而不是 new 关键字可以把所有的实例化代码集中在一个位置，从而可以大大简化更换所用的类或者在运行期间选择类的工作。在派生子类的时候也提供了更大的灵活性 ———— 先创建一个抽象的父类，在子类中创建工厂方法，从而把成员对象的实例化推迟到专门的子类中进行。</p><h1 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h1><p>由 2 部分组成：抽象父类 + 具体实现的子类。通常在抽象父类中封装了子类的算法框架，包括一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123;  <span class="comment">// 饮料抽象类</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;  <span class="comment">// 模板方法</span></span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;  <span class="comment">// 具体方法 boilWater</span></span><br><span class="line">        System.out.println(<span class="string">&quot;把水煮沸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;  <span class="comment">// 抽象方法 brew</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;  <span class="comment">// 抽象方法 addCondiments</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span>;  <span class="comment">// 抽象方法 pourInCup</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用沸水浸泡茶叶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把茶倒进杯子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加柠檬&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用沸水冲泡咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;把咖啡倒进杯子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖和牛奶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从大的方面来讲，模板方法模式常被架构师用于搭建项目的框架，架构师定好了项目的骨架，程序员在继承了框架的结构之后，负责往里面填空。</p><p>模板方法模式是好莱坞原则（别调用我们，我们会调用你，高层组件调用低层组件）的一个典型应用。当使用模板方法模式的时候意味着子类放弃了对自己的控制权，而是改用父类去通知子类，哪些方法应该在什么时候被调用。作为子类，只负责提供一些设计上的细节。除此之外好莱坞原则还常常用于发布-订阅模式和回调函数。</p><h1 id="对-js-设计模式的误解"><a href="#对-js-设计模式的误解" class="headerlink" title="对 js 设计模式的误解"></a>对 js 设计模式的误解</h1><p>在 js 中第一个问题是习惯性将静态语言的设计模式照搬到 js 中，例如有人为了在 js 中模仿 Factory Method 模式，而生硬地将创建对象的步骤延迟到子类中，而实际上，在 Java 等静态语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合 DIP 原则。在这些语言中创建对象的时候哦，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。而在 js 这种类型模糊的语言中，对象多态是天生的，一个变量既可以指向一个类，又可以随时执行另一个类 —— js 中并不存在类型耦合的问题，自然也没有必要刻意去把对象的创建“推迟”到子类中，也就是说 js 实际上是并不需要工厂方法模式的。<em>模式的存在首先是能为我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既无用又麻烦！</em></p><p>另一个问题是习惯根据模式的名字去臆测模式的一切。例如命令模式的本意是把请求封装到对象中，利用命令模式可以解开请求发送者和请求接受者之间的耦合。但是命令模式经常被误解为只有一个名为 <code>execute</code> 的普通方法调用。这个方法除了叫做 execute 之外，其实并没有看出其他用途。所以很多人会误会命令模式的意图，以为它其实没有什么用途，从而联想到其他设计模式也没有什么用途。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红包业务系统的构建</title>
      <link href="/2021/02/20/redpacket-system/"/>
      <url>/2021/02/20/redpacket-system/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>红包系统本质上是高并发资金秒杀系统。</p><h2 id="架构一览"><a href="#架构一览" class="headerlink" title="架构一览"></a>架构一览</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redpacket-arch.png" alt="红包系统架构"></p><h2 id="系统演进之路"><a href="#系统演进之路" class="headerlink" title="系统演进之路"></a>系统演进之路</h2><ol><li>满足业务需求，快速迭代上线</li><li>出现超卖现象，启用事务锁</li><li>流量增加，收红包出现性能瓶颈，改为乐观锁，性能提升3倍</li><li>流量继续增加，乐观锁也扛不住了，上缓存</li><li>分布式 MQ 解决异步写</li><li>数据分片来解决 DB 横向拓展</li></ol><h1 id="业务场景需求分析"><a href="#业务场景需求分析" class="headerlink" title="业务场景需求分析"></a>业务场景需求分析</h1><p>红包发送者从红包商那里购买一定数量和一定金额的红包（每个红包的规格一样或者不一样），之后将红包商品赠送出去（对象是红包接受人群），收红包本质上是对红包商品的秒杀活动。存在 B2B 和 B2C 两个过程。</p><p>红包是小额金融产品：充值卡、购物卡</p><p>发红包：从中间商购买和发布<br>发红包：秒杀、兑换</p><p>红包资金账户满足用于红包业务资金账户的交易和记账。</p><h1 id="业务模型分析和设计"><a href="#业务模型分析和设计" class="headerlink" title="业务模型分析和设计"></a>业务模型分析和设计</h1><p><a href="https://www.infoq.cn/article/xh-four-color-modeling">四色建模法</a></p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/send-redpacket.png" alt="追踪事件和痕迹-发红包"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/get-redpacket.png" alt="追踪事件和痕迹-收红包"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redpacket-expiret.png" alt="追踪事件和痕迹-红包过期"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redpacket-core-model.png" alt="骨干模型构建-建立联系"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redpacket-actors.png" alt="寻找和添加参与者-人&amp;事&amp;物"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redpacket-roles.png" alt="添加角色"></p><h1 id="红包算法概述"><a href="#红包算法概述" class="headerlink" title="红包算法概述"></a>红包算法概述</h1><ul><li>简单随机法</li><li>2次随机算法：先随机再洗牌、先洗牌再随机</li><li>2倍均值法：微信红包算法</li></ul><p>红包序列是按照红包金额和数量通过算法进行拆分得到的子红包集合，红包序列可以在发红包时生成，也可以在抢红包时计算。</p><p>发红包时计算：红包可以预置，可以以商品交易系统的思路来进行构建，红包数量就是库存，抢红包的时候只需要从库存中扣除一个即可。缺点是会产生大量数据，造成大量DB读写操作。<br>抢红包时计算：发红包时只需要确定红包的几个基本属性，不需要生成实际的红包序列，在抢红包的时候动态构建和计算库存。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端杂谈</title>
      <link href="/2021/01/19/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/"/>
      <url>/2021/01/19/%E5%89%8D%E7%AB%AF%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么js要放在body最下面二css要放在head中？"><a href="#为什么js要放在body最下面二css要放在head中？" class="headerlink" title="为什么js要放在body最下面二css要放在head中？"></a>为什么js要放在body最下面二css要放在head中？</h1><p>浏览器拿到css就知道该怎么渲染HTML了，如果把css放在body下面则会先<strong>按照默认样式进行渲染</strong>，当css加载完成的时候会按照css的样式再渲染一遍，即发生了reflow。由于js会阻塞代码执行，所以js一般放在body最下面，还有一个原因：js放在最下面的时候就可以取得页面中所有的元素了。</p><h1 id="window-onload和DomContentLoaded有什么区别"><a href="#window-onload和DomContentLoaded有什么区别" class="headerlink" title="window.onload和DomContentLoaded有什么区别"></a>window.onload和DomContentLoaded有什么区别</h1><p>前者是页面的资源加载完成（包括图片、视频），后者是DOM渲染完即可，此时图片、视频可能还没加载完。</p><h1 id="图片懒加载的实现原理"><a href="#图片懒加载的实现原理" class="headerlink" title="图片懒加载的实现原理"></a>图片懒加载的实现原理</h1><p>先用一张默认的图片代替（这张默认的图片因为使用太频繁，浏览器可能缓存了）然后再更改img的src属性。<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2abac139-937e-4416-a48c-e1582866083e.png" alt="image.png"></p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>可以跨域的3个标签：</p><ul><li>img:可以用于打点统计，统计网站可能是其他域，使用img标签有一个好处：没有浏览器兼容性问题</li><li>link：可以使用CDN</li><li>script:可以使用CDN,可以JSONP</li></ul><p>本地3000端口开启了一个服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">now</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>()</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;api server started at 3000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        axios.<span class="title function_">get</span>(<span class="string">&#x27;http://127.0.0.1:3000&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">            .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/56cce1d9-800c-4f0e-9042-b869bc02ed34.png" alt="image.png"></p><p>使用JSONP实现跨域，服务端和客户端都进行一个很小的改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="string">`callback(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; now: <span class="keyword">new</span> <span class="built_in">Date</span>().toString() &#125;)&#125;</span>)`</span></span><br><span class="line">    res.<span class="title function_">end</span>(data)</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;api server started at 3000&#x27;</span>)</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get data&#x27;</span>, data)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:3000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/d7675956-1394-4431-bb7b-9a7070676839.png" alt="image.png"></p><p>以上是原理部分，就是服务器返回的数据包了一层函数，客户端有个同样名字的函数去接收。实际的开发中有很多现成的库。 </p><h1 id="页面有-100w-个任务需要执行，怎么保证页面不卡顿"><a href="#页面有-100w-个任务需要执行，怎么保证页面不卡顿" class="headerlink" title="页面有 100w 个任务需要执行，怎么保证页面不卡顿"></a>页面有 100w 个任务需要执行，怎么保证页面不卡顿</h1><p>主要是使用分治的思想，下面是其实现方案：</p><ol><li>requestIdleCallback</li><li>web worker: 缺点是不能操作dom</li><li>setTimeout: 自己去控制时间，每隔一小段执行一下</li></ol><h1 id="HTML-Collection-和-Node-List-区别"><a href="#HTML-Collection-和-Node-List-区别" class="headerlink" title="HTML Collection 和 Node List 区别"></a>HTML Collection 和 Node List 区别</h1><p>它们都是 ArrayLike，HTMLCollection 是实时的，NodeList 不是实时的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlCollection = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;item&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.item&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>document.getElementsByTagName(&#39;*&#39;)</code> 可以获得所有元素。<code>document</code> 上还有一些特殊的集合。<code>document.images</code> <code>document.forms</code> <code>document.links</code> 分别代表页面中所有的图片、表单、链接。</p><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>防抖(Debounce)：事件触发后延迟执行，若期间再次触发则重新计时。—— 搜索框输入、窗口 resize、按钮防止重复点击</p><p>节流(Throttle)：事件触发后在规定时间内只执行一次。无视触发频率，按照指定的间隔时间执行。—— 滚动事件、鼠标移动追踪、Canvas 绘制。</p><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>用户输入场景（搜索、表单）</strong></td><td>防抖</td><td>只需要在输入停止后处理一次，无需响应中间过程</td></tr><tr><td><strong>持续触发场景（滚动、拖拽）</strong></td><td>节流</td><td>需要按固定频率响应，确保操作流畅性</td></tr><tr><td><strong>按钮防重复提交</strong></td><td>防抖（立即执行）</td><td>点击后立即反馈，同时防止短时间内多次提交</td></tr><tr><td><strong>高频事件性能优化</strong></td><td>节流</td><td>限制事件处理频率，避免浏览器卡顿（如 window.resize 用节流可能比防抖更流畅）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>码农翻身有感</title>
      <link href="/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/"/>
      <url>/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>青青翠竹尽是法身，郁郁黄花无非般若。教育小孩和做团队 leader 有相通之处。</p></blockquote><p>做技术切记“本末倒置”，我非常痛恨那些采用 bottom-up 方式来讲解技术的资料和文章，一上来就是技术细节、安装步骤、配置丰富，让初学者晕头转向，不知所云，看完以后也不知道为什么要有这个东西、解决了什么问题、它有什么来龙去脉。换句话说，这些资料和文章习惯于讲解 How，而不是 Why，但是在我看来，Why 有时候比 How 更重要。</p><p>当你改变不了别人的时候，抱怨也没有用，还是要先改变一下自己。</p><p>程序的局部性原理可以从时空两个维度来进行解释。</p><p>时间局部性：如果程序中某条指令开始执行，则不久之后该指令可能被再次执行；如果某数据被访问，则不久之后该数据可能被再次访问。<br>空间局部性：一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被再次访问。</p><p>GSM 技术的核心是时分多址(TCDMA),将每个无线电频率按照时间均匀分给 8 (或者 16) 个用户，每个用户交互占用 1&#x2F;8 的信道时间(人们通话的时候,语音的实际间隔时间其实很长,只要编码合理,就可以多用户公用一个信道)</p><p>设计模式就是在某种场合下对某个问题的一种解决方案。就是给面向对象程序设计中的一些好的设计取个名字。</p><p>互联网公司的崛起大概是在 2012 年左右移动互联网开始出现，互联网的渗透率得以加速，BAT 逐渐开始成为家喻户晓的名字。其次，经过前面时间的积累，互利网企业主导的各种分布式、大数据、移动互联网、云计算等技术的风头开始超过传统的 IT 巨头，阿里开始去 IOE，打造自己的云计算平台，成为先进技术的代表着；最主要的还是互利网企业盈利能力大幅增加，能够提供市场上更有竞争力的薪水和股票。于是互利网企业在人才市场上开始变得炙手可热，BAT 这些企业开始被人称为“大厂”。今天我们感觉这些互联网巨头高高在上，人们纷纷向往。事实上，这个现象出现的时间非常短。今天这些企业有足够的名字和资源将自己营造得高高在上，可以在众多优秀的候选人中挑来选去，仅仅在 10 年前，还不是这样的。但是事情的真正的吊诡之处还不在这里，当今这些互联网大厂的核心技术和业务模式在十几年前就已经奠定了，经过几年的探索，大概在七八年前开始稳定成熟。也就是说互联网企业的技术实力和商业能力是在这些企业还默默无闻的时候就发展起来的，而在这些企业成为明星之后，并没有得到突破性的进展。想想这些所谓的互利网大厂，最近几年并没有什么值得称道的商业模式创新和技术创新。也就是说：十多年前，可能是一些并不优秀的技术人员加入到一个并不出名的公司，然后这些人开创了一个杰出的事业。用马云的话说，就是“二流的人做一流的事”。然后公司开始挑选一流的人，但结果似乎只是在维持这个事业，并没有开创出更加杰出的事业。今天的 BAT 似乎成为了当年的 IBM，历史好像进入了某种循环。如果这就是事情的真相，那么我们或许可以从中得到某种启发，重新考虑下未来的职业规划。也许就会发现：我们可能不需要追逐当前所谓的热门技术，而应该好好想想需要为自己的未来准备些什么。</p><h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h1><h2 id="德雷福斯模型"><a href="#德雷福斯模型" class="headerlink" title="德雷福斯模型"></a>德雷福斯模型</h2><p>专业人员能力成长模型，这个模型认为所有专业人员都需要经历 5 个成长阶段，不管是医生、律师还是软件开发，任何专业技能的从业者都需要经历新手、高级新手、胜任者、精通者、专家 5 个阶段。</p><p>任何一个人进入专业的技能领域，即使在学校已经系统学习过这个专业的相关知识，但是依然无法独立完成工作，必须在有经验的同事指导下，学习相关技能。这里主要学习的是有关工作的规则和套路。比如用什么工具、框架，如何开发程序，如何开会、写周报，如何和同事合作，业务领域的名词是什么意思等等这些这种各样和工作有关的大小事情。这个阶段叫做<em>新手</em>阶段。</p><p>通常说来，一个人大约工作了 2-3 年后，就差不多掌握了工作的各种套路，可以拜托新手阶段，独立完成一些基本的工作了。通过新手阶段的人，少部分会直接进入胜任者阶段，而大多数则进入<em>高级新手</em>阶段。高级新手通常是新手的自然延续，他不需要别人指导工作，也不需要学习工作的规则和套路，因为高级新手已经在新手阶段掌握了这些套路，他可以熟练应用这些规则套路完成它的工作。但是高级新手的能力也仅限于此，他不明白这些规则是如何指定出来的，为什么使用这个框架开发而不是另一个框架，也不明白这个框架是如何开发出来的。</p><p>因此，一旦需要解决的问题和过往的问题有很大不同，以往的规则套路无法解决这些新问题的时候，高级新手就抓瞎了，不知道怎么办。</p><p>一个悲观的事实是，新手会自然进入高级新手阶段，而高级新手却无法自然进入其后的其他等级阶段。实际上，<strong>在各个专业领域，超过半数的人终其一生都停留在高级新手阶段</strong>。也就是说：大多数人一生的工作就是机遇其专业领域的规则在进行重复性劳动。他们不了解这些规则背后的原理，也无法在面对新问题时，开创出新的方法和规则。那些简历上十多年如一日使用相同的技术方案、开发类似软件项目的资深工程师大部分都是高级新手。</p><p>导致一个人终身停留在高级新手阶段的原因有很多，其中一个重要的原因就是：<strong>高级新手不知道自己是高级新手</strong>。高级新手觉得自己在这个专业领域混得不错，做事熟练，经验丰富。</p><p>事实上，这种熟练只是对既有规则的熟练，如果岁月静好，一切都循规蹈矩，也没有什么问题。而一旦行业出现技术变革或者工作出现新情况，高级新手就会遇到巨大的工作困难。事实上，各行各业都存在大量的高级新手，只是软件开发领域的技术变革更加频繁，问题变化也更加快速，使得高级新手的问题更加突出。</p><p>少部分新手和高级新手会在工作中学习、领悟规则背后的原理，当需要解决的问题变化，或者行业出现技术革新时，能够尝试学习新技术、解决新问题，这样的人就进入<em>胜任者</em>阶段。胜任者工作的一个显著特点：<strong>做事具有主动性</strong>。他们在遇到新问题时，会积极寻求新的解决方案去解决问题，而不是像高级新手那样，要么束手无策，要么还是用老办法解决新问题，使问题更加恶化。</p><p>胜任者能解决新问题，但他们通常只会见招拆招，局限于解决问题本身，而缺乏反思精神和全局思维：为什么会出现这样的问题？如何避免类似问题再发生？这个问题在更宏大的背景下处于什么位置？还有哪些类似的问题？</p><p>而拥有反思精神和全局思维，即使没有新问题也能进行自我突破、寻求新的出路的人，就进入了<em>精通者</em>阶段。<strong>精通者需要通过主动学习进行提升，主动进行大量的阅读和培训</strong>而不是仅仅依靠工作中的经验和实践。他们在完成一个工作后会反思：哪些地方可以改进，下次怎么做会更好？</p><p>精通者<strong>拥有了自我改进的能力</strong>。</p><p>高级新手会把规则当做普适性的真理而使用，甚至引以为豪；而精通者则会明白所有的规则只会在特定的场景下才会有效，<strong>工作中最重要的不是规则，而是对场景的理解。</strong></p><p>而最终，各行各业大约只有 1% 的人会进入<em>专家</em>阶段，专家把过往的经验都融会贯通，然后形成一种直觉，他们直觉地知道事情应该怎么做，然后用**最直接、最简单的方法把问题解决。**专家通常也是他所在领域的权威，精通者和胜任者会学习、研究专家是如何解决问题的，然后把这种解决方案形成套路，成为行业做事的规则。</p><h2 id="如何在工作中成长"><a href="#如何在工作中成长" class="headerlink" title="如何在工作中成长"></a>如何在工作中成长</h2><p>德雷福斯模型告诉我们，人的专业能力不会随着工作年限的增加而自然增长，多数人会终身停留在高级新手阶段。那么如何在工作中不断成长，提升自我，最终成为专家？有以下几个建议：</p><ol><li>用于承担责任。如果只是遵循别人的指令，按照别人的规则做事，你用于不会指知道事物的真相是什么，只有对结果负责，压力之下，才会看透事物的本质，才会抓住核心和关键。</li><li>在实践中保持技能。通俗来说就是要摘那些跳起来才够得着的苹果，只要再进入一点点就能完成，通过这样持续的工作训练和挑战，在实践中持续获得进步，就可以不断从新手到专家这个方向前进。</li></ol><p>有些成功是可遇不可求的，至少要做到团队影响力，努力做到公司影响着，且不仅仅要做到，还要做好。在技术之路上，绝大多数人都是分母，但是这不能是自己不努力的理由。也许我们多么努力都达不到别人的成功，但是不要放弃，你的努力会时刻影响着你。</p><p>做为软件工程师，如果只是听从别人的指令开发代码，却不了解这些代码究竟想要解决什么问题，很多时候你是在制造问题，而不是解决问题。加班加点辛苦工作只是在给公司制造麻烦。对于自己而言，日复一日重复执行解决方案，距离成为一个技术专家也越来越远。</p><h1 id="如何有效沟通"><a href="#如何有效沟通" class="headerlink" title="如何有效沟通"></a>如何有效沟通</h1><p>在日常生活工作中，总要和很多人合作。有时候，我们需要依赖别人的工作结果，以作为我们工作的输入；有时候，我们的工作产出需要交付给别人，才能产生最终的价值。这这些合作过程中，可能会遇到各种问题。</p><h2 id="如果某人能解决问题，而他自己却感受不到问题，那么就让他感受一下"><a href="#如果某人能解决问题，而他自己却感受不到问题，那么就让他感受一下" class="headerlink" title="如果某人能解决问题，而他自己却感受不到问题，那么就让他感受一下"></a>如果某人能解决问题，而他自己却感受不到问题，那么就让他感受一下</h2><p>在工作合作的过程中，有的时候，对于对方来说，明明是举手之劳的事情，但他偏偏在拖延，你去催促也没有什么效果。这时候，我们很容易将问题归结为对方的工作态度有问题，事实上，很多时候，其实是对方没有理解你的问题，他觉得你在没事找事，你才是工作态度有问题的人。</p><p>将问题归结为人的态度问题，大多数情况下，是无法解决问题的，况且，很多时候确实不是态度问题，而是不同的人做事能力、理解能力、立场和看待事物的角度不同。所以，如果只是立场和角度的问题，那么就可以将对方拉到同一立场来解决问题。如果对方没有感受到问题，那么想办法让对方感受一下问题。</p><p>通常来说，上司的能力要比你自己的能力强，调动的资源也比你多，有些事情对你而言可能非常困难，但是你的上司也许一句话就可以搞定，这个时候就可以考虑利用自己的上司去解决问题。如果他没有感受到问题，就想办法让他感受到问题。</p><p>有句话说：<strong>用人的最高境界是用上司。</strong></p><p>有的时候，对于一件有风险的工作，如果你自己做决策，那么放事情不顺利的时候，你可能无法承担风险，那么就应该将上司拉进来。你可以直接问他：有这样的方案和计划，你觉得合适么？但是这种提问方式，可能会导致你的方案被上司否定，更好的提问方式是：这里有 A,B 两个方案，你觉得哪个方案更合适？从而将上司的回答引导到你期望的答案上去。而上司一旦回答了你的问题，就等于参与到你的工作中去了，当事情出现风险的时候，你再去找他寻求支持的时候，因为是他曾经做出的决策，那么他更容易跟你站在一起，帮你解决问题。这里需要注意的是，当你寻求上司支持的时候，不要问上司怎么办，不要给上司提开放式的问题。一则上司可能不理解你的问题上下文，无法给出合适建议，从而使上司和你都难堪。再则上司如果给出的方案你你难以执行的，你是在给自己挖坑。而封闭式的问题，只需要回答好或者不好都可以了 —— 例如选择 A 方案还是 B 方案。</p><p>相反，如果你给下属提问，就不要提封闭式的问题了，你问下属这个方案好不好可能会导致他质疑你的能力，同时也限制了他的能动性，使他无法思考和调查更多的解决方案。</p><h2 id="直言有讳"><a href="#直言有讳" class="headerlink" title="直言有讳"></a>直言有讳</h2><p>在合作的过程中，合作的小伙伴可能犯一些错误，如果这个错误影响了你，你应该指出来，而不是为了和谐假装视而不见，任由事情向失败的方向滑落。但是，这里需要注意的是，指出错误是为了改正错误，达成目标，而不是为了责备、打压对方，也就是所谓的：<em>要批评不要责难，要对事不对人</em>。</p><p>如果针对人，那么对方就一定和你站在对立的一面，你们就是在进行人际斗争，而不是在解决问题。<em>直言有讳</em>就是说，指出负面情况的时候，要直接，不要兜圈子、说含糊话，否则语言就没有力量，无法解决问题。但是也不是想说什么就说什么，要有所避讳，主要就是不要把问题指向人。可以说这件事情这样做是不对的，但是不要说你这个人是有问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>网络层和数据链路层的桥梁。</p><p>通过IP地址找到MAC地址,只适用于IPv4，不能用于IPv6（可以用ICMPv6替代ARP发送邻居探索消息，融合了IPv4中的ARP,ICMP重定向和ICMP路由选择，甚至还能自动设置IP地址：和DHCPv6结合）。ARP是通过ARP请求和ARP响应两种类型的包来确定MAC地址的。</p><blockquote><p>IPv6中ICMP的作用被放大，如果没有ICMPv6，IPv6无法正常通信。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ARP.png" alt="ARP的工作机制.png"></p><p>如上图所示主机A为了获得主机B的MAC地址，要通过广播发送一个ARP请求包，这个包包含了想要了解其MAC地址的主机的IP地址。如果ARP请求包中的目标IP和自己的IP地址一致，那么这个节点就将自己的MAC地址塞入到ARP响应包中返回给主机A。</p><blockquote><p>ARP请求包还有一个作用：将自己的MAC地址告诉对方</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>中间节点并不承诺提供可靠的连接通道，物资完全可能失序、重复、甚至丢失。所谓可靠完全由两个端点来实现。</p><p>TCP要求无论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况如何变化，都必须保持这个特性。因此它每次发包都会计算往返时间及其偏差（RTT:Round Trip Time）。数据被重发之后如果还是收不到确认应该，则会再次进行发送，此时确认应答的时间将会以2倍，4倍的指数函数延长。此外，数据也不会被无限、反复重发。达到一定重发次数之后，如果还是没有任何确认应答返回，就会判断为该网络或者对端主机发生异常，强制关闭连接，并且通知应用通信通信异常强行终止。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>窗口大小是指无需等待确认应答而可以继续发送数据的最大值，这个机制大量使用了缓冲区。可以对多个段同时进行确认应答。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/scroll-window.png" alt="滑动窗口"></p><p>如下图所示，当某一段报文丢失的时候，发送端会一直收到序号为1001的确认应答，这个确认应答好像在提醒发送端“我想接收的是从1001开始的数据”。因此，在窗口比较大，又出现报文段丢失的情况下，同一个序号的确认应答将会被重复不断返回。而发送端主机如果连续3次收到同一个确认应答就会对其所对应的数据进行重发。这种机制比超时管理更加高效，因此也被称为高速重发机制。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/high-speed-resend.png" alt="高速重发机制"></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>一般来说，计算机网络处于一个共享的环境，因此有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果突然发送一个较大量的数据，极有可能会导致整个网络的瘫痪。为了防止该问题的出现，在通信开始的时候就会通过一个叫做<em>慢启动</em>的算法得出的数据，对发送数据量进行控制。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 优化总结</title>
      <link href="/2020/09/13/MySQL%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/13/MySQL%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/15603997-6500-4093-9710-d8eeafb7ee6d.png" alt="MySQL服务器调优思路"></p><p>第一步要做的是确定问题的症结，而不是一上来就看表结构和查询语句。</p><h2 id="开启profiling"><a href="#开启profiling" class="headerlink" title="开启profiling"></a>开启profiling</h2><blockquote><p>MySQL默认会开启缓存池，本地调试的时候清除缓存的命令是：<code>reset query cache</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like <span class="string">&#x27;%profi%&#x27;</span>;  </span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; <span class="built_in">set</span> profiling=on;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开之后就可以查看每一次查询了</span></span><br><span class="line">MariaDB [(none)]&gt; show profiles;</span><br><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                         |</span><br><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">|        1 | 0.00033615 | show variables like <span class="string">&#x27;%profi%&#x27;</span> |</span><br><span class="line">+----------+------------+-------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看查询每一步的耗时</span></span><br><span class="line">MariaDB [(none)]&gt; show profile <span class="keyword">for</span> query 1;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000034 |</span><br><span class="line">| Opening tables       | 0.000027 |</span><br><span class="line">| After opening tables | 0.000003 |</span><br><span class="line">| System lock          | 0.000002 |</span><br><span class="line">| Table lock           | 0.000002 |</span><br><span class="line">| After table lock     | 0.000004 |</span><br><span class="line">| init                 | 0.000007 |</span><br><span class="line">| optimizing           | 0.000010 |</span><br><span class="line">| statistics           | 0.000014 |</span><br><span class="line">| preparing            | 0.000006 |</span><br><span class="line">| executing            | 0.000002 |</span><br><span class="line">| Filling schema table | 0.000185 |</span><br><span class="line">| executing            | 0.000002 |</span><br><span class="line">| Sending data         | 0.000012 |</span><br><span class="line">| end                  | 0.000003 |</span><br><span class="line">| query end            | 0.000002 |</span><br><span class="line">| closing tables       | 0.000002 |</span><br><span class="line">| removing tmp table   | 0.000004 |</span><br><span class="line">| closing tables       | 0.000002 |</span><br><span class="line">| freeing items        | 0.000003 |</span><br><span class="line">| updating status      | 0.000008 |</span><br><span class="line">| cleaning up          | 0.000003 |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">22 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>一般的优化就是 profiling 结合 explain。explain 中几个注意点如下：</p><ul><li>possible_keys: 可能用到的索引, 系统估计可能用的几个索引, <strong>但最终只能用1个</strong></li><li>key : 最终用的索引</li><li>key_len: 使用的索引的最大长度</li></ul><p>重点关注的是：type，是分析查数据过程的重要基于</p><ul><li>all: 意味着从表的第1行,往后,逐行做全表扫描,运气不好扫描到最后一行.</li><li>index: 比 all 性能稍好一点，通俗的说: all 扫描所有的数据行, 相当于data_all，index 扫描所有的索引节点,相当于 index_all，两种情况下可能出现：<ul><li>索引覆盖的查询情况下, 能利用上索引,但是又必须全索引扫描；</li><li>利用索引来进行排序,但取出所有的节点。</li></ul></li><li>range: 能根据索引，做范围扫描  </li><li>ref：通过索引列可以直接引用到<em>某些</em>数据行</li><li>eq_ref：指通过索引列直接引用<em>某1行</em>数据（常见于连接查询中）</li><li>const, system, null 这3个分别指查询优化到常量级别, 甚至不需要查找时间。一般按照主键来查询时,易出现 const,system；直接查询某个表达式,不经过表时, 出现 NULL</li></ul><p>ref 列：连接查询的时候前表和后表的引用关系</p><p>rows 列：表示<em>预估</em>扫描的行数</p><p>extra 列：</p><ul><li>using index:是指用到了索引覆盖,效率非常高</li><li>using where 是指光靠索引定位不了,还得where判断一下 </li><li>using temporary 是指用上了临时表, group by 与order by 不同列时,或group by,order by 别的表的列.</li><li>using filesort : 文件排序(文件可能在磁盘,也可能在内存)</li></ul><p>select sum(shop_price) from goods group by cat_id(????  这句话,用到了临时表和文件排序) </p><blockquote><p>SQL性能优化的目标，至少要达到 range 级别，要求是 ref 级别，最好是 const。</p></blockquote><h2 id="MySQL状态监控收集"><a href="#MySQL状态监控收集" class="headerlink" title="MySQL状态监控收集"></a>MySQL状态监控收集</h2><p>定时收集MySQL的指标绘制成图表，便于查询分析问题。</p><ul><li><code>show status;</code>可以查看服务器状态，重点观察以下几个指标：<code>Queries</code>,<code>Threads_connected</code>,<code>Threads_running</code>。可以根据这个指标计算出QPS。</li><li><code>show proceslist;</code>显示了哪些线程在运行，重点关注：<code>State</code>列。</li></ul><p>几个很耗时的状态如下,尽量避免：</p><ul><li>Convert HEAP to MyISAM:查询结果太大内存放不下放在磁盘，<code>show variables like &#39;%tmp_table%&#39;</code>，少取数据或者调整服务器配置临时表的大小</li><li>Create tmp table:如group的时候创建临时表</li><li>Copying to tmp table on disk:</li><li>Sending data:发送数据过多</li><li>Sorting result</li><li>Locked:被其他查询锁住</li></ul><h2 id="表优化和列类型选择"><a href="#表优化和列类型选择" class="headerlink" title="表优化和列类型选择"></a>表优化和列类型选择</h2><ul><li>字段类型选择优先级：整数 &gt; data,time &gt; char,vchar &gt; blob，字符串类型要考虑字符集的转换和排序的时候的校对集</li><li>字段类型够用就行，能用smallint都不要用int</li><li>避免用NULL:不利于索引，要用特殊字节标注，在磁盘上的空间其实更大</li></ul><p>一般而言group by需要按照分组字段进行排序，排序结果放在临时表，然后根据临时表做聚合操作。因此explain的时候会出现<code>Using temporary</code>和<code>Using filesort</code>。</p><blockquote><p>MyISAM会缓存<code>count(*)</code>，一旦有where查询<code>count(*)</code>速度就不快了，尤其是where的列没加索引的情况下。<br>union all不过滤效率较高，去重应该放在程序里面。</p></blockquote><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c2390ab0-e515-421e-a4d6-8552ae6ef926.png" alt="sql优化"></p><p>**判断是否存在使用<code>EXISTS</code>而不要使用<code>COUNT(*)</code>。**例如：<code>select exists(select * from account0 where uid =1);</code>可以替代<code>select count(*) from account0 where uid = 1</code>。（语义上更清晰，同时 <code>EXISTS</code> 是短路操作）。</p><p><strong>尽量不要使用非参数化的负向查询</strong>，因为这个无法利用索引。例如<code>&lt;&gt;</code>,<code>not in</code>,<code>not like</code>,<code>not exists</code>,<code>not between</code>,<code>is not null</code>。</p><p>**不要在 <code>WHERE</code> 子句中对字段进行运算或者函数。**例如<code>where amount / 2 &gt; 100</code>，即使 amount 字段上有索引也不会用到，改成<code>where amount &gt; 200</code> 即可利用索引。</p><p><strong>在 min，max，distinct，order by，group by 操作的列上建立索引可以避免额外的开销。</strong></p><p>**千万不要 <code>ORDER BY RAND()</code>。**想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。如果你真的想把返回的数据行打乱了，你有 N 种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL 会不得不去执行 <code>RAND()</code> 函数（很耗 CPU 时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了 <code>LIMIT 1</code> 也无济于事（因为要排序）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千万不要这样做：</span></span><br><span class="line"><span class="variable">$r</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这要会更好：</span></span><br><span class="line"><span class="variable">$r</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SELECT count(*) FROM user&quot;</span>);</span><br><span class="line"><span class="variable">$d</span> = <span class="title function_ invoke__">mysql_fetch_row</span>(<span class="variable">$r</span>);</span><br><span class="line"><span class="variable">$rand</span> = <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="variable">$d</span>[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line"><span class="variable">$r</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;SELECT username FROM user LIMIT <span class="subst">$rand</span>, 1&quot;</span>);</span><br></pre></td></tr></table></figure><p>**永远为每张表设置一个 ID。**我们应该为数据库里的每张表都设置一个 ID 做为其主键，而且最好的是一个 INT 型的（推荐使用 UNSIGNED），并设置上自动增加的 AUTO_INCREMENT 标志。就算是你 users 表有一个主键叫 “email” 的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的 ID 来构造你的数据结构。而且，在 MySQL 数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区…… 在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的 ID，有一个“课程表”有课程 ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生 ID 和课程 ID 叫“外键”其共同组成主键。</p><p>**把 IP 地址存成 UNSIGNED INT。**很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的 IP 而不是 INT 型的 IP。如果你用 INT 来存放，只需要 4 个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的 WHERE 条件：IP between ip1 and ip2。我们必需要使用 UNSIGNED INT，因为 IP 地址会使用整个 32 位的无符号整型。而你的查询，你可以使用 INET_ATON() 来把一个字符串 IP 转成一个整型，并使用 INET_NTOA() 把一个整形转成一个字符串 IP。在 PHP 中，也有这样的函数 ip2long() 和 long2ip()。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$r</span> = <span class="string">&quot;UPDATE users SET ip = INET_ATON(&#x27;&#123;<span class="variable">$_SERVER</span>[&#x27;REMOTE_ADDR&#x27;]&#125;&#x27;) WHERE user_id = <span class="variable">$user_id</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>**固定长度的表会更快。**如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。例如，表中没有如下类型的字段：VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。固定长度的表会提高性能，因为 MySQL 搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p><p>使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。</p><p><strong>垂直分割。</strong>“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有 100 多个字段，很恐怖。）</p><p>示例一：在 Users 表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</p><p>示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</p><blockquote><p>当对一个表进行任何写操作(INSERT, UPDATE, DELETE) 时，与该表相关的所有查询缓存都会被标记失效，即使更新的数据只影响表中很小的一部分，缓存也会清空，导致命中率下降。在写密集型的应用中，频繁缓存失效会引发大量缓存重建，反而增加系统开销（例如全局锁竞争）。查询缓存本身也要占用大量内存，在高动态数据环境下收益可能非常低。MySQL 8.0 已经移除了查询缓存。</p></blockquote><p>另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去 Join 他们，不然的话，这样的性能会比不分割时还要差，而且，会是指数级的下降。</p><p><strong>拆分大的 DELETE 或 INSERT 语句。<strong>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会</strong>锁表</strong>的，表一锁住了，别的操作都进不来了。Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。如果你把你的表锁上一段时间，比如 30 秒钟，那么对于一个有很高访问量的站点来说，这 30 秒所积累的访问进程&#x2F;线程，数据库链接，打开的文件数，可能不仅仅会让你的 WEB 服务 Crash，还可能会让你的整台服务器马上挂了。所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例： </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//每次只做1000条</span></span><br><span class="line">    <span class="title function_ invoke__">mysql_query</span>(<span class="string">&quot;DELETE FROM logs WHERE log_date &lt;= &#x27;2009-11-01&#x27; LIMIT 1000&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">mysql_affected_rows</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没得可删了，退出！</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次都要休息一会儿</span></span><br><span class="line">    <span class="title function_ invoke__">usleep</span>(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7b97616e-48d8-4b87-8c7e-92bd0564d8fb.png" alt="索引优化"></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="https://www.cnblogs.com/chancy/p/10684452.html">mysql explain type的解释</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - 操作系统</title>
      <link href="/2020/09/08/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/09/08/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="文件是如何组织的"><a href="#文件是如何组织的" class="headerlink" title="文件是如何组织的"></a>文件是如何组织的</h1><p>文件系统将硬盘空间以块为单位进行划分，每个文件占据若干个块，然后再通过一个文件控制块 FCB 记录每个文件占据的硬盘数据块。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/b3237593-3e45-40d9-be1d-aee9a9bb03fe.png" alt="image.png"></p><p>这个文件控制块在Linux操作系统中就是<code>inode</code>，要想访问文件，就必须获得文件的<code>inode</code>信息，在<code>inode</code>中查找文件数据块索引表，根据索引中记录的硬盘地址信息访问硬盘，读写数据。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2512d95b-8bc6-4156-bafe-c0045bb37c51.png" alt="image.png"></p><p><code>inode</code>中记录着文件权限、所有者、修改时间和文件大小等文件属性信息，以及文件数据块硬盘地址索引。</p><p>RAID5将数据划分为N-1片，再利用N-1片数据进行位运算，得到一片校验数据，然后将这N片数据写入到N个硬盘。这样任何一块硬盘损坏都可以利用校验片的数据和其他片的数据进行计算得到丢失的那个数据，而硬盘的利用率也达到了<code>N-1 / N</code>。这样兼顾了磁盘利用率、读写速度和数据可用性，实际生产中用的最多。</p><blockquote><p>RAID5中校验位的生成采用的是异或运算。所有数据的bit位，逐位进行异或，得到的就是校验位。如果丢失部分数据，用校验数据和其余数据逐位进行异或运算，可到丢失部分数据。举例，5块磁盘做RAID5，四块磁盘上的bit为：0 1 1 1 ，那么异或计算后，校验位为 1，如果丢失了第一块盘上的bit位0，那么校验位1和其他三块盘上的bit位进行异或运算，可以算出0。</p></blockquote><h1 id="进程、线程、协程、管程"><a href="#进程、线程、协程、管程" class="headerlink" title="进程、线程、协程、管程"></a>进程、线程、协程、管程</h1><p>进程：资源分配的基本单位<br>线程：程序执行的基本单位</p><p>线程通过Linux的线程调度器进行调度。线程上下文切换指的是CPU保存原线程现场（一般放在CPU的cache中），执行新线程，恢复现场继续执行原线程的过程。</p><p>线程分为用户线程和内核线程（OS负责创建），JAVA中的每一个线程都是由JVM负责创建，对应OS中的一个内核线程，JVM中的线程和内核线程数量为1:1</p><p>golang在启动的时候会初始化一堆内核线程，goroutine启动之后会放在队列中交给内核线程执行，从这方面来讲go routine更像是一个个task。go routine非常类似Java中的线程池。golang在用户空间模拟了CPU的执行。</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><p>面向无连接的方式下可能会有很多的冗余通信。</p><p>为什么IP层面向无连接？</p><p>原因有2点：简化和提速。面向连接比面向无连接处理相对复杂，甚至管理每个连接本身是一个相反繁琐的事情。此外每次通信之前需要实现建立连接又会降低处理速度。需要有连接的时候可以委托上一层提供此项服务。因此IP为了实现简单化和高速化采用面向无连接的方式。</p><p>为了提高可靠性，上一层的TCP采用面向有连接型。</p><p>IP提供尽力服务(Best Effort)：为了把数据包发送到目标地址，尽最大努力，并不做最终收到与否的验证。IP数据包可能在途中丢包、错位、数据量翻倍的问题。</p><p>为什么IP层不提供可靠传输的功能？</p><p>如果要一种协议规定所有的功能和作用，那么该协议的具体实现和编程将会变得非常复杂，相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层协议进行编程会更有利于该协议的实现。</p><p>IP包的首部有1个字节表示TTL，表示可以中转多少路由器。每经过一个路由器，TTL会减少1，变为0则丢弃这个包。可以避免IP包在网络中无限传递的问题。</p><ul><li>IP是分组交换的一种协议，面向无连接，它不具备重发机制，属于非可靠性传输协议。</li><li>TCP&#x2F;UDP属于传输层的协议，首部使用的源端口和目标端口进行唯一性确认，而IP地址是位于网络层。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/mokafamily/p/9975980.html">Golang并发原理及GPM调度策略</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - 数据库</title>
      <link href="/2020/08/01/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/08/01/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>辩证唯物主义告诉我们，事物发展轨迹是波浪式前进，螺旋式上升，有的时候似乎重新回到过去，但是却有了本质的区别和进步。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-outline.png" alt="MySQL 知识体系大纲"></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="为啥索引能加快查询速度"><a href="#为啥索引能加快查询速度" class="headerlink" title="为啥索引能加快查询速度"></a>为啥索引能加快查询速度</h2><blockquote><p>索引其实也是一种空间换时间的思路。</p></blockquote><p>数据库索引使用 B+ 树，B+ 树是一种 N 叉排序树，树的每个节点包含 N 个数据，这些数据按顺序排好，两个数据之间是一个指向子节点的指针，而子节点的数据则在这两个数据大小之间。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8ab6cfb3-8d6e-4167-80b7-ab0cfc8776a5.png" alt="B+树"></p><p>如上图所示：B+ 树的节点存储在磁盘上，每个节点存储 1000 多个数据，这样树的深度最多只要 4 层就可以存储数亿的数据。如果将树的根节点缓存在内存中，则最多只需要三次磁盘访问就可检索到需要的索引数据。</p><blockquote><p>B 树和 B+ 树的区别：B 树的每个节点存储了记录的索引信息，而 B+ 树存储的是索引，只有在叶子节点存储的是全量的信息。并且 B+ 树在叶子节点有一个链表的结构，在范围查找的时候横向遍历会非常方便（不需要回溯到父节点再拓展向下）。</p></blockquote><p>B+ 树只是加快了索引的检索速度，如何通过索引加快数据库记录的查询速度呢？</p><p>数据库索引有两种，一种是聚簇索引，聚簇索引的数据库记录和索引存储在一起，上面这张图就是聚簇索引的示意图，在叶子节点，索引 1 和记录行 r1 存储在一起，查找到索引就是查找到数据库记录。像 MySQL 数据库的主键就是聚簇索引，主键 ID 和所在的记录行存储在一起。MySQL 的数据库文件实际上是以主键作为中间节点，行记录作为叶子节点的一颗 B+ 树。</p><p>另一种数据库索引是非聚簇索引，非聚簇索引在叶子节点记录的就不是数据行记录，而是聚簇索引，也就是主键，如下图：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6d1fa5dd-9a76-4438-abaa-fbe7b8bc6849.png" alt="非聚簇索引"></p><p>通过 B+ 树在叶子节点找到<em>非聚簇索引a</em>，和索引 a 在一起存储的是主键 1，再根据主键 1 通过主键（聚簇）索引就可以找到对应的记录 r1。这种通过非聚簇索引找到主键索引，再通过主键索引找到行记录的过程也被称作<strong>回表</strong>。</p><p>所以通过索引，可以快速查询到需要的记录，而如果要查询的字段上没有建索引，就只能扫描整张表了，查询速度就会慢很多。</p><p>MyISAM 引擎索引（无论是否是主键索引）指向磁盘上的物理行；而 InnoDB 引擎主键索引（聚簇索引：数据和索引在一块）是和数据记录保存在一起的，一般索引（非聚簇索引）存储的是主键。</p><p>B+ 树的页面会分裂，对于聚簇索引这个问题比较严重。对于 MyISAM，节点存储的是物理行的地址，内容较小又缓存在内存里，分裂速度快很多，InnoDB 节点下存储了行的数据，分裂的时候还需要移动数据，比较耗时。因此 InnoDB 对于主键的选择非常敏感，如果碰到不规则数据插入时,造成频繁的页分裂。</p><blockquote><p>聚簇索引的主键值,应尽量是连续增长的值,而不是要是随机值, (不要用随机字符串或 UUID)否则会造成大量的页分裂与页移动.</p></blockquote><p>索引覆盖指的是查询的数据在索引中都能找到，不需要回表（explain 的 extra 列有<code>using index</code>）。</p><h2 id="为什么-hash-索引使用较少"><a href="#为什么-hash-索引使用较少" class="headerlink" title="为什么 hash 索引使用较少"></a>为什么 hash 索引使用较少</h2><p>在 memory 存储引擎的表里，默认是 hash 索引, hash 的理论查询时间复杂度为O(1)。但是并不常用，原因有以下几点：</p><ol><li>hash 函数计算后的结果是随机的，如果是在磁盘上放置数据，例如主键为 id 为例，那么随着 id 的增长, id 对应的行，在磁盘上随机放置（磁盘的顺序查找优于随机查找）</li><li>无法对范围查询、排序进行优化</li><li>无法利用前缀索引。 比如在 btree 中, field 列的值“hellopworld”，并加索引查询 xx&#x3D;helloword，自然可以利用索引, xx&#x3D;hello，也可以利用索引(左前缀索引)。而 hash(‘helloword’) 和 hash(‘hello’) 两者的关系仍为随机，无法利用索引</li><li>必须回表，也就是说通过索引得到数据的位置后，必须回到表中取数据</li></ol><h2 id="如何设计索引"><a href="#如何设计索引" class="headerlink" title="如何设计索引"></a>如何设计索引</h2><p>好的索引应该查询频繁、区分度高、长度小（其中区分度和长度是互斥的，需要做一些权衡）、尽量覆盖常用查询字段。索引长度直接影响索引文件的大小，影响增删改的速度，并间接影响查询速度(占用内存多)。</p><p>对于左前缀不易区分的列，例如 url 列：<a href="http://www.baidu.com/">http://www.baidu.com</a> 和 <a href="http://www.qq.com/">http://www.qq.com</a> 前 11 个字符都是相同的，有以下 2 种建立索引的技巧：</p><ol><li>可以考虑存储的时候倒序存储，db 中存储：moc.udiab.www&#x2F;&#x2F;:ptth和moc.qq.www&#x2F;&#x2F;:ptth，这样左前缀的区分度就更大了</li><li>多加一列 url_hash（可以采用 crc_32 ）,<code>update t_url set url_hash = crc32(url)</code>，在 url_hash 上建立索引，索引长度将大幅减少</li></ol><p>通用的准则如下：</p><ul><li>主键应该用递增的值，不要用离散的值，离散值会导致文件在磁盘上的位置有间隙，浪费空间，且不容易顺序读取。</li><li>uuid 也是逐步增长的，可以考虑去掉<code>-</code>转为整数。</li><li>页面搜索严禁左模糊或者全模糊，如果需要请通过搜索引擎来解决。说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</li><li>避免用 NULL:不利于索引，要用特殊字节标注，在磁盘上的空间其实更大</li><li>不要使用 count(列名) 或 count(常量) 来替代<code>count(*)</code>，<strong><code>count(*)</code>是SQL92定义的标准统计行数的语句</strong>，跟数据库无关，跟 NULL 和非 NULL 无关。说明：count(*) 会统计值为 NULL 的行，而 count(列名) 不会统计此列为 NULL 值的行。</li><li>count(distinct column) 计算该列除 NULL 外的不重复行数。注意，count(distinct column1,column2) 如果其中一列全为 NULL，那么即使另一列用不同的值，也返回为 0。</li><li>禁止使用存储过程。存储过程难以调试和扩展，更没有移植性。</li><li>IN 操作能避免则避免。若实在避免不了，需要仔细评估 IN 后面的集合元素数量，控制在 1000 个之内。</li></ul><h2 id="索引常见误区"><a href="#索引常见误区" class="headerlink" title="索引常见误区"></a>索引常见误区</h2><p>在 where 条件的所有列上都加索引，例如 <code>where cat_id = 3 and price &gt; 100;</code>,错误的做法是在 cat_id 和 price 列上都加上两个独立的索引（原因：通常只能用上 cat_id 或者 price 中的一个，因为是独立索引，查询优化器一般在一个表上只会选择一个最佳索引来优化效率）。</p><p>面试题：联合索引 index(a,b,c):<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c8923fcd-bd2f-4da4-9734-35ee6953d59f.png" alt="联合索引"></p><p>上述最后两条语句 b 使用了范围查询和模糊查询，导致只使用了(a,b)索引。</p><h2 id="基于索引进行数据库优化"><a href="#基于索引进行数据库优化" class="headerlink" title="基于索引进行数据库优化"></a>基于索引进行数据库优化</h2><h3 id="什么情况下会产生临时表"><a href="#什么情况下会产生临时表" class="headerlink" title="什么情况下会产生临时表"></a>什么情况下会产生临时表</h3><ol><li>group by 的列和 order by 的列不同时, 2 表边查时,取 A 表的内容,group&#x2F;order by 另外表的列</li><li>distinct 和 order by 一起使用时</li></ol><h3 id="什么情况下临时表会写到磁盘上"><a href="#什么情况下临时表会写到磁盘上" class="headerlink" title="什么情况下临时表会写到磁盘上"></a>什么情况下临时表会写到磁盘上</h3><ol><li>取出的列含有 text&#x2F;blob 类型时（内存表储存不了 text&#x2F;blob 类型）</li><li>在 group by 或 distinct 的列中存在 &gt;512 字节的 string 列</li><li>select 中含有 &gt;512 字节的 string 列,同时又使用了 union 或 union all 语句</li></ol><h3 id="分页常用的实践方案有哪些，如何优化"><a href="#分页常用的实践方案有哪些，如何优化" class="headerlink" title="分页常用的实践方案有哪些，如何优化"></a>分页常用的实践方案有哪些，如何优化</h3><ol><li>从业务上解决，不允许翻过 100 页，以百度为例，一般 70 页左右（连百度都无法解决深度分页问题）</li><li>不用 offset，用条件查询，where id &gt; 5000000 limit 10</li><li>解决方案 2 有个问题：数据被物理删除过，就会造成空洞，分页的结果不一致，解决方案数据不物理删除（使用逻辑删除，被删除的内容不显示即可）</li><li>非要物理删除，还要 offset 精确查询，还不能限制用户分页。优化思路是：不查,少查,查索引,少取，只查索引得到 id，再用 id 去获取具体条目，这种技巧就是<strong>延迟索引</strong>。</li></ol><p>小数据量（几万）只需要使用 limit 语句进行全表扫描即可，因为即使 offset 很大，全表扫描的代价也不大。limit 中的 offset 是先查询然后跳过，对于大表来说逐行扫描跳过一定数量是不可接受的。以下以每页 10 条数据为例子，数据生成脚本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tableConfig = &#123;</span><br><span class="line">  <span class="attr">posts_small</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">10000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">posts_big</span>:&#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">500000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mock</span> = <span class="built_in">require</span>(<span class="string">&#x27;mockjs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Random</span> = <span class="title class_">Mock</span>.<span class="property">Random</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sql = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> tableName <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(tableConfig)) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;count&#125; = tableConfig[tableName];</span><br><span class="line"></span><br><span class="line">  sql += <span class="string">`CREATE TABLE \`<span class="subst">$&#123;tableName&#125;</span>\` (</span></span><br><span class="line"><span class="string">  \`id\` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span></span><br><span class="line"><span class="string">  \`type\` tinyint(3) unsigned DEFAULT NULL COMMENT &#x27;类型&#x27;,</span></span><br><span class="line"><span class="string">  \`content\` varchar(512) DEFAULT &#x27;&#x27; COMMENT &#x27;内容&#x27;,</span></span><br><span class="line"><span class="string">  \`created\` timestamp NULL DEFAULT NULL COMMENT &#x27;时间&#x27;,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (\`id\`),</span></span><br><span class="line"><span class="string">  KEY \`idx_created\` (\`created\`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">    sql += <span class="string">`INSERT INTO <span class="subst">$&#123;tableName&#125;</span> SET type = <span class="subst">$&#123;Random.natural(<span class="number">0</span>,<span class="number">1</span>)&#125;</span>,content = &#x27;<span class="subst">$&#123;Random.cparagraph()&#125;</span>&#x27;,created = from_unixtime(<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(Random.datetime()).getTime() / <span class="number">1e3</span> | <span class="number">0</span>&#125;</span>);\n`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./data.sql&#x27;</span>,sql);</span><br></pre></td></tr></table></figure><p>小表 1W 条，大表 50W 条，执行分页查询如下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/1b84ad70-d446-11e9-ade4-13ccd89a2e5d.png" alt="分别对小表和大表进行limit"></p><p>在大表中进行分页查询后，非常长的时间才拿到响应（并且随着 offset 的增加，性能越差）,查看服务器负载：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ac1be720-d3b2-11e9-ade4-13ccd89a2e5d.png" alt="top命令"></p><p>在 top 命令中发现其他指标都正常，但是 wa 比较高意味着大量的磁盘 IO，进一步执行 iotop 验证结论。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6e35cd90-d3b2-11e9-ade4-13ccd89a2e5d.png" alt="io-top"></p><p>使用 show profile 可以发现耗时都在 Sending Data.</p><p>原因在于<code>SELECT *</code>会进行<strong>回表操作</strong>（因为查询的有不包含索引的列），即先按照索引条件筛选出主键，再根据主键查询取出全部的列，这是一个<strong>非常耗时</strong>的操作。改成只查询出分页的主键（效率高的原因是索引文件比数据文件小得多），然后再使用 IN 查询（或者用 INNER JOIN ）性能可得到大幅提高：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/b58e5000-d447-11e9-ade4-13ccd89a2e5d.png" alt="image.png"></p><p>这里吐槽下：不知道为啥子查询中不能有 LIMIT 子句,网上的解决方案是再包一层：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/330f8620-d448-11e9-ade4-13ccd89a2e5d.png" alt="解决limit子句不能放在子查询中的问题"></p><p>另一种分页优化：<code>SELECT * FROM articles WHERE id &gt;= (SELECT id FROM articles ORDER BY id LIMIT 10000, 1) LIMIT 10</code>，将主查询变成了一个普通的范围查询。</p><p>参考资料：<a href="https://segmentfault.com/a/1190000008859706">MySQL的limit分页的性能分析和优化</a></p><blockquote><p>MySQL中的索引尽量建立在区分度比较高的列上（也就是说不要有大量的重复数据）。</p></blockquote><blockquote><p>在长期的数据更改过程中, 索引文件和数据文件,都将产生空洞,形成碎片。我们可以通过一个 nop 操作(不产生对数据实质影响的操作)来修改表。<code>optimize table</code>，修复表的数据及索引碎片,就会把所有的数据文件重新整理一遍,使之对齐.这个过程,如果表的行数比较大,也是非常耗费资源的操作。所以,不能频繁的修复。如果表的 Update 操作很频繁,可以按周&#x2F;月,来修复。如果不频繁,可以更长的周期来做修复。</p></blockquote><h2 id="针对索引的常见面试题"><a href="#针对索引的常见面试题" class="headerlink" title="针对索引的常见面试题"></a>针对索引的常见面试题</h2><p>表中有 ABC 3 个字段创建的联合索引，下面的情况能否走索引？</p><ol><li><code>where A = 10 and C = 3</code>，A 能走，C 不能走。这条语句能走索引，但是可能不会把索引的效果全部应用上</li><li><code>where A in(1,2,3)</code> 主要有下面的 2 种回答：一定能走（符合最左原则）；一定不能，因为在一个范围，而不是在某一个值。上面的 2 种说法都是不负责任的，正确答案是：理论上可以走，但是一定要和面试官沟通例如 A 的数据的范围，或者数据的多少都能影响到 A 走的效果</li><li><code>where A &gt; 8 and A &lt; 100</code> 和情况 b 其实差不多，也是要具体分析，不能一概而论！</li><li><code>where A like &#39;%2%&#39;</code> 不能</li><li><code>where A like &#39;2%&#39;</code> 能</li><li><code>where A * 3 = 90</code> 不能，因为有计算的过程，是一个表达式，本来可以走的索引就走不到了</li></ol><h2 id="创建索引一定会锁表？"><a href="#创建索引一定会锁表？" class="headerlink" title="创建索引一定会锁表？"></a>创建索引一定会锁表？</h2><p>在 MySQL 5.6 之前，创建索引会锁表，但是在 MySQL 5.6.7 之后 InnoDB 新增了 Onine DDL，在添加索引的时候可以和 DML (INSERT, UPDATE, DELETE, SELECT)命令一起执行。默认情况下是不锁表的。</p><h1 id="为什么预编译的SQL能防止SQL注入"><a href="#为什么预编译的SQL能防止SQL注入" class="headerlink" title="为什么预编译的SQL能防止SQL注入"></a>为什么预编译的SQL能防止SQL注入</h1><p>预编译是发生在 MySQL 服务器端，不仅能防止 SQL 注入还能提高性能，因为只编译了一遍，不需要再次发送完整的 SQL 了，只需要绑定参数了，有效减少了 IO，nodejs 中推荐的库是<a href="https://github.com/sidorares/node-mysql2#using-prepared-statements">node-mysql2</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2/promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;192.168.3.118&#x27;</span>,</span><br><span class="line">        <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;master&#x27;</span>,</span><br><span class="line">        <span class="attr">database</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">await</span> connection.<span class="title function_">query</span>(<span class="string">&#x27;SELECT * FROM test WHERE uid = ?&#x27;</span>, [<span class="number">1</span>]); <span class="comment">// 使用普通的sql</span></span><br><span class="line">    <span class="keyword">await</span> connection.<span class="title function_">execute</span>(<span class="string">&#x27;SELECT * FROM test WHERE uid = ?&#x27;</span>, [<span class="number">1</span>]); <span class="comment">// 预编译的sql</span></span><br><span class="line">    <span class="keyword">await</span> connection.<span class="title function_">execute</span>(<span class="string">&#x27;SELECT * FROM test WHERE uid = ?&#x27;</span>, [<span class="number">2</span>]); <span class="comment">// 预编译的sql</span></span><br><span class="line">&#125;)().<span class="title function_">then</span>(process.<span class="property">exit</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(e));</span><br></pre></td></tr></table></figure><p>用 Wireshark 抓包（如果报权限错误可以使用sudo命令<code>sudo /Applications/Wireshark.app/Contents/MacOS/Wireshark</code>）。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/144c2940-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3d60d2e0-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/53c9f9d0-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6ecbbbb0-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7b857c10-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"></p><p><a href="https://blog.csdn.net/maoxinwen1/article/details/79590228">MYSQL服务器的查询日志</a>如下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/9a2f8570-d836-11e9-ade4-13ccd89a2e5d.png" alt="image.png"></p><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><p>主要有如下图所示的 4 个方向：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-optimization.png" alt="数据库优化的 4 个方向"></p><p>慢查日志分析工具：mysqldumpslow（官方自带），pt-query-digest。</p><p>explain 查询计划需要关注下面的几个字段：</p><ul><li>type: const, eq_ref, ref, range, index, ALL（从好到坏）</li><li>possible_keys：可能使用的索引</li><li>key：实际使用的索引</li><li>key_len: 使用的索引长度。在不损失精确性的情况下，长度越短越好，较长的 key_len 可能意味着使用了复合索引或者较大类型的字段</li><li>extra：需要关注 using filesort，using temporary</li></ul><p>ref 和 eq_ref 都是 explain 中的 join 类型，表示 MySQL 如何连接表，区别如下：</p><ul><li>eq_ref: 对于左表的每一行，当前表有唯一的一行（主键、或者唯一索引）</li><li>ref：左表的每一行，当前表可能有多个匹配（普通索引）</li></ul><h1 id="主主复制架构是怎样的，需要注意什么"><a href="#主主复制架构是怎样的，需要注意什么" class="headerlink" title="主主复制架构是怎样的，需要注意什么"></a>主主复制架构是怎样的，需要注意什么</h1><p>主要是解决一主多从架构写库的<strong>高可用问题</strong>，无法解决写操作的性能和提升数据库的存储能力。需要注意的是<em>任何时候都只能有一台数据库作为主库进行写操作</em>，只有当这台 DB 宕机的时候才会将写操作切换到另一台主数据库上，这样才能保证数据一致性，不会出现数据冲突。如果确实存在多主写的情况可以抽离主键生成服务，各个服务器先调用主键生成服务生成主键然后插入也可以避免主键冲突。</p><h1 id="说说数据库分片"><a href="#说说数据库分片" class="headerlink" title="说说数据库分片"></a>说说数据库分片</h1><p>数据库分片用来解决数据库的存储能力。也就是说，将一张表的数据分成若干片，每一片都包含了数据表中一部分的行记录，然后每一片存储在不同的服务器上，这样一张表就存储在多台服务器上了。</p><p>最简单的数据库分片存储可以采用硬编码的方式，在程序代码中直接指定一条数据库记录要存放到哪个服务器上。比如将用户表分成两片，存储在两台服务器上，那么就可以在程序代码中根据用户 ID 进行分片计算，ID 为偶数的用户记录存储到服务器 1，ID 为奇数的用户记录存储到服务器 2。</p><p>但是硬编码方式的缺点比较明显:</p><ul><li>如果要增加服务器，那么就必须修改分片逻辑代码，这样程序代码就会因为非业务需求产生不必要的变更</li><li>其次，分片逻辑耦合在处理业务逻辑的程序代码中，修改分片逻辑或者修改业务逻辑都可能使另一部分代码因为不小心的改动而出现 Bug</li></ul><p>可以通过使用分布式关系数据库中间件解决这个问题，将数据的分片逻辑在中间件中完成，对应用程序透明，如 MyCat。</p><blockquote><p>实践中，更常见的数据库分片算法是我们所熟悉的余数 Hash 算法，根据主键 ID 和服务器的数目进行取模计算，根据余数连接相对应的服务器。</p></blockquote><h2 id="死锁形成的原因是啥"><a href="#死锁形成的原因是啥" class="headerlink" title="死锁形成的原因是啥"></a>死锁形成的原因是啥</h2><p>死锁是一种争夺资源而造成的一种互相等待的现象，如果没有外力作用，它们都将无法推进下去，这时称系统处于死锁或者系统产生了死锁。这些永远在等待的进程被称为死锁进程。表级锁不会产生死锁，所以<em>死锁问题主要针对的是InnoDB</em>。</p><p>死锁的关键在于两个（或以上）session 的加锁顺序不一致。对应的解决方案是就是让不同的 session 加锁有次序。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul><li>共享锁（行）、排它锁（行）</li><li>意向锁（表）</li><li>记录锁（索引）</li><li>间隙锁（范围）</li></ul><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁（Intention Locks）是 InnoDB 引擎中的一种锁机制（表级锁），用于协调事务间的加锁操作，避免冲突和死锁的发生。</p><p>为什么要有意向锁？</p><p>事务 A 加锁了 Users 表中的一行数据（行锁），事务 B 要对整个 Users 表进行加锁（表锁）。如果没有意向锁，那事务 B 就会加锁成功了。而事务 B 如果加锁成功的话，那么它是可以对表中的任意数据行进行操作的，包括事务 A 加锁的那行数据，所以，这个时候就发生了锁冲突。为了避免这个问题，所以 MySQL 引入了意向锁，在事务 A 添加行锁的时候，先添加意向锁，而事务 B 在添加表锁的时候，先判断一下意向锁，如果有意向锁了，它就不能加表锁了，这样避免了锁冲突，提升了加锁判断的效率。</p><blockquote><p>想象一下，如果没有意向锁的话，那么事务 B 在加表锁的时候，只能一行行的判断有没有行锁，而这种判断的效率是非常低的，尤其数据量比较大时。</p></blockquote><p>意向锁可以分为下面 2 种类型：</p><ol><li>意向共享锁(Intention Shared Lock,IS): 表示在某个资源上设置共享锁。也就是读锁，用于读取数据的操作，允许多个事务同时持有（共享锁），不互斥</li><li>意向排他锁(Intention Exclusive Lock,IX): 表示在某个资源上设置排他锁。也就是写锁，用于修改和更新数据操作，并且同一时间只能由一个事务持有，不能和其他事务共同持有，具有互斥性和排他性。</li></ol><p>意向锁并不能直接由开发者创建和使用,由 MySQL 自行维护的一种协调事务加锁的机制。它在事务创建行锁和表锁时创建，在事务提交或回滚之后自动释放。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>原子性：undo log，保存和执行相反的日志(例如：INSER-DELETE,UPDATE-相反的UPDATE)，还能实现 MVCC<br>一致性：<br>隔离性：锁<br>持久性：redo log，保证 crash safe，即使数据没有持久化只要日志持久化了，依然可以进行恢复。这其实是一种 WAL（write ahead log）机制</p><p>注意：undo log 和 redo log 是 InnoDB 存储引擎这一层次，而 binlog 是 mysql server 这个层次，不要搞混了。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log 记录了事务对哪些数据页做了修改。redo log 包含 2 部分：</p><ol><li>redo log buffer：内存中的日志缓冲</li><li>redo log file：磁盘上的日志文件</li></ol><p>MySQL 每执行一条 DML，先将记录写入到 redo log buffer，后续某个时间点再一次性将多个操作记录写入到 redo log file。这种先写日志，再写磁盘的技术就是 WAL。</p><p>在用户空间下，缓冲区的数据一般是无法写入磁盘的，中间必须经过 OS 的内核缓冲区。因此， redo log buffer 写入 redo log file 实际上是先写入 OS Buffer，再通过 fsync system call 将其刷新到 redo log file 中。redo log 记录的是数据页的变更，这种变更没必要全部保存，它采用了循环队列的思想（大小固定，循环写入，写到结尾的时候再次回到开头）。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-redo-log-ring-buffer.jpg" alt="MySQL redo-log"></p><p>write pos 指向下一个待写入的日志条目位置。checkpoint 表示在此之前的日志对应的修改已经持久化到磁盘的数据文件(.idb)中。</p><p>有下面的 3 个特点：</p><ol><li>是 InnoDB 存储引擎层日志，其他引擎可能没有这个日志。</li><li>不管事务是否提交都会被记录下来，所以在 InnoDB 引擎下对于数据的任何更改都会有记录。</li><li>先写日志，后写磁盘。</li></ol><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ol><li>保存的是事务发生之前的数据版本</li><li>主要用于回滚</li><li>同时可以提供多版本并发控制下的读（MVCC），也就是非锁定读</li></ol><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>即归档日志</p><ol><li>主从复制</li><li>以二进制的形式进行记录</li><li>用于 DB 的基于时间点的还原</li><li>提交事务记录 bin log，定时刷盘</li></ol><p>如果在还没来得及写入 big log 的时候 DB 就崩溃了，一系列的更改就会丢失！这是 MySQL 中最重要的日志！</p><h2 id="事务并发与-MVCC"><a href="#事务并发与-MVCC" class="headerlink" title="事务并发与 MVCC"></a>事务并发与 MVCC</h2><p>并发事务带来了 3 个问题：</p><ul><li>脏读：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。（读取了未提交的脏数据）</li><li>不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。（同一事务中相同的查询返回不同的结果）</li><li>幻读：它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。（同一事务中相同的查询【另一事务insert，delete，update改变了结果集的数量】返回不同数量的<em>结果集</em>）</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-dirty-read.png" alt="脏读"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-unrepeatable-read.png" alt="不可重复读"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-phantom-read.png" alt="幻读"></p><p>幻读和不可重复读区别：幻读更强调<strong>多行记录</strong>，脏读和不可重复读强调单行记录。</p><p>事务并发带来的 3 个问题其实都是<em>读一致性</em>的问题，必须由数据库本身提供一定的事务隔离机制来解决。InnoDB 在 RR 级别（默认级别）配个锁解决了幻读问题。主要有 2 种机制：</p><ol><li>MVCC: InnoDB 存储引擎为每个事务生成一个一致性视图（Consistent Read View），在事务开始时记录当前活跃事务的 ID，确保事务的读取操作只能看到该视图生成前的已提交数据。事务中的多次查询会基于同一快照，因此看不到其他事务的插入或删除操作（即使其他事务已提交）。</li><li>Next-Key Lock: InnoDB 对索引记录的“间隙”加锁，阻止其他事务在范围内插入新数据。当执行 SELECT … FOR UPDATE 或 SELECT … LOCK IN SHARE MODE 时，InnoDB 会对查询范围内的索引间隙加锁。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A（RR 隔离级别）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>; <span class="comment">-- 基于快照读取，返回 10 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B 插入一行 age=25 并提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务A 再次查询，仍返回 10 行（MVCC 保证一致性视图）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务A（RR 隔离级别）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 对 age&gt;20 的现有记录和间隙加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B 尝试插入 age=25 的数据，会被阻塞，直到事务A提交</span></span><br></pre></td></tr></table></figure><p>间隙锁依赖索引。如果查询条件没有索引，InnoDB 会锁全表，性能极差。只有使用 FOR UPDATE 或 LOCK IN SHARE MODE 时，间隙锁才会生效。</p><p>MySQL 在 RR 隔离级别下，通过 MVCC 的一致性视图 和 Next-Key Lock 的结合，既保证了非锁定读的幻读防护（通过快照），又保证了锁定读的幻读防护（通过锁机制）。这种设计在事务并发性和数据一致性之间取得了平衡。</p><p>Next-Key Lock 锁定范围，左开右闭。</p><p><em>并不是说可重复读级别直接解决了幻读问题，而是在 MySQL 中可重复读级别 + 锁不存在幻读问题。</em></p><p><a href="https://www.javacn.site/interview/mysql/rr_mvcc.html#rr-mvcc-%E6%9C%89%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%E5%90%97">RR 级别有幻读问题么</a></p><p>MVCC 机制解决了 RR 级别中的部分幻读问题，但是又没有把幻读问题全部解决。</p><ul><li>MVCC 解决了 RR 级别中，快照读的幻读问题。多次快照读的时候，因为 RR 级别复用的是读视图</li><li>MVCC 解决不了在 RR 隔离级别中，如果遇到快照读和当前读中间添加过数据的操作，读视图不能复用，就出现了幻读问题</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>事务的隔离级别从低到高依次是：</p><ul><li>Read Uncommitted：可能出现脏读、不可重复读、幻读</li><li>Read Committed：可能出现不可重复读、幻读</li><li>Repeatable Read：默认级别，可能出现幻读，但是 InnoDB 引擎在此隔离界别下通过 MVCC 搭配 Gap Locks 可以解决幻读</li><li>Serializable</li></ul><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/read-uncomitted.png" alt="读未提交"></p><p>事务 B 对年龄的更改对于事务 A 是完全透明的，A 能完全感知到 B 的变化，B 还没有提交更改 A 就能读到，B 有可能回滚，A 还是用到了错误更新后的数据。脏读就是这样体现出来的！</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/read-commited.png" alt="读已提交"></p><p>在 B 事务提交之前，A 是无法感知 B 的变化的，保证了 A 是无法读取到 B 的脏数据的！但是在事务 A 中前后两次相同的查询却返回了不同的数据，这就是不可重复读！</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/repeatable-read.png" alt="可重复读"></p><p>A 是否能在自己的事务中感知到 B 事务提交之后的结果是可重复读和读已提交的区别。在这种隔离级别下，A 事务在还未提交的时候无法感知其他任何已提交的数据，在自己的事务内读多少次都是前后一致的！</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>严格按照先后顺序执行数据库的变更操作，对所有的读写都进行加锁。</p><h3 id="选择合适的隔离级别"><a href="#选择合适的隔离级别" class="headerlink" title="选择合适的隔离级别"></a>选择合适的隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.tx_isolation; <span class="comment">-- 系统层面</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx_isolation</span>; <span class="comment">-- 会话层面</span></span><br><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> SESSION transaction isolation level REPEATABLE READ;</span><br></pre></td></tr></table></figure><p>隔离级别的选择和设置一定要非常慎重，它对业务有着潜移默化的深远影响。一定不要粗浅认为默认的隔离级别是什么就认为当前公司应该使用使用什么级别。很多公司会修改事务的隔离级别为 Read Committed，它们使用了上松下严的策略——在 DB 层面设置的比较宽松，在业务中进行更加精细化控制。</p><blockquote><p>Spring 事务传播属性：当 Spring 开启了事务并且设置了传播机制，它就会覆盖 MySQL 已有的事务隔离界别。<strong>如果 MySQL 不支持该隔离级别，Spring 的事务就不会生效！</strong></p></blockquote><p>在一般的生产实践中 RR(Repeatable Read) 和 RD(Read Comitted) 是常态（搭配锁）。</p><h3 id="当前读与快照读"><a href="#当前读与快照读" class="headerlink" title="当前读与快照读"></a>当前读与快照读</h3><ul><li>当前读：读取记录的最新版本。为了保证其他并发事务不会修改当前记录，会对读取的记录进行加锁。UPDATE, INSERT, DELETE, SELECT FOR UPDATE, SELECT LOCK IN SHARE MODE 都是当前读。</li><li>快照读：不加锁的非阻塞读。快照读的前提是隔离级别不能是串行化，串行化级别下快照读会退化为当前读。普通的 SELECT 是快照读。</li></ul><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-hiden-field.png" alt="隐式字段"></p><p>为了实现 MVCC, InnoDB 在每行数据中引入了几个 <em>隐式字段</em>，这些字段对用户不可见，但是在内部用于管理数据的版本和事务隔离。</p><ul><li>DB_TRX_ID: 用于判断数据版本对当前事务是否可见。如果事务 A 修改了某行数据，则该行的 DB_TRX_ID 会被设置为事务 A 的 ID。</li><li>DB_ROLL_PTR: 回滚指针，当事务需要回滚的时候，通过这个指针可以找到之前版本的数据并进行恢复。</li><li>DB_ROW_ID: 如果没有定义主键，使用它作为行的唯一标识符。</li></ul><h3 id="读视图"><a href="#读视图" class="headerlink" title="读视图"></a>读视图</h3><p>读视图的 3 个全局属性</p><ul><li>list: 生成读视图的时候活跃的事务 ID 集合</li><li>up limit id: list 中最小的事务 ID</li><li>low limit id：下一个要分配的事务 ID</li></ul><p>在 RR 隔离级别下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-read-view1.png" alt="读视图-1"></p><p>一定要注意：读视图是在<strong>第一次 SELECT</strong>的时候生成的，而不是在进入事务就生成的。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-read-view2.png" alt="读视图-2"></p><p>如上图所示：事务 2 在第一次 SELECT 的时候活跃的事务只有 1 和 2，因此 read-view 的 list 为 {1,2}。</p><ul><li>可重复读级别，在<strong>首次快照读</strong>的时候生成读视图，并且这个读视图会在当前事务传递</li><li>读已提交级别，在<strong>每次快照读</strong>的时候生成读视图 —— 读视图可能存在多份</li><li>其他隔离级别不适合 MVCC，一般不讨论</li></ul><h3 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h3><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-data-visional-alg.png">MVCC 数据可见性算法</a></p><p>基于事务的读视图和数据的隐式字段两个方面来判断数据版本是否对当前事务可见。</p><p>数据版本对当前事务可见的条件：</p><ol><li>数据版本由已提交的事务修改，且修改时间早于当前活跃事务。(DB_TRX_ID &lt; up limit id)</li><li>数据版本由当前事务自己修改。(DB_TRX_ID &#x3D;&#x3D; 当前事务 ID)</li><li>数据由已提交的事务修改，且修改时间晚于当前活跃事务 (DB_TRX_ID not in list)</li></ol><p>数据版本对当前事务不可见的条件：</p><ol><li>数据版本由未提交的事务修改。(DB_TRX_ID in list)</li><li>当前数据版本由未来事务修改。（DB_TRX_ID &gt;&#x3D; low limit id）</li></ol><p>不可见时的处理：通过 DB_ROLL_PTR 回滚指针找到上一个版本的数据(undo log)。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mvcc-data-visional-alg-demo.png" alt="MVCC 数据可见性算法示例"></p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务中强调 BASE。</p><ul><li>Basically Available: 系统保证在大多数情况下能够提供服务，即使某些节点出现故障时，仍尽可能保持可用性。这意味着系统优先保障可用性，而非一致性。</li><li>Soft State: 系统状态允许在一段时间内处于不一致状态。与 ACID 强一致性的要求不同，BASE 允许系统在更新过程处于“柔性”状态，即数据在某些节点上可以暂时不一致。</li><li>Eventually consistent：最终一致性强调，即使在网络分区或系统故障的情况下，在经过足够的时间和多次数据同步操作后，所有节点的数据一定会一致。</li></ul><p>BASE 理论是对 CAP 定理中 AP（可用性和分区容错性）方案的延伸，强调在分布式系统中即使无法实现强一致性，也可以通过适当的方式使系统最终达到一致性。</p><ul><li>可靠事件队列：该模式的核心在于确保事件可靠投递并避免重复消费。现代消息中间件普遍实现了事件持久化和至少一次投递机制，此外，幂等性的实现也有成熟的解决方案。这种依赖持续重试来确保可靠性的解决方案在计算机领域被广泛应用，它还有专有的名称 —— “最大努力交付”（Best-Effort Delivery）。因此，可靠事件队列也称为“最大努力一次提交”（Best-Effort 1PC）机制，也就是将最容易出错的业务通过本地事务完成后，借助不断重试的机制促使同一个事务中其他操作也顺利完成。</li><li>TCC：Try-Confirm-Cancel。按照 TCC 事务模型的规定，Confirm 和 Cancel 阶段只返回成功，不会返回失败。如果 Try 阶段之后，出现网络问题或者服务器宕机，那么事务管理器要不断重试 Confirm 阶段或者 Cancel 阶段，直至完成整个事务流程。TCC 事务模型其实有点类似两阶段提交（2PC）的准备阶段和提交阶段，但 TCC 位于业务层面，而不是数据库层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。感知各个阶段的执行情况以及推进执行下一个阶段需要编写大量的逻辑代码，不仅仅是调用一下 Confirm&#x2F;Cancel 接口那么简单。通常的情况，我们没必要裸编码实现 TCC 事务模型，而是利用分布式事务中间件（如 Seata、ByteTCC）降低编码工作，提升开发效率。<ul><li>Try：该阶段的主要任务是预留资源或执行初步操作，但不提交事务。Try 阶段确保所有相关操作可以成功执行且没有资源冲突。例如，在预订系统中，这一阶段可能包括检查商品库存并暂时锁定商品</li><li>Confirm：如果 Try 阶段成功，系统进入 Confirm 阶段。在此阶段，系统会提交所有操作，确保事务最终生效。由于 Try 阶段已保证资源的可用性和一致性，Confirm 阶段的执行是无条件的，不会发生失败</li><li>Cancel：如果 Try 阶段失败，或需要回滚事务，系统进入 Cancel 阶段。此时，系统会撤销 Try 阶段中的所有预留操作并释放资源。Cancel 阶段确保事务无法完成时，系统能够恢复最初的状态</li></ul></li><li>Saga：非常适合处理流程较长且需要确保事务最终一致性的业务操作。通常采用事件驱动设计，即每个服务都是异步执行的，无需设计资源的冻结状态或处理撤销冻结的操作。<ul><li>将大事务 T 拆分成若干小事务</li><li>为每个子事务设计对应的补偿动作</li></ul></li></ul><p>将事务控制从数据库资源层转移到业务层，通过将事务拆分为多个子事务，弱化资源锁定，从而提高系统可用性。分布式事务实现的最终一致性保证不一致是暂时的，最终会达到一致。但*这是一个非常脆弱的保证，它无法告诉我们系统什么时候达到一致。*在一致性达成之前，读请求可能会返回任意值或失败，这对业务工程师而言带来了相当大的挑战。  </p><h3 id="事务补偿机制"><a href="#事务补偿机制" class="headerlink" title="事务补偿机制"></a>事务补偿机制</h3><p>针对每一个操作，都要注册一个与其对应的补偿（撤销）操作。在执行失败的时候执行补偿操作撤销之前的动作。</p><p>例如下单的时候扣减库存：订单库和商品库是分开的，就存在了分布式事务问题：</p><p>下单之前会对库存进行扣减，这个时候可能是UPDATE语句把库存更新了，接下来进行INSERT操作创建订单。但是如果订单创建失败了就直接抛出异常了（由于商品库在别的库，所以无法回滚）。这个时候就需要调用补偿操作把商品库存加回来。</p><p>互联网上经常使用银行转账的例子来说明事物，但是这个例子如果涉及到两家银行，这就是一个分布式事务的问题。需要提供补偿机制。</p><p>优点：逻辑清晰、流程简单<br>缺点：数据一致性比XA还要差，可能出错的点比较多。TCC属于应用层的一种补偿方式，需要程序员编写大量代码</p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ol><li>RR 级别是默认的级别，但是不一定是最常用的，乐观锁必不可少。</li><li>WHERE, ON, GROUP BY, ORDER BY 后面跟着的字段建议使用索引，反而需要查找的列可能并不一定需要索引。</li><li>使用组合索引，少用单列索引。例如一个组合索引能解决的问题就没有必要创建 3 个单列索引了。</li></ol><p>高并发下 DB 读写压力大怎么解决？<br>常见的解决方案：读写分离（主从一致性）、加机器、分库分表（热点问题，编程复杂度提升）这些都能减轻并行事务影响或者减轻读写压力，但是可能会导致其他问题。</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>设计高并发系统的时候，DB 层面应该如何设计？其实分库和分表是两回事，可能光分库不分表也可能光分表不分库。其实分库分表一定是跟着公司的业务走的，用户越多，数据量越大单个DB肯定扛不住。单个库最高支撑并发2000就一定要进行扩容了，一个健康的单库并发值最好保持在每秒1000左右，不要太大。</p><h2 id="对于一个未分库分表的系统如何动态切换到分库分表"><a href="#对于一个未分库分表的系统如何动态切换到分库分表" class="headerlink" title="对于一个未分库分表的系统如何动态切换到分库分表"></a>对于一个未分库分表的系统如何动态切换到分库分表</h2><ul><li>最简单的方案：停机迁移。这个方案比较low，谁都能干。</li><li>还有个高大上的方案：<strong>双写</strong>。</li></ul><p>这种方案可以实现不停机维护：简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong>，这就是所谓的双写，同时写俩库，老库和新库。然后系统部署之后，新库数据差太远，用数据导出工具，跑起来读老库数据写新库，写的时候要根据<code>gmt_modified</code>这类字段判断这条数据最后修改的时间，<strong>除非是读出来的数据在新库里没有，或者是比新库的数据新才会写</strong>。简单来说，就是<em>不允许用老数据覆盖新数据</em>。</p><p>导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。</p><p>接着当数据完全一致了，就ok了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干的。</p><h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL数据是改善数据存储能力的一个重要手段。主要用来解决大规模分布式数据的存储问题。常用的HBASE，Cassandra，面临的挑战是<em>数据一致性问题</em>。如果数据分布存储在多台服务器组成的集群上，那么当有服务器节点失效的时候，或者服务器之间网络通信故障的时候，不同用户读取的数据就可能会不一致。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/73d5fe40-9d68-493d-be92-5922b646784f.png" alt="image.png"></p><p>如上图所示用户 1 连接服务器节点 A，用户 2 连接服务器节点 B，当两个用户同时修改某个数据的时候，如果正好服务器 A 和服务器 B 之间的网络通信失败，那么这两个节点上的数据也就不一致了，其他用户在访问这个数据的时候，可能会得到不一致的结果。</p><p>关于分布式存储系统有一个著名的CAP原理，CAP原理说：一个提供数据服务的分布式系统无法同时满足数据一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）这三个条件。</p><p>一致性是说，每次读取的数据都应该是最近写入的数据或者返回一个错误，而不是过期数据，也就是说，数据是一致的。</p><p>可用性是说，每次请求都应该得到一个响应，而不是返回一个错误或者失去响应，不过这个响应不需要保证数据是最近写入的。也就是说，系统需要一直都是可以正常使用的，不会引起调用者的异常，但是并不保证响应的数据是最新的。</p><p>分区容忍性说，即使因为网络原因，网络分区失效的时候，部分服务器节点之间消息丢失或者延迟了，系统依然应该是可以操作的。</p><p>CAP原理是说，当网络分区失效发生的时候，我们要么取消操作，保证数据就是一致的，但是系统却不可用；要么继续写入数据，但是数据的一致性就得不到保证了。</p><p>对于一个分布式系统而言，网络失效一定会发生，也就是说，分区容忍性是必须要保证的，而对于互联网应用来说，可用性也是需要保证的，分布式存储系统通常需要在一致性上做一些妥协和增强。</p><p>Apache Cassandra 解决数据一致性的方案是，在用户写入数据的时候，将一个数据写入集群中的三个服务器节点，等待至少两个节点响应写入成功。用户读取数据的时候，从三个节点尝试读取数据，至少等到两个节点返回数据，并根据返回数据的时间戳，选取最新版本的数据。这样，即使服务器中的数据不一致，但是最终用户还是能得到一个一致的数据，这种方案也被称为<em>最终一致性</em>。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/409360e5-bdc7-449a-a244-ba58475d437f.png" alt="image.png"></p><p>因为各种原因，互联网应用主要采用的是水平伸缩，也就是各种分布式技术。事实上，在数据存储方面，有时候采用垂直伸缩，也就是<em>使用更好的硬件服务器部署数据库，也是一种不错的改善数据存储能力的手段</em>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/aspirant/p/9214485.html">为什么B+树适合做索引</a></li><li><a href="https://www.cnblogs.com/zyy1688/p/9983122.html">行锁升级为表锁</a></li><li><a href="https://www.imooc.com/learn/1309">探秘 MySQL 多版本并发控制原理</a></li><li><a href="https://www.cnblogs.com/ZJJCodeLife-520/p/16472231.html">MVCC - Read View 的可见性判断理解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - 消息队列</title>
      <link href="/2020/07/28/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/28/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h1><ol><li>消息中间件把进程间通信和网络通信的底层细节屏蔽，提供统一的接口。</li><li>自动解决包拼接的问题，tcp是基于单字节的流传输协议，你需要自己做包的encode和parser，并且parser是针对字节流。消息中间件一般提供基于消息粒度的接口。</li><li>消息中间件提供了一些常用的消息通信模式，例如：发布-订阅模式，广播模式等。这是一个理由。自己写的话，也需要做这些事情，细节还多。通信模式一般伴随着一套协议，例如AMQP协议。</li><li>消息中间件可能会提供持久化的能力，如果你的程序处理不过来，它会在中间提供队列的能力，队列还有一定的持久化策略支持。这提高了系统的可用性和吞吐能力。这个角度上它有点像电容的作用。</li><li>消息中间件提供一个消息的多种传输模式，例如：保证一个包只会被发一次，或者一个包可以发多次等等策略。</li><li>以上这些能力，让你在选择用一台机子多进程（单机多个子服务），或者多台机子多进程（多机多服务），搭建这样的构架的时候，不用解决tcp这层传输到应用层上述需求之间的那些提供可靠有策略传输的实现细节。</li><li>各种不同的消息中间件的区别在于实现语言、功能侧重、对IO&#x2F;存储支持上的各不相同。理解清楚为什么要使用消息中间件，就像我们必须理解为什么要用tcp而不用udp一样。</li></ol><h1 id="Kakafa为什么性能很高"><a href="#Kakafa为什么性能很高" class="headerlink" title="Kakafa为什么性能很高"></a>Kakafa为什么性能很高</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/76d42371-5e25-4674-a53b-57f4a2803840.png" alt="image.png"> </p><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>Page Cache是OS的一种磁盘缓存机制，目的是减少对磁盘的IO操作。具体来说就是把磁盘中的数据缓存在内存中，把对磁盘的访问变成对内存的访问</p><h2 id="Zero-Copy"><a href="#Zero-Copy" class="headerlink" title="Zero Copy"></a>Zero Copy</h2><p>如图所示，传统跨进程的文件读写涉及到4次拷贝（上下文切换），kafka采用sendfile系统调用后简化了<em>不必要</em>的拷贝：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8cba9228-5ed7-46f7-a120-2464b5c6cc07.png" alt="image.png"></p><p>数据表明采用了零拷贝之后提高60%的发送性能</p><p>kafka怎么保证消息可靠性？可以通过配置ack保证不同的可靠性投递，但是依然不能保证100%可靠性投递，因为网络太差的话ack还是回不来。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/hmsiwtv/article/details/46960053">Kafka入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - Web 安全</title>
      <link href="/2020/06/15/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-web%E5%AE%89%E5%85%A8/"/>
      <url>/2020/06/15/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-web%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>XSS 利用的是用户对网站的信任，CSRF 利用的是网站对用户的信任。</p></blockquote><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>跨站脚本攻击(Cross Site Scripting)其简称应该是 CSS，但是 CSS 与前端的样式表重叠了，所以改为 XSS，这个 X 其实是 Cross 的通用英文缩写<br>。XSS 攻击的原理是数据变成了脚本，常用的探测方法就是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>这一条如果能注入成功就能以 src 的方式注入外部脚本。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>在常用的探测脚本中都是<code>alert(1)</code>，弹个框能有啥用，还能上天不？答案是真的能上天：</p><ul><li>获取页面数据（你看到的东西别人也能看到,偷取网站数据）</li><li>获取 Cookies（敏感信息泄露，例如登录态）</li><li>劫持前端逻辑（欺骗用户，本来应该做 A 操作的，结果点击按钮执行了 B）</li><li>发送请求</li></ul><p>因此 XSS 是比较危险的。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>反射型：url 参数直接注入(<code>http://example.com/search?q=&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>)</li><li>存储型：存储到 DB 后读取注入(例如评论区)</li></ul><p>反射型的攻击一般危害略小于存储型，因为 URL 中带了参数容易被用户察觉。为了让 URL 中的参数不那么明显，攻击者通常会将 URL 进行短地址编码，这样用户打开的时候就没有多少疑问了。</p><p>如果 HTML 的属性是用户输入动态构建的，用户就可以通过<code>&quot;</code>进行注入：</p><p><code>&lt;img src = &quot;1&quot; onerror=&quot;alert(1)&quot;&quot; /&gt;</code></p><p>即用户输入<code>1&quot; onerror=&quot;alert(1)&quot;</code>即可完成攻击，这种拼接字符串的方式和 SQL 注入的一种方式非常类似</p><p>常见的 XSS 攻击存在于 HTML 属性和 HTML 内容，因此富文本编辑器中非常容易出现 XSS攻击。</p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>概括起来就是以下几种：</p><ul><li>转义</li><li>节点白名单，仅仅保留白名单中的节点</li><li>CSP(Content Security Policy) 限制脚本加载来源</li><li>现代浏览器自带拦截，X-XSS-Protection头，可以防止反射型XSS,防止URL中的参数再次出现在HTML内容和属性中，防御非常有限</li><li>对输入HTML内容进行转义，将<code>&lt;</code>,<code>&gt;</code>,<code>&quot;</code>,<code>&#39;</code>转义为HTML实体即可,参见<a href="https://www.npmjs.com/package/escape-html">escape-html</a>的npm模块，其实<strong>比较好的方法是对输入的内容进行JSON序列化</strong>，js中对应的就是<code>JSON.stringify</code></li><li>对于富文本中XSS攻击的防御比较推荐的做法是按照白名单保留部分标签和属性，因为黑名单实在是太多了（各种script标签，onerror,onmouseover,onclick,每当你增加一个新的黑名单规则很容易找到一个方案绕过!白名单的思想是解析HTML文本构造成文档树(<a href="https://github.com/cheeriojs/cheerio">cheerio</a>)，仅仅保留白名单中指定的那些类型的节点，如下所示：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xssFilter</span>(<span class="params">html</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.<span class="title function_">load</span>(html);</span><br><span class="line">    <span class="keyword">const</span> whiteList = &#123;</span><br><span class="line">        <span class="string">&#x27;img&#x27;</span>: [<span class="string">&#x27;src&#x27;</span>], <span class="comment">// img标签只能有src属性</span></span><br><span class="line">        <span class="string">&#x27;font&#x27;</span>: [<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;size&#x27;</span>], <span class="comment">// font标签只能有color和size</span></span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: [<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    $(<span class="string">&#x27;*&#x27;</span>).<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> elementName = element.<span class="property">name</span>;</span><br><span class="line">        <span class="keyword">if</span> (!whiteList[elementName]) &#123;</span><br><span class="line">            $(element).<span class="title function_">remove</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">in</span> element.<span class="property">attribs</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!whiteList[elementName].<span class="title function_">includes</span>(attr)) &#123;</span><br><span class="line">                $(element).<span class="title function_">attr</span>(attr, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> $.<span class="title function_">html</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成熟方案<a href="https://github.com/leizongmin/js-xss">js-xss</a>,这个模块采用的就是白名单的思想。</p><blockquote><p>CSP即<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/default-src">内容安全策略</a>，这个规范与内容安全有关，主要是用来定义页面可以加载哪些资源，减少 XSS 的发生。XSS 之所以是漏洞的原因是“内容被当成了程序”执行了，这样我们只需要将用户输入的内容标记为不可执行，那么注入的内容也不会产生实际的危害。需要服务器设置<code>Content-Security-Policy</code>响应头。</p></blockquote><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造，注意和 XSS 中的跨站不同，这个主要是<strong>在其他任意网站进行的操作对目标网站造成了影响</strong>。一个可怕的例子是：打开了一个别人发给你的网站，你的钱莫名其妙变少了，csrf 也被称为one click attack，一点就爆炸。</p><p>原理是攻击者<strong>获取了用户的登陆凭证仿冒了用户</strong>（最常用的攻击方式是携带了cookie）。这种攻击可怕的方式在于被攻击用户是<strong>毫不知情</strong>的。因此可以用来盗取用户资金，冒充用户进行发帖（灌水的时候可以加上攻击者的网址链接，用户一点就由发起了CSRF攻击，从而造成 CSRF 蠕虫，影响非常恶劣，例如微博这种 UGC 平台）</p><p>攻击者通过一些技术手段欺骗用户去访问一个自己以前认证过的网站并执行一些操作（发邮件，发消息，购买商品，转账等）。因为浏览器之前认证过，被访问的网站会觉得这是真实用户操作。</p><h2 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h2><ul><li>Get 请求应该具有幂等性，不能对数据进行修改</li><li>限制 Cookie 在跨站请求中的发送，<a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">cookie的samesite属性</a>，这种方式防止 CSRF 非常简单，但是有浏览器兼容性问题。</li><li>CSRF 是绕过了网站的前端直接发送带有 cookie 信息的请求，因此可以在网站前端加入只有前端才能得到的信息。基于这个思想有 2 种解决方案：验证码和 csrf_token。都能很大程度避免 CSRF，但是验证码对体验其实是有降低的，csrf_token 的原理是后端生成随机字符串放到 session 和前端表单的隐藏域中（不需要实际显示），表单提交的时候校验 session 中的 token 和表单提交的 token 是否一致。注意：不管是验证码和 csrf_token 都需要<strong>做空值验证</strong>（注意逻辑陷阱，攻击者可能发送空值绕过验证），在 ajax 请求中token 通常放置在 meta 标签中。</li><li>验证 Refer，禁止来自第三方网站的请求，注意 refer 是一个完整的 url，验证的时候需要保证鲁棒性，例如:<a href="http://www.b.com&c=www.a.com,是一个合法/">http://www.b.com&amp;c=www.a.com，是一个合法</a> refer，如果 a.com仅仅用indexOf(“<a href="http://www.a.com")进行验证可能有安全问题./">www.a.com&quot;)进行验证可能有安全问题。</a></li><li>增加验证流程，例如指纹、密码、短信验证码</li></ul><h1 id="Cookie-的安全性"><a href="#Cookie-的安全性" class="headerlink" title="Cookie 的安全性"></a>Cookie 的安全性</h1><p>Cookie 遵循同源策略，只有同源才可以读写。HTTP only 的 Cookie 对于js是不可见的，path 和 domain 也可以控制 Cookie 的可见性。</p><p>Cookie 常用来保存用户的登陆凭证，因此直接将 uid 放在 Cookie 中有巨大的安全隐患（别人可以篡改 Cookie 模仿任意用户），常见的做法是 uid+签名。大致流程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">KEY</span> = <span class="string">&#x27;HSD#$#%$6575FDGKJFl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">signUid</span>(<span class="params">uid</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hmac = crypto.<span class="title function_">createHmac</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="variable constant_">KEY</span>);</span><br><span class="line">    hmac.<span class="title function_">update</span>(<span class="title class_">String</span>(uid));</span><br><span class="line">    <span class="keyword">return</span> hmac.<span class="title function_">digest</span>(<span class="string">&#x27;hex&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; uid cookie中的uid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; sign cookie中的签名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAuth</span>(<span class="params">uid, sign</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> expectedSign = <span class="title function_">signUid</span>(uid);</span><br><span class="line">    <span class="keyword">return</span> expectedSign === sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> sign = <span class="title function_">signUid</span>(uid);</span><br><span class="line"><span class="comment">// 登陆成功后向cookie中设置uid和uid签名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;uid = &#x27;</span>, uid, <span class="string">&#x27;sign = &#x27;</span>, sign);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户进行其他需要授权的操作的时候验证传入的uid和签名</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;合法用户，验证结果&#x27;</span>, <span class="title function_">checkAuth</span>(uid, sign));</span><br><span class="line">uid = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;篡改cookie中的uid为2，验证结果&#x27;</span>, <span class="title function_">checkAuth</span>(uid, sign));</span><br><span class="line">uid = <span class="number">1</span>;</span><br><span class="line">sign = <span class="string">&#x27;modifyed sign&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;篡改cookie中的签名，验证结果&#x27;</span>, <span class="title function_">checkAuth</span>(uid, sign));</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2fd9ed04-f6e7-4915-a5fb-31f711c86af0.png" alt="image.png"></p><p>除了上述 uid+uid签名 的方式，还有没有不暴露用户信息的方式呢？</p><p>答案是有的，将 uid 以密文的设置到 Cookie，服务器每次对 Cookie中的 uid 进行解密。</p><p>另外还有一种基于 session 的方案，校验用户名和密码之后服务器生成一个键值对，其中key 为 sessionid（随机字符串），value 为用户信息，服务器可以将此信息持久化到外部存储，并将 sessionid 放入客户端 cookie 中，客户端每次请求的时候带上 cookie，这样服务器就知道当前用户了，这样就可以避免暴露 uid。</p><h2 id="XSS与cookie的关系"><a href="#XSS与cookie的关系" class="headerlink" title="XSS与cookie的关系"></a>XSS与cookie的关系</h2><p>XSS 可能盗取用户 cookie，设置 http only 的 cookie 不会被盗取(因为无法被 js 访问)</p><h2 id="CSRF和cookie的关系"><a href="#CSRF和cookie的关系" class="headerlink" title="CSRF和cookie的关系"></a>CSRF和cookie的关系</h2><p>csrf则是利用了用户cookie，验证码和csrf token方式有效的原因是无法修改目标网站的cookie，最好是禁用第三方的cookie。</p><p>如果没有cookie，csrf和xss的攻击威力至少少一大半。</p><h1 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h1><p>一个典型的场景是将目标网站（恶意网站）放入到 iframe 中，并将此 iframe 的透明度设置为 0，导致用户实际上是看不到目标网站的。接下来使用一张比较劲爆的背景图吸引用户对用户进行指导按照指定的位置进行点击，这样用户实际上是在和目标网站进行交互。</p><p>解决方案是服务器输出 header:X-Frame-Options 禁止内嵌。例如支付宝进行这样处理的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>sdfds<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.alipay.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们试图在自己的网页中内嵌支付宝的时候显示如下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/55dbfafa-8ba6-44c2-896e-11051d2b3b47.png" alt="image.png"></p><p>值得注意的是这个 HTTP 头兼容性非常好（从IE8）</p><h1 id="传输安全"><a href="#传输安全" class="headerlink" title="传输安全"></a>传输安全</h1><p>http 中的 connect 方法是实现 http 代理的一种方法，它实际上是一种 TCP 代理，因此也可以代理 HTTPS ，但是 HTTPS 中的内容是密文无法查看。免费的 HTTPS 常用let’s encrypt</p><h1 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h1><p>足够复杂的密码是对抗彩虹表的有效手段之一，因为彩虹表受限于计算和存储性能。密码的变换次数越多越安全，加密成本几乎不变（生成密码的时候速度慢一些），彩虹表失效（数量太大，无法建立通用性），解密成本增大 N 倍。</p><p>保证密码传输安全主要有以下几种手段：</p><ol><li>https传输</li><li>登陆频率限制（一定程度上杜绝暴力破解）</li><li>前端加密意义是有限的（因为前端传的是明文中间人就传明文，前端传的密文中间人就传密文，但是中间人至少无法知道明文密码）</li></ol><h1 id="接入层注入问题"><a href="#接入层注入问题" class="headerlink" title="接入层注入问题"></a>接入层注入问题</h1><p>SQL 注入和 XSS 非常类似：都是<strong>数据变成了程序被以外执行</strong>。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6e8836db-9b63-4890-bbf6-435f528dac20.png" alt="image.png"></p><ol><li>末尾的<code>1=0</code>使得所有条件为假，不会得到任何数据</li><li>末尾的<code>1=1</code>使得所有条件为真，查出所有数据</li><li>可以用于服务器数据库版本探测，比如如果某个版本有漏洞可能被利用</li><li>针对每一条记录都返回 1，2，3</li><li>在 4 的基础上多了最前面的id列</li><li>union 可以将结果展示到结果的下方，可以用于探测表有多少个字段（1，2如果不报错则表示有 2 个字段；1，2，3 不报错就表示有3个字段）</li><li>可以对表数据进行探测</li></ol><p>SQL 注入有非常多的写法，防不胜防，后果非常严重，一定要引起足够重视！其实SQL注入并不是小公司才有，支付宝、腾讯、微博这种体量的公司也曾经出现过这个问题。</p><h2 id="SQL注入的防御"><a href="#SQL注入的防御" class="headerlink" title="SQL注入的防御"></a>SQL注入的防御</h2><ul><li>关闭错误输出：错误信息对于攻击者有非常大的帮助，黑客可以根据报错决定注入方向是否正确或者向哪个方向改进</li><li>检查参数类型：例如输入的 id 只能是整数，不能拼接其他字符串</li><li>对数据进行转义：例如<code>node-mysql</code>包中可以对参数进行转义<code>mysql.escape(param)</code>,在使用占位符<code>?</code>的时候会自动调用<code>escape</code></li><li>参数化查询：查询步骤分2步：①将带参数的SQL发给服务器，但是并不真正执行，因为没有真正的参数，这个时候 SQL 服务器知道了你的意图。②只发送参数。这种方式在 Java 中叫做PreparedStatement，<a href="https://github.com/sidorares/node-mysql2#using-prepared-statements">node-mysql2</a>支持这种方式。使用参数化查询之后<strong>用户无法改变SQL语句的意图</strong>，最简单最彻底的防御</li><li>使用 ORM，安全性好，开发效率也高</li></ul><h2 id="NoSQL的注入和防御"><a href="#NoSQL的注入和防御" class="headerlink" title="NoSQL的注入和防御"></a>NoSQL的注入和防御</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7ae53dd9-569c-410d-8a37-4ba127721737.png" alt="image.png"></p><p>可以看到在 POST 模拟的时候不知道用户名和密码的情况下就得到了 token，即成功登陆。后端登陆的伪码如下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/0aa77479-959c-4b34-b701-3d101607f2b0.png" alt="image.png"></p><p>主要问题在于 password 传的不是字符串而是对象，同样的原理我们可以在不知道 username 的情况下进行相同的注入。</p><p>防御方法：</p><ol><li>入参数据检查和转换</li><li>写完整条件</li></ol><h1 id="接入层上传问题"><a href="#接入层上传问题" class="headerlink" title="接入层上传问题"></a>接入层上传问题</h1><p>上传业务通常分为 2 步</p><ol><li>上传文件</li><li>再次访问上传的文件</li></ol><p>一般而言上传是不会有问题的，但是<strong>当上传的文件被当做程序来解析执行</strong>（例如：服务器是 php，上传的是 php 文件）就有严重问题了。</p><p>解决方案有：</p><ol><li>限制后缀名，例如后端是 php 的话不能上传 php 文件，有的时候非常简单有效，但是不一定准确</li><li>检查文件类型，这个依赖浏览器的 MIME，攻击者可能绕过浏览器</li><li>文件内容检查，不同类型的文件有不同的内容头，即开头的几个字符都是有一定特征的</li><li>程序输出：不要让用户上传的文件被直接访问。即上传文件的目的就是为了显示，可以程序读取文件内容给到前端，但是会降低性能，一个折中的方法是有读文件请求的时候给 NGINX 发一个指令</li><li>权限控制：写权限和执行权限是互斥的，这一条是核心安全保障，<strong>无论在什么情况下都是要遵守的</strong>。php 文件具有执行权限，但是上传文件的目录有写权限。</li></ol><blockquote><p>部署网站的时候一定要用低权限用户，能满足网站正常需要即可。</p></blockquote><h1 id="OAuth-过程"><a href="#OAuth-过程" class="headerlink" title="OAuth 过程"></a>OAuth 过程</h1><ol><li>用户请求使用QQ登陆目标网站</li><li>目标网站重定向到QQ登录页</li><li>用户在QQ登陆页输入自己的用户名和密码</li><li>QQ登陆成功后跳转到目标网站</li><li>目标网站获取access_token</li><li>QQ服务器返回access_token</li><li>用户在目标网站登陆完成</li></ol><p>整个OAuth的过程中用户只是获得了token。这里面有以下几个思想：</p><ol><li>一切行为由用户授权</li><li>授权行为不泄露敏感信息</li><li>授权是会过期的</li></ol><p>其实<strong>在我们自己的业务中也可以利用Oauth的思想防止资料泄露</strong>。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/f99fcf88-0bcf-443a-a9a5-bef65986b46a.png" alt="image.png"></p><p>这样的系统有以下几个特点：</p><ol><li>用户需要授权才能读取资料</li><li>不能批量获取数据</li><li>数据接口可以风控审计（例如 1 分钟内查了 1000 个用户的资料可以直接把服务停掉排查）</li></ol><h1 id="其他安全问题"><a href="#其他安全问题" class="headerlink" title="其他安全问题"></a>其他安全问题</h1><h2 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h2><ul><li>TCP 半连接</li><li>HTTP 连接</li><li>DNS：一般带宽很小，攻击 DNS 是一种非常有效的方案</li></ul><p>DDOS 是大规模分布式拒绝服务攻击，流量可以达到几十或者上百G，用户来源非常广，很难区分正常用户和攻击者，非常难防御。</p><p>更严重的是攻击流量非常大影响到骨干网的时候运营商可能直接把机房流量给你下了，这个时候你的网站自然没人访问了。常见的案例是恶意竞争者攻击别人的游戏服务器。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fb516945-2699-4dff-95b9-e6ed956e2eeb.png" alt="image.png"></p><p>虽然难防，但是我们也是可以做一些<strong>有限</strong>事情的：</p><ul><li>防火墙</li><li>交换机，路由器</li><li>流量清洗</li><li>高防IP（把域名解析到高防IP，背后是大规模的流量清洗服务，能提供非常大的带宽）</li></ul><p>开发时候的预防：</p><ol><li>避免重逻辑业务</li><li>快速失败返回（负载越高，越容易失败，重试几率越大，服务越容易崩溃）</li><li>防雪崩机制</li><li>有损服务（保证核心服务可用）</li><li>CDN</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://imququ.com/post/content-security-policy-reference.html">CSP介绍</a></li><li><a href="https://www.cnblogs.com/rysinal/p/8350783.html">node-mysql包对SQL注入的防御</a></li><li><a href="http://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84SQL%E8%83%BD%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5">为什么预编译的SQL能防止SQL注入</a></li><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">如何防止 CSRF 攻击</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - Redis</title>
      <link href="/2020/06/15/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-Redis/"/>
      <url>/2020/06/15/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-Redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：缓存穿透(Cache Penetration) 和缓存击穿(Cache Breakdown) 的区别。穿透强调大量恶意请求根本不存在的数据，因为这个时候就好像没有缓存层，流量全部到 DB,影响整个系统；击穿就表示有缓存，但是热点 key 失效了，主要是针对的热点数据。穿透-DB无数据，击穿-DB有数据。</p></blockquote><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>访问一个 DB 和缓存中都不存在的 key 时，请求会直接打到 DB 上，并且因为查不到数据，没法建立缓存，下一次请求还会打到 DB 上。这个时候缓存就像被“穿透”了一样，起不到任何作用，每次请求都会打到 DB 就好像没有缓存一样，大量这样的请求可能导致 DB 挂掉。</p><p>对于系统，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。黑客发出的那 4000个攻击，缓存中查不到，每次你去数据库里查，也查不到，举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/93b08b0b-33bc-4dba-91f3-ae5c678a1e2f.png" alt="缓存穿透问题"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>接口校验。在正常业务中可能存在少量访问不存在key的情况，但是一般不会出现大量的这种情况，所以这种场景发生的最大可能是遭受了非法攻击。可以在最外层加上验证：用户鉴权、数据合法性验证等。例如商品查询中，商品是正整数，则可以直接对非正整数进行过滤</li><li>缓存空值。当缓存和DB中都没有查询到值得时候，可以将空值写进缓存，但是设置比较短的过期时间，该时间需要根据产品业务特性来设置</li><li>布隆过滤器。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则进一步查询缓存和 DB</li></ol><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>例如有以下业务代码获取商品子分类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> catsStr = <span class="keyword">await</span> redis.<span class="title function_">get</span>(<span class="string">&#x27;subCats&#x27;</span> + catId);</span><br><span class="line"><span class="keyword">if</span> (!catsStr) &#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="keyword">await</span> mysql.<span class="title function_">getSubCatList</span>(catId);</span><br><span class="line">  <span class="comment">// 注意判空逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (list &amp;&amp; list.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> redis.<span class="title function_">set</span>(<span class="string">&#x27;subCats&#x27;</span> + catId,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(list),<span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(catsStr);</span><br></pre></td></tr></table></figure><p>以上代码的问题在于：如果恶意用户发送的 catId 不合法，那么这些<em>请求都会穿透缓存达到 MySQL</em>。最简单的解决方案是直接将上述代码的判空条件去掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存空对象的方式解决缓存穿透问题</span></span><br><span class="line"><span class="keyword">const</span> catsStr = <span class="keyword">await</span> redis.<span class="title function_">get</span>(<span class="string">&#x27;subCats&#x27;</span> + catId);</span><br><span class="line"><span class="keyword">if</span> (!catsStr) &#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="keyword">await</span> mysql.<span class="title function_">getSubCatList</span>(catId);</span><br><span class="line">  <span class="comment">// 去掉判空逻辑</span></span><br><span class="line">  <span class="keyword">await</span> redis.<span class="title function_">set</span>(<span class="string">&#x27;subCats&#x27;</span> + catId,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(list), <span class="number">30</span>);</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(catsStr);</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><blockquote><p><a href="https://consoles.fun/2025/01/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8">布隆过滤器</a>的特点是：<strong>判断不存在的时候一定不存在，判断存在的时候大概率存在</strong>。（原理是使用多个桶中的多个哈希函数，因此一旦一个哈希函数计算不存在就一定不存在；反之，因为哈希存在冲突的可能，可能一个并不存在的值，经过计算和另一个存在桶中的值哈希相同）。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8231c2fb-64c0-425b-bf1c-b491e22a7d1f.png" alt="image.png"></p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个<strong>key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库</strong>，就像是在一道屏障上凿开了一个洞。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>加锁互斥。在并发的多个请求中，只有第一个请求能拿到锁并执行 DB 查询操作，其他线程拿不到锁就阻塞这，等到第一个线程将数据写入缓存后直接走缓存。互斥锁选择大部分是采用 redis 的分布式锁，这可以保证只有一个请求走到 DB，这是一种思路。但是仔细想想的话，其实没有必要严格保证只有一个请求走 DB，<em>只要保证走到 DB 的请求大大降低即可</em>，使用 JVM 锁其实已经足够了，同时性能比分布式锁更好</li><li>热点数据不过期。直接将缓存设置为不过期，由定时任务异步加载数据更新缓存。这种方式适用于比较极端的情况，例如流量特别大的场景。使用时需要考虑业务能接受数据不一致的时间，还有就是异常情况的处理，不要到时候缓存刷新不上，一直是脏数据，那就凉了。</li><li>热点数据提前续租。在接近失效的时候主动延长其缓存时间。</li><li>限制并发访问。</li></ol><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>对于一个系统，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。缓存雪崩的事前事中事后的解决方案如下。</p><ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ccd8b0d0-e28d-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p><p>用户发送一个请求，系统收到请求后，先查本地 ehcache 缓存，如果没查到再查 redis。如果 ehcache 和 redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 redis 中。</p><p>限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p>这样做有以下几个好处：</p><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2&#x2F;5 的请求都是可以被处理的。</li><li>只要有 2&#x2F;5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li></ul><p>综上所述，总结为以下几点：</p><ul><li>缓存层高可用</li><li>客户端降级</li><li>提前演练是解决雪崩问题的重要方法</li></ul><p>大量的热点 key 设置了相同的过期时间，在同一时刻大量失效。缓存雪崩其实有点像“升级版的缓存击穿”。缓存击穿是一个热点 key，而缓存雪崩是一组热点 key。因此缓存击穿的解决方案也适用于缓存雪崩：</p><ol><li>加互斥锁</li><li>热点数据不过期</li><li>过期时间分散</li><li>限流和降级</li></ol><h1 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h1><p>问题描述：热点 key + 较长的重建时间（执行了较长时间的SQL）</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/148a34a3-9d42-4dfc-b9b0-d3f7ab4e85d3.png" alt="image.png"></p><p>如图所示，并发高德时候大量线程进行了缓存的重建，客户端响应就会很慢，存储层的压力也比较大。解决方案有：</p><ul><li>互斥锁</li><li>数据永不过期：为每个value添加逻辑过期时间，使用一个线程去重建缓存（用过互斥锁）</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/aedcbc5c-3c29-401b-9426-f4794c9167dd.png" alt="互斥锁"></p><p>互斥锁保证了只有一个线程进行缓存重建的问题，但是会导致大量线程hang住的问题</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8701db00-2426-4ea8-9f55-2e2dc8c05841.png" alt="数据永不过期"></p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/9327e9ad-51fa-4884-80a5-8bc2af65889c.png" alt="image.png"></p><h1 id="无底洞问题"><a href="#无底洞问题" class="headerlink" title="无底洞问题"></a>无底洞问题</h1><p>这个问题产生于facebook，2010年的时候fb有了3000个memcached节点，加机器造成了性能不升反降的问题。</p><p>问题的关键在于节点非常多的时候，节点间通信的网络IO成本就不容忽视了。</p><h1 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ac8efe49-2164-4c2c-93fd-1d8b645ed57c.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/407df850-5a37-49bf-8ce3-74ce7cd7b7ba.png" alt="image.png"></p><blockquote><p>1条redis命令在内存中执行的时间大概是100ns。</p></blockquote><h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><p>redis的慢查询是采用固定长度的队列结构（List）：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3900bf41-27c2-4e53-baa5-a5f276e33092.png" alt="image.png"></p><p>主要有2个配置:</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/847850b8-3e46-463f-80ac-82590db82aa2.png" alt="image.png"></p><p><code>slowlog-log-slower-than</code>通常设置为1ms（默认是10ms），因为redis通常的QPS是万级别的，平均时间是0.1ms，队列长度也不要设置太小（1000是比较合理的），定期持久化慢查询结果，因为这样对于定位历史问题非常有帮助。</p><h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fb89b2d9-8f49-48a7-bce0-93a7dcfa16b0.png" alt="image.png"></p><p>将命令批量打包后发给服务器执行然后批量返回执行的结果。有2点需要注意：</p><ol><li>redis的命令执行时间通常是微秒级别</li><li>pipeline中命令的条数要控制（网络）</li></ol><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/72b66878-2a85-4ad9-ac60-20d20702e2c2.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/209e9d8d-f4bf-496c-8c83-06df5fa3d253.png" alt="image.png"></p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/55f835aa-ab82-4b44-b9bf-33f2e0e7087b.png" alt="image.png"></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>主从复制的一个作用是读写分离（高性能），还能一定程度上实现高可用、数据备份。在生产环境中主从不能在一台机器上，因为丧失了高可用，没有任何意义。主要命令是<code>slaveof</code>，从节点不能做任何写操作:<code>slave-read-only</code>设置为<code>yes</code>。<strong>主从复制没有真正做到故障的自动转移</strong>。master节点宕机之后处理起来比较麻烦，没有实现 master 宕机之后 slave 升级为master。解决这个问题 redis 提供了 sentinel 机制。</p><p>主从复制因为所有的从节点都是依赖主节点，所以受限于主节点的存储能力和写能力。</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/42b41d1d-85a8-48c6-bff7-88083144ed83.png" alt="image.png"></p><p>主节点配置<br>redis-7000.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line">logfile <span class="string">&quot;7000.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;./&quot;</span></span><br></pre></td></tr></table></figure><p>从节点配置7001,7002</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/7000/7001/g&quot;</span> redis-7000.conf &gt; redis-7001.conf</span><br><span class="line">sed <span class="string">&quot;s/7000/7002/g&quot;</span> redis-7000.conf &gt; redis-7002.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;slaveof 127.0.0.1 7000&quot;</span> &gt;&gt; redis-7001.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;slaveof 127.0.0.1 7000&quot;</span> &gt;&gt; redis-7002.conf</span><br></pre></td></tr></table></figure><p>启动主节点7000，两个从节点7001和7002：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/39ca59de-47b3-4e2f-ae7e-9759e5d549b0.png" alt="image.png"></p><p>编辑sentinel配置文件：</p><p>redis-sentinel-26379.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/tmp&quot;</span></span><br><span class="line">logfile <span class="string">&quot;26379.log&quot;</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 7002</span><br><span class="line">sentinel known-slave mymaster 127.0.0.1 7001</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><p>测试sentinel26379节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br><span class="line">redis-cli -p 26379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><p>配置sentinel 26380和26381节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&quot;s/26379/26380/g&quot;</span> redis-sentinel-26379.conf &gt; redis-sentinel-26380.conf</span><br><span class="line">sed <span class="string">&quot;s/26379/26381/g&quot;</span> redis-sentinel-26379.conf &gt; redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/64909d05-6297-498b-8978-3b45a05f8ceb.png" alt="image.png"></p><p>演示master节点的故障转移：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Redis</span> = <span class="built_in">require</span>(<span class="string">&#x27;ioredis&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> <span class="title class_">Redis</span>(&#123;</span><br><span class="line">    <span class="attr">sentinels</span>: [</span><br><span class="line">        &#123;<span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="attr">port</span>: <span class="number">26379</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="attr">port</span>: <span class="number">26380</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="attr">port</span>: <span class="number">26381</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;mymaster&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="keyword">await</span> redis.<span class="title function_">incr</span>(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    util.<span class="title function_">log</span>(<span class="string">&#x27;get i&#x27;</span>, i)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/8fcab923-7770-4e3d-a47b-cab7e56588d2.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6fafbe06-8d2d-4e51-90de-4ad8addf3178.png" alt="image.png"></p><p>sentinel节点只是配置中心而不是代理，客户端连接到sentinel节点拿到master节点连接信息。</p><h2 id="哨兵的底层原理"><a href="#哨兵的底层原理" class="headerlink" title="哨兵的底层原理"></a>哨兵的底层原理</h2><p>对于每个被 Sentinel 监控的主节点来说，Sentinel 会创建 2 个连向主服务器的异步网络连接：</p><ol><li>命令连接：用于向主节点发送命令，并接受命令回复。</li><li>订阅连接：订阅主节点的 <code>__sentinel__:hello</code> 频道（Sentinel 自动发现和集群通信的核心机制）。</li></ol><p>使用 2 个连接的好处：</p><ol><li>命令连接的阻塞（如主节点响应慢）不会影响订阅通道的实时性。</li><li>避免协议解析的复杂性（命令和订阅消息的格式不同，通信模式有差异）。</li></ol><blockquote><p>Sentinel 和其他 Sentinel 之间只会有命令连接。</p></blockquote><h3 id="Sentinel-如何发现新-slave-节点加入"><a href="#Sentinel-如何发现新-slave-节点加入" class="headerlink" title="Sentinel 如何发现新 slave 节点加入"></a>Sentinel 如何发现新 slave 节点加入</h3><p>新节点加入会将自己注册到 master 的 slaves 列表中，Sentinel 节点会周期性向 mater 发送 INFO 命令，因此在下一次收到 master 的 INFO 响应的时候就会感知到新节点的加入。</p><h3 id="Sentinel-感知节点下线"><a href="#Sentinel-感知节点下线" class="headerlink" title="Sentinel 感知节点下线"></a>Sentinel 感知节点下线</h3><p>默认情况下，Sentinel 会每秒向它创建了命令连接的实例（master，slave，其他 sentinel）发送 PING 命令，通过回复判定节点的在线状态。如果返回不在线或者在特定的时间内没有返回，Sentinel 就将这个节点标记为<strong>主观下线</strong>。为了确认这个服务器是否是真的下线了，它会向同样监视这一主服务器的其他 Sentinel 进行询问(<code>SENTINEL is-master-down-by-addr</code>命令)，看它们是否认为主服务器已经进入了下线状态（可能主观，也可能客观）。当 Sentinel 从其他 Sentinel 那里接收到足够数量的已下线判断之后，Sentinel 就会将从服务器标记为<strong>客观下线</strong>，接下来从众多的 Sentinel 中选举（基于 Raft 共识算法）出一个负责执行故障转移的<em>领头 Sentinel</em>，由它对主服务器执行故障转移操作。</p><p>主观下线：只有 Sentinel 自己判断为下线，客观下线：询问其他 Sentinel，多数（quorum）认为下线。</p><h4 id="选举出领头-Sentinel-并执行故障转移"><a href="#选举出领头-Sentinel-并执行故障转移" class="headerlink" title="选举出领头 Sentinel 并执行故障转移"></a>选举出领头 Sentinel 并执行故障转移</h4><ol><li>Sentinel 自荐：任何一个发现主节点客观下线的 Sentinel 会先将自己设为<em>候选人</em>，并递增自己的配置纪元（epoch），接下来向其他 Sentinel 广播自己的 runid 和 current_epoch（类似选举轮次）</li><li>其他 Sentinel 投票：每个 Sentinel 在同一 epoch 中 只能投一票，且遵循先到先得原则。如果目标 Sentinel 尚未在本轮 epoch 中投票，则同意投票，并回复支持的 runid。如果已投票，则拒绝请求。</li><li>统计票数：发起选举的 Sentinel 如果收到超过 quorum，则成为领头 Sentinel。</li><li>执行故障转移：领头 Sentinel 负责。</li></ol><h1 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群(Cluster)"></a>集群(Cluster)</h1><ol><li>握手(CLUSTER MEET)。</li><li>指派槽(CLUSTER ADDSLOTS)。分配 16384 个 slots 到各个节点，只有这些槽全部被分配，整个集群才是上线状态（ok）</li></ol><p>指派槽之后，会向集群中的其他节点广播该节点负责的槽，这样所有节点都知道了该节点负责哪些 slots。</p><p>集群解决了单机 QPS 有限(10W QPS)和容量有限的问题。常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定 node 加入集群(握手)</span></span><br><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br><span class="line"><span class="comment"># 查看集群中的节点</span></span><br><span class="line">CLUSTER NODES</span><br><span class="line"><span class="comment"># 指派槽</span></span><br><span class="line">CLUSTER ADDSLOTS</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redis-cluster-node-meet.png" alt="节点握手过程"></p><p>节点 A 和节点 B 握手完成后会使用 Gossip 协议传播给集群中的其他节点，让其他节点也和节点 B 进行握手，最终经过一段时间后，节点 B 会被集群中的所有节点认识。</p><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/4d5db512-8e53-4435-9338-d9f05f04b019.png" alt="数据分区方案对比"></p><ul><li>节点取余：基于客户端分片，节点伸缩的时候，大量数据(50%-80%)需要迁移(rehash)。</li><li>一致性哈希：memcached中广泛使用。优化取余，只影响邻近节点，但是还是有数据迁移。</li><li>虚拟槽分区：redis cluster采用。每一个槽映射一个数据子集，一般比节点数大；良好的hash函数，例如CRC16；服务端管理节点、槽和数据。</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/e75f1098-627e-46f1-8488-4fe52a62f7a5.png" alt="Redis cluster 的虚拟槽"></p><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>配置文件<code>redis-[7000-7005].conf</code>一共6个配置文件，其中一个文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">pidfile <span class="string">&quot;/var/run/redis-7000.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;7000.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;./&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-7000.rdb&quot;</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><p>启动6个节点（主节点7000-7002），然后随便连接一个客户端：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/b9030cfa-4abc-437e-b2b1-75d5f063b7c1.png" alt="image.png"></p><p>可以发现集群还不可用，需要分配槽：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/97e0203d-218c-4873-8bb1-a27719fdf7b4.png" alt="image.png"></p><h3 id="节点握手meet"><a href="#节点握手meet" class="headerlink" title="节点握手meet"></a>节点握手meet</h3><p>通过此操作，各个节点可以彼此感知。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7c8f049d-f424-44b3-aa61-ad14dea02f7e.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/04799ee6-325b-4288-8803-e68b99da74dc.png" alt="image.png"></p><h3 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h3><p>16384个槽分配到3个主节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start=0</span><br><span class="line">end=16384</span><br><span class="line"></span><br><span class="line">startPort=7000</span><br><span class="line">endPort=7002</span><br><span class="line">step=5461</span><br><span class="line">startSlot=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> `<span class="built_in">seq</span> <span class="variable">$&#123;startPort&#125;</span> <span class="variable">$&#123;endPort&#125;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  endSlot=`<span class="built_in">expr</span> <span class="variable">$&#123;startSlot&#125;</span> + <span class="variable">$&#123;step&#125;</span>`</span><br><span class="line">  <span class="keyword">for</span> slot <span class="keyword">in</span> `<span class="built_in">seq</span> <span class="variable">$&#123;startSlot&#125;</span> <span class="variable">$&#123;endSlot&#125;</span>`</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;port:<span class="variable">$&#123;port&#125;</span>,slot:<span class="variable">$&#123;slot&#125;</span>&quot;</span></span><br><span class="line">    <span class="comment">#redis-cli -p $&#123;port&#125; cluster delslots $&#123;slot&#125;</span></span><br><span class="line">    redis-cli -p <span class="variable">$&#123;port&#125;</span> cluster addslots <span class="variable">$&#123;slot&#125;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  startSlot=`<span class="built_in">expr</span> <span class="variable">$&#123;endSlot&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/732e4fd3-b975-4285-9519-7e9bd1718219.png" alt="image.png"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/4bed0e5d-47ca-4689-b324-922c044741e5.png" alt="image.png"></p><h3 id="设置主从关系"><a href="#设置主从关系" class="headerlink" title="设置主从关系"></a>设置主从关系</h3><p>设置7003为7000的从节点</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c43d1387-554d-4db0-8d69-8a570e43ad00.png" alt="image.png"></p><p>用相同的命令设置7004和7005从节点：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/5543f820-12ba-4da3-a4a2-095c81be835e.png" alt="image.png"></p><p>接下来我们就可以从集群中读取和写入数据了：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/01f2cc37-8f92-4033-8fda-c439413308cb.png" alt="image.png"></p><p>key命中哪个slot是根据key算出crc16然后对16384取余得到，使用<code>CLUSTER KEYSLOT hello</code>可以查看key命中在哪个slot。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/d3ea6c16-708d-440c-a2e9-d4f45de8dd42.png" alt="image.png"></p><p>如果没有命中槽，服务器会返回move异常，这时候需要客户端重新连接目标节点发送命令。</p><p>生产环境中使用以下的配置错开配置来节省机器资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主节点        从节点</span></span><br><span class="line">10.0.0.1:7000 10.0.0.2:7003</span><br><span class="line">10.0.0.2:7001 10.0.0.3:7004</span><br><span class="line">10.0.0.3:7002 10.0.0.1:7005</span><br></pre></td></tr></table></figure><p>redis官方提供了搭建集群的ruby脚本，<a href="http://consoles.fun/2018/11/25/redis/#%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%99%A8%E4%BB%8ERuby-redis-trib-rb-%E7%A7%BB%E6%A4%8D%E5%88%B0C">redis5.0之后创建集群就变得非常容易</a></p><h3 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h3><p>使用直连的方式而不是代理追求卓越性能</p><ol><li>从集群中选择一个可以运行的节点，使用cluster slots初始化槽和节点映射</li><li>将cluster slots的结果映射到本地，为每个节点创建连接池</li><li>准备执行命令</li><li>注意兼容move异常对本地缓存进行刷新</li></ol><p>因为执行命令的时候key必须在一个槽上，因此mget，mset这样的对多个key执行命令执行命令在cluster模式下执行就会报错：<code>CROSSSLOT Keys in request don&#39;t hash to the same slot</code>.</p><p>解决这个问题主要有以下几种方案:</p><ol><li>将mget分解为多次get</li><li>将mget中的key按照crc分组，确保一组mget中的key落在一个slot上</li><li>使用hash tag将多个key落在同一个slot里面</li></ol><p>hash_tag:当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。</p><p>如何处理请求倾斜的问题：</p><ol><li>避免big key</li><li>热键不要使用hash tag</li><li>当一致性要求不高的时候，可以使用本地缓存加MQ</li></ol><p>集群模式下并不建议使用读写分离，因为从节点每次连接都需要执行readonly命令，读写分离并不能解决复制延迟、读取过期数据、从节点故障的问题，成本非常高。</p><p>分布式redis虽然解决了容量和性能的扩展性，但是很多业务其实“不需要”，它主要有以下的几个痛点：</p><ol><li>客户端维护更复杂：SDK和应用本身的消耗（例如更多的连接池），客户端性能会降低</li><li>lua，事务和有些命令无法跨节点使用：mget,keys,scan,flush,sinter等</li></ol><p>很多场景下Sentinel其实已经足够好了，它解决了高可用的问题。</p><h1 id="缓存设计和优化"><a href="#缓存设计和优化" class="headerlink" title="缓存设计和优化"></a>缓存设计和优化</h1><h2 id="缓存的成本："><a href="#缓存的成本：" class="headerlink" title="缓存的成本："></a>缓存的成本：</h2><ol><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li><li>代码维护成本：多了一层缓存维护逻辑</li><li>运维成本：例如 Redis Cluster</li></ol><p>超时剔除和主动更新结合，最大内存和缓存淘汰策略兜底。</p><h1 id="使用-Redis-实现限流"><a href="#使用-Redis-实现限流" class="headerlink" title="使用 Redis 实现限流"></a>使用 Redis 实现限流</h1><ol><li>基于计数器和过期时间实现的计数器算法：使用一个计数器存储当前请求量（新请求使用 INCR），并设置一个过期时间，计数器在一段时间内自动清零。计数器未到达限流值的时候可以继续运行，反之拒绝。</li><li>基于 Zset 实现的滑动窗口算法：将请求都存入 ZSet 中，在 score 中存储请求时间。使用 zrange 方法可以轻松获取 2 个时间窗口内的请求量。</li><li>基于 List 实现的令牌桶算法：在程序中使用定时任务将令牌添加到 List 中，程序使用 lpop 成功获取令牌才进行放行。</li></ol><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="百万数据存入-Redis-有哪些实现方案？"><a href="#百万数据存入-Redis-有哪些实现方案？" class="headerlink" title="百万数据存入 Redis 有哪些实现方案？"></a>百万数据存入 Redis 有哪些实现方案？</h2><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/sava-large-data-to-redis.png">存储大量数据到 Redis 的方案</a></p><h3 id="前置工作：预处理和压缩"><a href="#前置工作：预处理和压缩" class="headerlink" title="前置工作：预处理和压缩"></a>前置工作：预处理和压缩</h3><ol><li>数据预处理：例如去重、格式转换等，可以减少实际写入的数据量</li><li>数据压缩：可以考虑使用 Redis 的压缩功能（LZF,Snappy 等压缩算法）</li></ol><h3 id="插入方案"><a href="#插入方案" class="headerlink" title="插入方案"></a>插入方案</h3><ol><li>批处理：使用 pipeline允许客户端发送多个命令到服务器，而不需要等待每个命令的回复。这减少了网络延迟的影响，提高了写入速度；使用 MSET, HMSET 等批量操作命令</li><li>数据分片：集群模式下，数据可以分布在多个节点上，从而分散负载并提高写入吞吐量</li><li>使用 lua 脚本：将多个操作组合成一个原子操作，减少客户端与服务器之间的通信次数</li><li>异步加载：将一个大任务分成多个小任务，然后再通过异步加载的方式批量写入 Redis，这样可以避免阻塞主线程，提高应用的整体响应性。</li></ol><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>除了以上手段之外，我们还可以通过以下手段优化 Redis：</p><ol><li>调整 Redis 配置参数：根据实际情况调整 Redis 的内存限制、持久化策略等参数，以提高性能和稳定性。</li><li>监控内存使用情况：使用 Redis 的监控工具，实时监控内存使用情况，避免内存溢出。</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://github.com/sohutv/cachecloud">https://github.com/sohutv/cachecloud</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 - js 基础</title>
      <link href="/2020/05/12/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-js%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/12/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-js%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>夫大人者，与天地合其德，与日月合其明，与四时合其序，与鬼神合其吉凶。——《周易》</p></blockquote><h1 id="在-JavaScript-中，-a-1-a-2-a-3-是否有可能为-true"><a href="#在-JavaScript-中，-a-1-a-2-a-3-是否有可能为-true" class="headerlink" title="在 JavaScript 中， (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 是否有可能为 true"></a>在 JavaScript 中， (a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2 &amp;&amp; a &#x3D;&#x3D; 3) 是否有可能为 true</h1><blockquote><p>参考解决思路：a是一个对象或函数，每次调用取值都不一样，以有序的规律变化就能实现多等</p></blockquote><h2 id="方案1：使用-getter"><a href="#方案1：使用-getter" class="headerlink" title="方案1：使用 getter"></a>方案1：使用 getter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">global</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> temp++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="方案2：重写valueOf-toString"><a href="#方案2：重写valueOf-toString" class="headerlink" title="方案2：重写valueOf&#x2F;toString"></a>方案2：重写valueOf&#x2F;toString</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从表面看，应该是<code>valueOf()</code>每次都被调用了，但是为什么会这样？我们又没有调用它。这里的<code>valueOf</code>为什么会被调用？这主要是<code>==</code>转换规则（换成 <code>===</code>，这种方式就不成立了）</p><ul><li>如果一个是<code>null</code>，一个是<code>undefined</code>，则它们相等</li><li>如果一个是数字，一个是字符串，先将字符串转换成数字，然后使用转换后的值进行比较</li><li>如果其中的一个值为<code>true</code>，则转换成<code>1</code>再进行比较；如果其中一个值为<code>false</code>，则转换成<code>0</code>再进行比较</li><li>如果一个值是对象，另一个值是数字或者字符串，则将对象转换成原始值再进行比较。转换成字符串时，会先调用<code>toString()</code>，如果没有<code>toString()</code>方法或者返回的不是一个原始值，则再调用<code>valueOf()</code>，如果还是不存在或者返回不是原始值，则会抛出一个类型错误的异常。返回的原始值会被转换成字符串；如果转换成数字时，也是类似的，不过是会先调用<code>valueOf()</code>，再调用<code>toString()</code>，返回的原始值会被转换成数字</li><li>其他不同类型之间的比较均不相等</li></ul><blockquote><p>所以在这里使用 a 与这些字符进行比较时会被转换成数字，此时会默认调用字符串的<code>valueOf()</code>方法，我们将这个方法进行重写，用于拦截处理a的值</p></blockquote><p>同理可以使用<code>toString</code>方法处理，因为字符串转数字类型时会涉及到<code>valueOf()</code>和<code>toString()</code>，道理一样,只要符合递增规则的，a就可以实现多等，因为此a非彼a</p><h2 id="方案3：ES6-Proxy"><a href="#方案3：ES6-Proxy" class="headerlink" title="方案3：ES6 Proxy"></a>方案3：ES6 Proxy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;<span class="attr">i</span>: <span class="number">0</span>&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">target, name</span>) =&gt;</span> name === <span class="title class_">Symbol</span>.<span class="property">toPrimitive</span> ? <span class="function">() =&gt;</span> ++target.<span class="property">i</span> : target[name]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.toPrimitive</code>是一个内置的<code>Symbol</code>值，用于定义对象在被转换为原始值（如数字、字符串）时的行为。当一个对象需要被转换为原始值时，JavaScript 会调用对象的<code>Symbol.toPrimitive</code>方法（如果存在）。</p><p>当 a 参与 <code>==</code> 比较的时候，js 会尝试将 a 转化为原始值，由于 a 是一个对象，js 会调用 a 的 <code>a[Symbol.toPrimitive]</code> 方法，get 拦截器返回的函数会被调用，返回 target.value 的当前值，并将 value 递增。</p><h2 id="方案4：使用不可见字符"><a href="#方案4：使用不可见字符" class="headerlink" title="方案4：使用不可见字符"></a>方案4：使用不可见字符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> ﾠ<span class="number">1</span> = a;</span><br><span class="line"><span class="keyword">var</span> ﾠ<span class="number">2</span> = a;</span><br><span class="line"><span class="keyword">var</span> ﾠ<span class="number">3</span> = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ===ﾠ<span class="number">1</span> &amp;&amp; a ===ﾠ<span class="number">2</span> &amp;&amp; a ===ﾠ<span class="number">3</span> );</span><br></pre></td></tr></table></figure><p>这些变量的名字看起来像是数字，但实际上它们的名字中包含了不可见的 Unicode 字符（例如零宽空格或其他不可见字符），这些字符在代码中不可见，但 JavaScript 引擎会将其视为变量名的一部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(encodeURIComponent(&quot;ﾠ1&quot;)); // 输出 &quot;%EF%BE%A01&quot;</span><br><span class="line">console.log(&quot;ﾠ1&quot;.charCodeAt(0)); // 输出 65408</span><br></pre></td></tr></table></figure><h2 id="方案5：join-shift"><a href="#方案5：join-shift" class="headerlink" title="方案5：join+shift"></a>方案5：join+shift</h2><p>对于对象数组进行比较时，这里数组 a 每次比较的时候都会默认调用<code>toString()</code>，然后<code>toString()</code>又会默认调用<code>join()</code>，这里将<code>join()</code>的实现改为<code>shift()</code>，意思是删除第一个数组元素值并返回。这样每次调用都会导致 a 数组删除第一个值并且返回删除掉的那个值，结合这样的规律，每次比较都取出对应位置的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="property">join</span> = a.<span class="property">shift</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);                <span class="comment">// [ 1, 2, 3, join: [Function: shift] ]</span></span><br><span class="line"><span class="comment">// console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3); // true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">1</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);                <span class="comment">// [ 2, 3, join: [Function: shift] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">2</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);                <span class="comment">// [ 3, join: [Function: shift] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == <span class="number">3</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);                <span class="comment">// [ join: [Function: shift] ]</span></span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">[] == [] <span class="comment">// false，不用的引用</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="function">()=&gt;</span><span class="number">1</span>) <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Array</span> <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="title function_">typeof</span>(<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>)) <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>根据 w3c 标准，分为基本数据类型(7)和对象(1)。基本类型: string(1), number(2), null(3), undefied(4), boolean(5), bignumber(6), symbol(7)。对象：object(1)。</p><p><strong>数组和函数都是 object 类型。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="string">&#x27;0&#x27;</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="string">&#x27;aaa&#x27;</span>] = <span class="number">3</span></span><br><span class="line">arr[<span class="string">&#x27;1&#x27;</span>] = <span class="number">555</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="string">&#x27;0&#x27;</span>]) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>] + arr[<span class="string">&#x27;0&#x27;</span>]) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(arr)) <span class="comment">// [ &#x27;0&#x27;, &#x27;1&#x27; ,&#x27;aaa&#x27;]</span></span><br></pre></td></tr></table></figure><p>js 中的数组本质上就是对象，意味着可以用数字索引来访问元素，也可以使用字符串键来访问属性。当使用字符串键的时候，如果该字符串可以转成有效的数字索引，则将其视为数字索引，因此 <code>arr[1]</code> 和 <code>arr[&#39;1&#39;]</code> 是一个东西。数组的 length 只反映基于数字索引（也包含可以隐式转换成数字）的实际元素的数量。所以虽然 arr 对象有 3 个 key，其长度还是 2。</p><p><code>Object.is</code> 用于比较两个值是否完全相等，解决了 <code>NaN</code>，<code>0</code> 与 <code>-0</code> 使用 <code>===</code> 存在的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, +<span class="number">0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>只有对象才能使用这个运算符（基础类型不能使用），会进行原型链的查找，因此有下面的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false, typeof null 返回 object 的原因是历史原因</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// false, 1 是基本类型</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// false，Number(1) 是函数调用，返回基本类型 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">// true，此时才是对象</span></span><br></pre></td></tr></table></figure><h2 id="原始类型和其包装类"><a href="#原始类型和其包装类" class="headerlink" title="原始类型和其包装类"></a>原始类型和其包装类</h2><p>字符串是原始类型，它的行为和对象不同。<strong>虽然可以向字符串添加属性，但是这些属性不会持久化，并且在某些操作中会被忽略</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">s.<span class="property">c</span> = <span class="string">&#x27;4&#x27;</span></span><br><span class="line">s.<span class="property">d</span> = <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s:&#x27;</span>, s) <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`s.c: <span class="subst">$&#123;s.c&#125;</span>, s.d: <span class="subst">$&#123;s.d&#125;</span>`</span>); <span class="comment">// undefined, undefined</span></span><br><span class="line"><span class="keyword">const</span> [a,b] = s </span><br><span class="line"><span class="keyword">const</span> &#123;c,d&#125; = s</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d) <span class="comment">// 1 2 undefined undefined</span></span><br></pre></td></tr></table></figure><p><code>s.c = &#39;4&#39;</code>, <code>s.d = &#39;5&#39;</code> 这两句话在试图给一个字符串添加属性的时候，js 会创建一个<em>临时的对象包装器</em>来处理这个操作，但是这个对象包装器会在操作完成后立即被销毁。因此第 5 行输出 s.a 和 s.b 都是 <code>undefined</code>。接下来第 6 行是数组的解构赋值，将字符串 s 当做一个<em>可迭代对象</em>，并逐个提取字符。因此 a:’1’, b:’2’。再接下来第 7 行使对象解构，尝试从字符串 s 中提取属性 c 和属性 d。由于字符串没有这两个属性，则 c 和 d 都是 <code>undefined</code>。</p><p>如果把这个题目改一改 s 并不是原始的字符串，而是<code>String</code>对象则情况如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 这个会输出 1 2 4 5</span></span><br><span class="line">s.<span class="property">c</span> = <span class="string">&#x27;4&#x27;</span></span><br><span class="line">s.<span class="property">d</span> = <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s:&#x27;</span>, s) <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`s.c: <span class="subst">$&#123;s.c&#125;</span>, s.d: <span class="subst">$&#123;s.d&#125;</span>`</span>); <span class="comment">// 4, 5</span></span><br><span class="line"><span class="keyword">const</span> [a,b] = s </span><br><span class="line"><span class="keyword">const</span> &#123;c,d&#125; = s</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d) <span class="comment">// 1 2 4 5</span></span><br></pre></td></tr></table></figure><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true，隐式转换，字符串 -&gt; 数字</span></span><br><span class="line"><span class="number">0</span> == [] <span class="comment">// true，隐式转换，对象 -&gt; 原始值(首先调用toString,然后是valueOf，对于数组的 toString，默认是 join 方法，空数组 join 是空字符串，从而走回了字符串和数字的比较)</span></span><br><span class="line"><span class="number">0</span> == [<span class="string">&#x27;&#x27;</span>] <span class="comment">// true，和上面的情况同理</span></span><br></pre></td></tr></table></figure><p>优先级：<code>Symbol.toPrimitive</code> &gt; <code>valueOf</code> &gt; <code>toString</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj); <span class="comment">// 42（hint 为 &quot;number&quot;）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;obj&#125;</span>`</span>); <span class="comment">// &quot;foo&quot;（hint 为 &quot;string&quot;）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="string">&#x27;&#x27;</span>); <span class="comment">// &quot;default&quot;（hint 为 &quot;default&quot;）</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] + [] <span class="comment">// &#x27;&#x27; -&gt; toPrimitive -&gt; valueOf -&gt; [] -&gt; toString -&gt; &#x27;&#x27;</span></span><br><span class="line">[] + &#123;&#125; <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="comment">// 空数组会经过 toPrimitive, valueOf, toString 转为空字符串</span></span><br><span class="line"><span class="comment">// 空对象会经过 toPrimitive, valueOf -&gt; &#123;&#125; -&gt; toString 转为 &#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="浮点数的精度问题"><a href="#浮点数的精度问题" class="headerlink" title="浮点数的精度问题"></a>浮点数的精度问题</h1><p>在编程的时候要慎用 <code>toFixed</code>，因为它可能会欺骗我们。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2.55</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)); <span class="comment">// 2.5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1.45</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)); <span class="comment">// 1.4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1.55</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)); <span class="comment">// 1.6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3.55</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>)); <span class="comment">// 3.5</span></span><br></pre></td></tr></table></figure><p>从上面的结果来看，规则非常模糊，上取整、下取整、四舍五入都有可能发生。造成以上结果的原因是：浮点数的存储、运算、显示这 3 个步骤都有可能不精确的！</p><ol><li>存储：0.3 不精确，0.3.toPrecision(30)，0.2.toPrecision(30)，有的数偏小，有的偏大</li><li>运算：0.3 - 0.2，因为 0.3 存储偏小，0.2 存储偏大，减法运算会将误差进一步扩大！也有可能运算将不精确缩小，甚至没有了！ 0.3+0.2 &#x3D; 0.5 </li><li>显示：会在一定误差内做近似处理</li></ol><p>浮点数的整数位数占用的位数会影响小数部分的精度，截断的时候可能少截一位导致数偏小，也有可能多一位导致数变大！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.45</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>) <span class="comment">// &#x27;2.5&#x27;</span></span><br><span class="line"><span class="number">1.45</span>.<span class="title function_">toFixed</span>(<span class="number">1</span>) <span class="comment">// &#x27;1.4&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看各自的高精度表示，toFixed(1) 会对第二位小数进行四舍五入</span></span><br><span class="line"><span class="number">2.45</span>.<span class="title function_">toPrecision</span>(<span class="number">20</span>) <span class="comment">// &#x27;2.4500000000000001776&#x27;</span></span><br><span class="line"><span class="number">1.45</span>.<span class="title function_">toPrecision</span>(<span class="number">20</span>) <span class="comment">// &#x27;1.4499999999999999556&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property">__proto__</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所有函数的 <code>__proto__</code> 都指向同一个原型对象 <code>Function.prototype</code>。<code>Object</code> 本身是一个内置的构造函数（用于创建普通对象）,作为函数，它的 <code>__proto__</code> 指向 <code>Function.prototype</code>。<code>Function</code> 也是一个构造函数,<code>Function</code>是构造所有函数的基类（包括它自身）。<code>Function.__proto__</code> 同样指向 <code>Function.prototype</code>。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/prototype-chain.png" alt="原型链示意图"></p><blockquote><p>为什么需要原型？JS 语言需要实现面向对象，而原型是面向对象的实现手段之一。一个面向对象的语言必须做到这一点：能判断一个实例的类型。在 JS 中通过原型就可以知道某个对象属于哪个类型，换句话说：<strong>原型的存在避免了类型的丢失</strong>。</p></blockquote><p>所有的数组，对象，函数（因为他们都是 w3c 中的 object 类型）都有一个<code>__proto__</code>，被称为隐式原型。所有的<strong>函数</strong>都有一个<code>prototype</code>属性，被称为显式原型。<code>prototype</code>是函数的一个属性而已，它和原型没有绝对的关系，每个对象都有一个原型，但是只有函数才会有<code>prototype</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数才有prototype属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//&gt;&gt; function()&#123;&#125;</span></span><br><span class="line"><span class="comment">//非函数，没有prototype属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property"><span class="keyword">prototype</span></span>);<span class="comment">//&gt;&gt; undefined</span></span><br></pre></td></tr></table></figure><p>每个实例对象都有一个属性<code>__proto__</code>，指向他的构造函数（constructor）的 <code>prototype</code> 属性(原型对象)，一个对象的原型就是它的构造函数的 <code>prototype</code> 属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式原型等于其构造函数上的显式原型</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><p>当一个对象的属性不存在的时候会向<strong>其构造函数的显式原型</strong>中查找（即该对象本身的隐式原型）。对象的<code>__proto__</code>也有自己的<code>__proto__</code>，层层向上，直到<code>__proto__</code>为<code>null</code>。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为原型链。因为<code>null</code>不再有原型，所以原型链的末端是<code>null</code>。</p><blockquote><p>使用<code>__proto__</code>是有争议的，也不鼓励使用它。因为它从来没有被包括在 EcmaScript 语言规范中，但是现代浏览器都实现了它。<code>__proto__</code>属性已在 ECMAScript 6 语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被不推荐使用，现在更推荐使用 <code>Object.getPrototypeOf/Reflect.getPrototypeOf</code> 和<code>Object.setPrototypeOf/Reflect.setPrototypeOf</code>（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型，应该尽量使用 <code>Object.create()</code> 来为某个对象设置原型）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj 的隐式原型是 Object.prototype</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    <span class="title function_">methodA</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;coffe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj);<span class="comment">//以obj为原型创建一个新的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。</span></span><br><span class="line">newObj.<span class="title function_">methodA</span>();<span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h2 id="面试题：说一下你对原型和原型链的理解"><a href="#面试题：说一下你对原型和原型链的理解" class="headerlink" title="面试题：说一下你对原型和原型链的理解"></a>面试题：说一下你对原型和原型链的理解</h2><p>标准答案：js 中每个对象都有其原型对象（隐式原型），通过 <code>__proto__</code> 可以找到该对象的原型对象，原型对象自己本身也有自己的原型对象，从而形成 1 条链条，这就是原型链。原型链的顶端是<code>null</code>。</p><p>加分点 1：和其他语言进行对比。<br>生成对象一般有两种：</p><ol><li>基于类创建对象：java，c++，python</li><li>基于已有对象生成对象：Self，Io，js<br>其实在 js 语言创始时候（1996），基于类创建对象是主流，但是 js 为了实现起来简单（历史原因）选择了第 2 种</li></ol><p>加分点 2：从数据结构上进行拓展。<br>原型链的本质是单链表。之所以没有采用双链表是因为我们大多数场景是需要为子类找到父类，通过父类找子类 1 方面需求几乎没有，2 来实现繁琐性能不高。</p><h2 id="创建对象的几种方法"><a href="#创建对象的几种方法" class="headerlink" title="创建对象的几种方法"></a>创建对象的几种方法</h2><ol><li>对象字面量</li><li>显式使用构造函数</li><li>Object.create</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;</span><br><span class="line"><span class="comment">// 上面的是使用对象字面量创建对象，其实是和下面的方法类似</span></span><br><span class="line"><span class="keyword">const</span> oo = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;<span class="attr">name</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> o11 = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> F = <span class="keyword">function</span> (<span class="params">name</span>) &#123;<span class="variable language_">this</span>.<span class="property">name</span> = name&#125; <span class="comment">// F.prototype.constructor === F</span></span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="title function_">F</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// o2.__proto__ === F.prototype, F.__proto__ === Function.prototype</span></span><br><span class="line"><span class="comment">// F 这个函数对象是 Function 的实例</span></span><br><span class="line"><span class="comment">// o2 instanceof F // true</span></span><br><span class="line"><span class="comment">// o2 instanceof Object // true</span></span><br><span class="line"><span class="comment">// F.prototype.__proto__ === Object.prototype // true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> P = &#123;<span class="attr">name</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> o3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(P)</span><br></pre></td></tr></table></figure><p>只有函数有 <code>prototype</code>，只有对象有<code>__proto__</code>。函数也是对象，因此它也有 <code>__proto__</code></p><h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = name &#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123; </span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">10</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让 Child 的原型对象继承 Parent 的原型对象 -&gt; Child 的实例就可以访问 Parent 的原型方法</span></span><br><span class="line"><span class="comment">// 不直接使用 `Child.prototype = Parent.prototype` 因为那样会导致修改 Child.prototype 时也影响 Parent.prototype（引用相同对象,子类添加新方法会影响父类）</span></span><br><span class="line"><span class="comment">// 不直接使用 `Child.prototype = new Parent()`，因为这样会执行 Parent 构造函数（父类的构造函数执行了 2 次），可能带来不必要的副作用（如修改全局状态）</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span> <span class="comment">// 修正 Child.prototype 的 constructor 属性(原先指向 Parent)，使其正确指向 Child 构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o) <span class="comment">// Child &#123; name: &#x27;child&#x27;, age: 10 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o <span class="keyword">instanceof</span> <span class="title class_">Parent</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o <span class="keyword">instanceof</span> <span class="title class_">Child</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">constructor</span>) <span class="comment">// [Function: Child]</span></span><br></pre></td></tr></table></figure><p>在上面的代码中 <code>Object.create(Parent.prototype)</code> 创建了一个新对象，并将这个新对象的 <code>[[Prototype]]</code>（即 <code>__proto__</code> ）指向 <code>Parent.prototype</code>。这样 <code>Child.prototype</code> 可以访问 <code>Parent.prototype</code> 的方法，但修改 <code>Child.prototype</code> 不会影响 <code>Parent.prototype</code>。执行完上述代码之后 <code>Child.prototype.__proto__ === Parent.prototype</code>。</p><p>基于这个原理，我们可以抽象出继承工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">subClass, superClass</span>) &#123;</span><br><span class="line">    <span class="comment">// 改进：添加一个空函数并将其创建的对象实例插入到原型链中，因为超类的实例可能比较大或者包含比较多的运算</span></span><br><span class="line">    <span class="keyword">const</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = superClass.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    subClass.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">    subClass.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = subClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改进引用父类的方式，从而子类中可以使用 `子类名.superClass_`得到父类的名称，比起Person.call(this, name)更具有通用性，同时有了superClass_也可以直接调用超类中的方法</span></span><br><span class="line">    subClass.<span class="property">superClass_</span> = superClass.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (superClass.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>) &#123;</span><br><span class="line">        superClass.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = superClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Author</span>(<span class="params">name, books</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">books</span> = books;</span><br><span class="line">    <span class="title class_">Author</span>.<span class="property">superClass_</span>.<span class="property">constructor</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Author</span>, <span class="title class_">Person</span>);</span><br><span class="line"><span class="title class_">Author</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getBooks</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">books</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Author</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="title class_">Author</span>.<span class="property">superClass_</span>.<span class="property">getName</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">getBooks</span>().<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="string">&#x27;村上春树&#x27;</span>, [<span class="string">&#x27;挪威的森林&#x27;</span>, <span class="string">&#x27;1Q84&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> info = a.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure><p>在 node 中可以使用 <code>util.inherits</code> 来简化继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Author</span>(<span class="params">name, books</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">books</span> = books;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Author</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getBooks</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">books</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">inherits</span>(<span class="title class_">Author</span>, <span class="title class_">Person</span>); </span><br></pre></td></tr></table></figure><p>nodejs 中实现的原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">inherits</span> = <span class="keyword">function</span>(<span class="params">ctor, superCtor</span>) &#123;</span><br><span class="line">  ctor.<span class="property">super_</span> = superCtor; <span class="comment">// 存储父类引用（方便调用父类方法）</span></span><br><span class="line">  ctor.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(superCtor.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: ctor,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断属性是否存在"><a href="#判断属性是否存在" class="headerlink" title="判断属性是否存在"></a>判断属性是否存在</h2><ol><li><code>Object.keys</code> 判断自身可枚举属性</li><li><code>Object.prototype.hasOwnProperty</code> 判断自有属性（不扫描原型链）</li><li><code>in</code> 或者 <code>Reflect.has</code> 可以判断自有属性和原型链属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可枚举属性</span></span><br><span class="line">o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(o)); <span class="comment">// 只会输出 [&#x27;a&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自有属性</span></span><br><span class="line">o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="property">a</span>, o.<span class="property">b</span>, o.<span class="property">c</span>) <span class="comment">// 1 100 200</span></span><br><span class="line"><span class="keyword">const</span> existA = o.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> existB = o.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> existC = o.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(existA, existB, existC); <span class="comment">// true, true, false</span></span><br></pre></td></tr></table></figure><h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn1</span>() <span class="comment">// 不会报错，因为函数会声明前置</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title function_">fn2</span>() <span class="comment">// 会报错，var声明前置的时候是undefined</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">function</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> ff = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">        &#125;;</span><br><span class="line">        a.<span class="title function_">push</span>(ff);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [f1, f2, f3] = <span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">f3</span>(); <span class="comment">// 这句话让闭包内的 i 增加了 1</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面会打印什么？答案是 2 和 3。这是因为闭包的另一个机制，<strong>同一个变量被引用它的多个闭包所共享</strong>。我们在<code>for</code>循环内部创建了两个函数，在循环外部创建了一个函数，这三个函数的都引用了<code>f</code>中的<code>i</code>，因而<code>i</code>被这三个函数的闭包所共享，也就是说在<code>i</code>离开自己所属的作用域时(<code>f</code>退出前)，将只会发生一次拷贝，并将新创建的三个函数的闭包中的<code>i</code>的对应的指针设定为那一份拷贝的内存地址即可。对于这一个共享的拷贝地址，除了这三个闭包之外，没有其他方式可以访问到它。</p><p>必须再次强调的是，被引用的变量拷贝到闭包中的时机发生在、被引用的变量离开自己所属的作用域时，即<strong>状态为非活动</strong>时。</p><p>考虑下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> ff = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;;</span><br><span class="line">    a.<span class="title function_">push</span>(ff);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [f1, f2] = <span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>我们知道 ES6 中引入了 let 关键字，由它声明的变量所属<strong>块级作用域</strong>。在上面的例子中，我们在 for 循环体的初始化部分使用了 let，这样一来 i 的作用域被设定为了该循环的块级作用域内。不过另一个细节是，循环体中的 i ，也就是 ff 中引用的 i，在每次迭代中都会进行重新绑定，换句话说循环体中的 i 的作用域是每一次的迭代。因此在循环体中，<strong>当每次迭代的 i 离开作用域时，它的状态变为非活动的，因此它的内容被拷贝到引用它的闭包中</strong>。</p><p>闭包常常会和 IIFE 一起使用，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  a.<span class="title function_">push</span>((<span class="keyword">function</span> (<span class="params">i</span>) &#123; <span class="comment">// f1, i1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// f2</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// i2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)); <span class="comment">// i3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [f1, f2] = a;</span><br><span class="line"><span class="title function_">f1</span>(); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">f2</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，让人迷惑的除了闭包的部分之外，就是 i1，i2 和 i3 了。</p><ul><li>i1 是 f1 的形参</li><li>i2 是 f2 中对外层作用域中的变量的引用</li><li>i3 是全局的变量 i，IIFE 执行时 i 对应的值将被作为实参来调用 f1</li><li>当 f1 被调用时，也就是 IIFE 执行阶段，它内部创建了一个新的函数 f2，同时也创建了 f2 对应的闭包</li><li>由于 f2 中引用了外层作用域中的 i，即 f1 执行期间的 i，且 i 为活动内容，所以 f2 的闭包中添加一条 Key 为 i，Value 为指向 f1 中活动的 i 绑定到的内存单元的地址</li><li>当 IIFE 执行完毕，即 f1 要退出的时候，其栈上活动对象 i 就会离开作用域，因此需要将 i 拷贝到引用它的闭包中。</li></ul><p>到目前为止，我们看到的例子都引用的直接外层作用域中的变量，那么我们再来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123; <span class="comment">// f1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123; <span class="comment">// f2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">z</span>) &#123; <span class="comment">// f3</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y + z)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xy = <span class="title function_">f</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> xyz = <span class="title function_">xy</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">xyz</span>(<span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>为了方便描述，我们分别标记了 f1，f2，f3。我们在 f3 内部，引用了 x 和 y，并且 x 并不是 f3 的直接外部作用域。那么这个闭包的构建过程时怎样的？</p><p>在 JS 中，函数也是以对象的形式存在的，如果将与函数关联的闭包想象成函数对象的一个类型为 <code>Map&lt;string, Value&gt;</code> 的属性也不过分，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">CLOSURE</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;closure&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FUN_BODY</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;fun-body&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FUN_PARAMS</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;fun-params&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> funObj = &#123;</span><br><span class="line">  [<span class="variable constant_">FUN_PARAMS</span>]: [<span class="comment">/* parameters list */</span>],</span><br><span class="line">  [<span class="variable constant_">FUN_BODY</span>]: [<span class="comment">/* instructions */</span>],</span><br><span class="line">  [<span class="variable constant_">CLOSURE</span>]: <span class="keyword">new</span> <span class="title class_">Map</span>&lt;string, <span class="title class_">Value</span>&gt;(), <span class="comment">// Value 可以被多个 closure 共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使在引擎的实现阶段，因为性能或者实现差异不采用这样的设计，但本质上与这个结构含义是一致的。为了能在运行阶段创建函数对象，在编译阶段就需要收集到必要的信息：</p><ul><li>形参列表</li><li>函数体</li><li>引用的外部变量</li></ul><p>比如在编译 f3 的阶段，我们发现它内部引用了外部的 x 和 y，由于 x 不是直接存在于父及作用域 f2 中的，为了使得未来使用 f2 创建 f3 的时候，仍能够找到 x 的绑定，我们需要将 x 加入到 f2 的闭包中。所以在编译阶段，我们会在 f2 的信息中标注它内部引用了外部变量 x。这样在创建 f2 的时候，x 就会被拷贝到它的闭包中了，等到使用它再创建 f3 的时候，f3 中的 x 也就有了着落。</p><p>最后来一个拓展练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123; x++ &#125;, </span><br><span class="line">    <span class="keyword">function</span> (<span class="params">y</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">z</span>) &#123; </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y + z)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [f1, xy] = <span class="title function_">f</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> xyz = <span class="title function_">xy</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">xyz</span>(<span class="number">3</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>闭包在实际开发中重要用于封装变量，收敛权限。</p><h2 id="什么是闭包，是否会造成内存泄漏"><a href="#什么是闭包，是否会造成内存泄漏" class="headerlink" title="什么是闭包，是否会造成内存泄漏"></a>什么是闭包，是否会造成内存泄漏</h2><p>在一个函数的环境中，闭包 &#x3D; 函数 + 外部的词法环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是闭包。即使 sub 函数是空实现并没有引用外部的变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广义上来说，上面的闭包定义是没有问题的。但是我们经常说的闭包是狭义上的，也就是下面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params"></span>)&#123;</span><br><span class="line">    a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sub</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">m</span>()</span><br><span class="line"><span class="comment">// 一般来说，函数调用完成后，其词法环境就可以销毁了。但是通过 s 可以间接访问了 m 函数的 a 变量，从而导致了 m 函数的词法环境还不能被销毁</span></span><br></pre></td></tr></table></figure><p>内存泄漏分为 2 种情况：</p><ol><li>持有了本该被销毁的函数，造成其词法环境无法被销毁</li><li>当有多个函数共享词法环境的时候可能导致词法环境膨胀，从而导致：无法访问也无法销毁的数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个例子中，bigData 是无法被访问的，但是由于 big 函数和 small 函数共享了词法环境，外部是能访问 smallData 的，导致内存泄漏</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createXXX</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> bigData = <span class="string">&#x27;x&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">1000000</span>)</span><br><span class="line">  <span class="keyword">const</span> smallData = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">big</span>(<span class="params"></span>)&#123;</span><br><span class="line">    bigData;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">small</span>(<span class="params"></span>)&#123;</span><br><span class="line">    smallData;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xxx = <span class="title function_">createXXX</span>()</span><br></pre></td></tr></table></figure><h2 id="闭包和提权漏洞"><a href="#闭包和提权漏洞" class="headerlink" title="闭包和提权漏洞"></a>闭包和提权漏洞</h2><p>首先看一道面试题：如何在不改变下面代码的情况下修改 <code>obj</code> 对象？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = ((<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">k</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))()</span><br></pre></td></tr></table></figure><p>obj 是在 o 函数的内部定义的，并且内部通过访问器对外部提供访问。我们可以在 <code>Object</code> 的原型上添加方法，返回自己本身！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj[k] 还可以返回原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;hack&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> r = o.<span class="title function_">get</span>(<span class="string">&#x27;hack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拿到 obj 对象:&#x27;</span>, r);</span><br><span class="line">r.<span class="property">a</span> = <span class="string">&#x27;hacked&#x27;</span></span><br><span class="line">r.<span class="property">hello</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">delete</span> r.<span class="property">b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>), o.<span class="title function_">get</span>(<span class="string">&#x27;b&#x27;</span>), o.<span class="title function_">get</span>(<span class="string">&#x27;hello&#x27;</span>));</span><br></pre></td></tr></table></figure><p>Node 服务器如果出现上述情况将会非常严重！可能导致一个恶意的第三方库搞花活篡改了另一个第三方库的代码，导致服务器崩溃！防御手段就是将原型置空!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = ((<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将原型置空</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">k</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))()</span><br></pre></td></tr></table></figure><p>这也就是为什么一些第三方库使用 <code>Object.create(null)</code> 来创建一个空对象，防止被篡改。</p><h1 id="实现-new-运算符"><a href="#实现-new-运算符" class="headerlink" title="实现 new 运算符"></a>实现 new 运算符</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> constr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>) <span class="comment">// 第一个参数是构造函数</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(constr.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// 创新一个新对象，该对象的原型是constr</span></span><br><span class="line">  <span class="keyword">const</span> result = constr.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>) <span class="comment">// 改变this的指向，让this指向刚才传创建的obj</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj <span class="comment">// 判断返回值是不是对象，如果是返回，如果不是返回刚才创建的新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`I am <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>,is <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// Person &#123; name: &#x27;张三&#x27;, age: 18 &#125;</span></span><br><span class="line">p.<span class="title function_">sayHello</span>() <span class="comment">// I am 张三,is 18 years old!</span></span><br></pre></td></tr></table></figure><p>注意 <code>myNew</code> 函数的第 5 行，是为了兼容以下这种情况 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现-call-函数"><a href="#实现-call-函数" class="headerlink" title="实现 call 函数"></a>实现 call 函数</h1><p>思路：</p><ol><li>参考 call 的语法规则，需要设置一个参数 thisArg ，也就是 this 的指向；</li><li>将 thisArg 封装为一个 Object；</li><li>通过为 thisArg 创建一个临时方法，这样 thisArg 就是调用该临时方法的对象了，会将该临时方法的 this 隐式指向到 thisArg 上</li><li>执行 thisArg 的临时方法，并传递参数；</li><li>删除临时方法，返回方法的执行结果。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用原生JavaScript实现call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...arr</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.判断参数合法性</span></span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">null</span> || thisArg === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">//指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)</span></span><br><span class="line">    thisArg = <span class="variable language_">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当以非构造函数形式被调用时，Object 等同于 new Object()。</span></span><br><span class="line">    thisArg = <span class="title class_">Object</span>(thisArg);<span class="comment">//创建一个可包含数字/字符串/布尔值的对象，</span></span><br><span class="line">                              <span class="comment">//thisArg 会指向一个包含该原始值的对象。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.搞定this的指向</span></span><br><span class="line">  <span class="keyword">const</span> specialMethod = <span class="title class_">Symbol</span>(<span class="string">&quot;anything&quot;</span>); <span class="comment">//创建一个不重复的常量</span></span><br><span class="line">  <span class="comment">//如果调用myCall的函数名是func，也即以func.myCall()形式调用；</span></span><br><span class="line">  <span class="comment">//根据上篇文章介绍，则myCall函数体内的this指向func</span></span><br><span class="line">  thisArg[specialMethod] = <span class="variable language_">this</span>; <span class="comment">//给thisArg对象建一个临时属性来储存this（也即func函数）</span></span><br><span class="line">  <span class="comment">//进一步地，根据上篇文章介绍，func作为thisArg对象的一个方法被调用，那么func中的this便</span></span><br><span class="line">  <span class="comment">//指向thisArg对象。由此，巧妙地完成将this隐式地指向到thisArg！</span></span><br><span class="line">  <span class="keyword">let</span> result = thisArg[specialMethod](...arr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.收尾</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[specialMethod]; <span class="comment">//删除临时方法</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">//返回临时方法的执行结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coffe1891&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.<span class="title function_">myCall</span>(obj);<span class="comment">//&gt;&gt; coffe1891</span></span><br></pre></td></tr></table></figure><h1 id="实现-apply-函数"><a href="#实现-apply-函数" class="headerlink" title="实现 apply 函数"></a>实现 apply 函数</h1><ol><li>传递给函数的参数处理，不太一样，其他部分跟 call 一样；</li><li>apply接受第二个参数为类数组对象, 这里用了《JavaScript权威指南》一书中判断是否为类数组对象的方法。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用原生JavaScript实现apply</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">null</span> || thisArg === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    thisArg = <span class="variable language_">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    thisArg = <span class="title class_">Object</span>(thisArg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否为【类数组对象】</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isArrayLike</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      o &amp;&amp; <span class="comment">// o不是null、undefined等</span></span><br><span class="line">      <span class="keyword">typeof</span> o === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="comment">// o是对象</span></span><br><span class="line">      <span class="built_in">isFinite</span>(o.<span class="property">length</span>) &amp;&amp; <span class="comment">// o.length是有限数值</span></span><br><span class="line">      o.<span class="property">length</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// o.length为非负值</span></span><br><span class="line">      o.<span class="property">length</span> === <span class="title class_">Math</span>.<span class="title function_">floor</span>(o.<span class="property">length</span>) &amp;&amp; <span class="comment">// o.length是整数</span></span><br><span class="line">      o.<span class="property">length</span> &lt; <span class="number">4294967296</span></span><br><span class="line">    )</span><br><span class="line">      <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> specialMethod = <span class="title class_">Symbol</span>(<span class="string">&quot;anything&quot;</span>);</span><br><span class="line">  thisArg[specialMethod] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = <span class="variable language_">arguments</span>[<span class="number">1</span>]; <span class="comment">// 获取参数数组</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理传进来的第二个参数</span></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    <span class="comment">// 是否传递第二个参数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(args) &amp;&amp; !<span class="title function_">isArrayLike</span>(args)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">        <span class="string">&quot;第二个参数既不为数组，也不为类数组对象。抛出错误&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args = <span class="title class_">Array</span>.<span class="title function_">from</span>(args); <span class="comment">// 转为数组</span></span><br><span class="line">      result = thisArg[specialMethod](...args); <span class="comment">// 执行函数并展开数组，传递函数参数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = thisArg[specialMethod]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> thisArg[specialMethod];</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实现-bind-函数"><a href="#实现-bind-函数" class="headerlink" title="实现 bind 函数"></a>实现 bind 函数</h1><p>区别于 call 和 apply，bind 不会立即执行函数，而是返回一个绑定了 this 的新函数。bind 可以预先传递部分参数（柯里化）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用原生JavaScript实现bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">objThis, ...params</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> thisFn = <span class="variable language_">this</span>;<span class="comment">//存储调用函数，以及上方的params(函数参数)</span></span><br><span class="line">  <span class="comment">//对返回的函数 secondParams 二次传参</span></span><br><span class="line">  <span class="keyword">let</span> funcForBind = <span class="keyword">function</span>(<span class="params">...secondParams</span>) &#123;</span><br><span class="line">    <span class="comment">//检查this是否是funcForBind的实例？也就是检查funcForBind是否通过new调用</span></span><br><span class="line">    <span class="keyword">const</span> isNew = <span class="variable language_">this</span> <span class="keyword">instanceof</span> funcForBind;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//new调用就绑定到this上,否则就绑定到传入的objThis上</span></span><br><span class="line">    <span class="keyword">const</span> thisArg = isNew ? <span class="variable language_">this</span> : <span class="title class_">Object</span>(objThis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用call执行调用函数，绑定this的指向，并传递参数。返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> thisFn.<span class="title function_">call</span>(thisArg, ...params, ...secondParams);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复制调用函数的prototype给funcForBind</span></span><br><span class="line">  funcForBind.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(thisFn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">return</span> funcForBind;<span class="comment">//返回拷贝的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">p,secondParams</span>)&#123;<span class="comment">//其实测试用的func其参数可以是任意多个</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(secondParams);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;1891&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">func.<span class="title function_">myBind</span>(obj,&#123;<span class="attr">name</span>:<span class="string">&quot;coffe&quot;</span>&#125;)(<span class="string">&quot;二次传参&quot;</span>);</span><br><span class="line"><span class="comment">//&gt;&gt; coffe</span></span><br><span class="line"><span class="comment">//&gt;&gt; 1891</span></span><br><span class="line"><span class="comment">//&gt;&gt; 二次传参</span></span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>currying 又称为<em>部分求值</em>。一个 currying 函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另一个函数，刚才转入的参数在函数形成的闭包中被保存起来。待到函数被真正求值的时候，之前传入的参数都会被一次性用于求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    [].<span class="property">push</span>.<span class="title function_">apply</span>(args, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">callee</span>; <span class="comment">// 返回正在执行的函数本身</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cost = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      money += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">cost = <span class="title function_">currying</span>(cost);</span><br><span class="line"></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">100</span>); <span class="comment">// 未真正求值</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">200</span>); <span class="comment">// 未真正求值</span></span><br><span class="line"><span class="title function_">cost</span>(<span class="number">300</span>); <span class="comment">// 未真正求值</span></span><br><span class="line"><span class="keyword">const</span> r = <span class="title function_">cost</span>(); <span class="comment">// 此时才求值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cost:&#x27;</span>, r);</span><br></pre></td></tr></table></figure><h1 id="实现函数重载"><a href="#实现函数重载" class="headerlink" title="实现函数重载"></a>实现函数重载</h1><p>重载是面向对象编程语言（比如Java、C#）里的特性，JavaScript语言并不支持该特性。所谓重载(overload)，就是函数名称一样，但是随着传入的参数个数不一样，调用的逻辑或返回的结果会不一样。jQuery之父John Resig曾经提供了一个非常巧妙的思路实现重载，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;<span class="comment">//IIFE+箭头函数，把要写的代码包起来，避免影响外界，这是个好习惯</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当函数成为对象的一个属性的时候，可以称之为该对象的方法。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125;  一个对象，以便接下来给这个对象添加重载的函数(方法)</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">name</span>&#125;    object被重载的函数(方法)名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">fn</span>&#125;      被添加进object参与重载的函数逻辑</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">overload</span>(<span class="params">object, name, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> oldMethod = object[name];<span class="comment">//存放旧函数，本办法灵魂所在，将多个fn串联起来</span></span><br><span class="line">    object[name] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// fn.length为fn定义时的参数个数,arguments.length为重载方法被&quot;调用&quot;时的参数个数</span></span><br><span class="line">      <span class="keyword">if</span> (fn.<span class="property">length</span> === <span class="variable language_">arguments</span>.<span class="property">length</span>) &#123;<span class="comment">//若参数个数匹配上</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);<span class="comment">//就调用指定的函数fn</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldMethod === <span class="string">&quot;function&quot;</span>) &#123;<span class="comment">//若参数个数不匹配</span></span><br><span class="line">        <span class="keyword">return</span> oldMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);<span class="comment">//就调旧函数</span></span><br><span class="line">                                                <span class="comment">//注意：当多次调用overload()时，旧函数中</span></span><br><span class="line">                                                <span class="comment">//又有旧函数,层层嵌套,递归地执行if..else</span></span><br><span class="line">                                                <span class="comment">//判断,直到找到参数个数匹配的fn</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不传参数时</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn0</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;no param&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传1个参数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">param1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;1 param:&quot;</span> + param1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传两个参数时，返回param1和param2都匹配的name</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">param1, param2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;2 param:&quot;</span> + [param1, param2];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;<span class="comment">//定义一个对象，以便接下来给它的方法进行重载</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">overload</span>(obj, <span class="string">&quot;fn&quot;</span>, fn0);<span class="comment">//给obj添加第1个重载的函数</span></span><br><span class="line">  <span class="title function_">overload</span>(obj, <span class="string">&quot;fn&quot;</span>, fn1);<span class="comment">//给obj添加第2个重载的函数</span></span><br><span class="line">  <span class="title function_">overload</span>(obj, <span class="string">&quot;fn&quot;</span>, fn2);<span class="comment">//给obj添加第3个重载的函数</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">fn</span>());<span class="comment">//&gt;&gt; no param</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">fn</span>(<span class="number">1</span>));<span class="comment">//&gt;&gt; 1 param:1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//&gt;&gt; 2 param:1,2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>每次调用 overload 时，新函数会捕获 oldMethod（即之前的函数），形成闭包。多次调用 overload 添加不同的函数时，会形成一个链式结构，逐层检查参数个数。</p><h1 id="Promise相关"><a href="#Promise相关" class="headerlink" title="Promise相关"></a>Promise相关</h1><h2 id="怎样控制-Promise-的并发"><a href="#怎样控制-Promise-的并发" class="headerlink" title="怎样控制 Promise 的并发"></a>怎样控制 Promise 的并发</h2><p><code>Promise.all</code>可以让<code>Promise</code>并发执行，但是这些Promise是<strong>创建的时候就开始执行了</strong>，所有数组中的<code>Promise</code>可以理解为同时执行，如何限制并发执行的个数呢？只能从<code>Promise</code>创建的时候开始考虑了。维护一个正在执行的<code>Promise</code>的队列记为<code>executing</code>,并发数记为<code>poolLimit</code>，当正在执行的<code>Promise</code>数量大于等于<code>poolLimit</code>就需要等待<code>executing</code>中<strong>一个</strong><code>Promise</code>执行完腾出位置了，<strong>Promise.race</strong>提供了这样一组api：接收一个<code>Promise</code>数组，当第一个<code>Promise</code>执行完的时候，整个<code>Promise.race</code>执行结束。我们正好可以利用这个特性，<strong>及时</strong>腾出位置加入其它的<code>Promise</code>到<code>executing</code>中!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asyncPool</span>(<span class="params">poolLimit, array, iteratorFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> ret = [];</span><br><span class="line">  <span class="keyword">const</span> executing = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  <span class="keyword">const</span> enqueue = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">    <span class="keyword">if</span> (i === array.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每调一次enqueue，初始化一个promise(使用Promise.resolve.then包装一下，这样返回的都是promise了)</span></span><br><span class="line">    <span class="keyword">const</span> item = array[i++];</span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">iteratorFn</span>(item, array));</span><br><span class="line">    <span class="comment">// 放入promises数组</span></span><br><span class="line">    ret.<span class="title function_">push</span>(p);</span><br><span class="line">    executing.<span class="title function_">add</span>(p);</span><br><span class="line">    <span class="comment">// promise执行完成后，从执行队列中删除</span></span><br><span class="line">    p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      executing.<span class="title function_">delete</span>(p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Promise.race，每当executing队列中promise数量低于poolLimit，就实例化新的promise并执行</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">    <span class="keyword">if</span> (executing.<span class="property">size</span> &gt;= poolLimit) &#123;</span><br><span class="line">      r = <span class="title class_">Promise</span>.<span class="title function_">race</span>(executing);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">    <span class="keyword">return</span> r.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">enqueue</span>());</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">enqueue</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(ret));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">timeout</span> = i =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(i), i));</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">asyncPool</span>(<span class="number">2</span>, [<span class="number">1000</span>, <span class="number">5000</span>, <span class="number">3000</span>, <span class="number">2000</span>], timeout).<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 8 Sep 17:20:07 - start</span></span><br><span class="line"><span class="comment">// 8 Sep 17:20:13 - [ 1000, 5000, 3000, 2000 ]</span></span><br></pre></td></tr></table></figure><p>其实所谓的 Promise 并发控制，就是<strong>控制Promise实例化的个数</strong>。然而这样的实现效果本质上来说已经摈弃了<code>Promise.all</code>，期待标准库中可以提供这个功能。</p><h2 id="如何取消-Promise"><a href="#如何取消-Promise" class="headerlink" title="如何取消 Promise"></a>如何取消 Promise</h2><p>Promise 一旦创建是不能取消的，我们只能对其进行包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">makeCancelable</span> = (<span class="params">promise</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> hasCanceled_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> wrappedPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promise.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span></span><br><span class="line">      hasCanceled_ ? <span class="title function_">reject</span>(&#123;<span class="attr">isCanceled</span>: <span class="literal">true</span>&#125;) : <span class="title function_">resolve</span>(val)</span><br><span class="line">    );</span><br><span class="line">    promise.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span></span><br><span class="line">      hasCanceled_ ? <span class="title function_">reject</span>(&#123;<span class="attr">isCanceled</span>: <span class="literal">true</span>&#125;) : <span class="title function_">reject</span>(error)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">promise</span>: wrappedPromise,</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">      hasCanceled_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> somePromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, <span class="number">1000</span>));<span class="comment">//创建一个异步操作</span></span><br><span class="line"><span class="keyword">const</span> cancelable = <span class="title function_">makeCancelable</span>(somePromise);<span class="comment">//为异步操作添加可取消的功能</span></span><br><span class="line">cancelable</span><br><span class="line">  .<span class="property">promise</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">&#123;isCanceled, ...error&#125;</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isCanceled&#x27;</span>, isCanceled));</span><br><span class="line"><span class="comment">// 取消异步操作</span></span><br><span class="line">cancelable.<span class="title function_">cancel</span>();</span><br></pre></td></tr></table></figure><p>出处：<a href="https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/React%20Native%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/React%20Native%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C</a></p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><p>不要混用同步和异步，容易给 debug 造成比较大的困惑，下面的代码是反面教材：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">fileName, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, cache[filename])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileName, <span class="function">(<span class="params">err, fileContent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line"></span><br><span class="line">    cache[fileName] = fileContent;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, fileContent);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOOD</span></span><br><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">fileName, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache[filename]) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>(<span class="literal">null</span>, cache[filename]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileName, <span class="function">(<span class="params">err, fileContent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line"></span><br><span class="line">    cache[fileName] = fileContent;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, fileContent);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="node-js-相关"><a href="#node-js-相关" class="headerlink" title="node.js 相关"></a>node.js 相关</h1><h2 id="nodejs中的global对象什么时候初始化"><a href="#nodejs中的global对象什么时候初始化" class="headerlink" title="nodejs中的global对象什么时候初始化"></a>nodejs中的global对象什么时候初始化</h2><p>global对象在src&#x2F;node.cc中的被创建，在bootstrap&#x2F;node.js中被初始化。在src&#x2F;node.cc的LoadEnvironment方法中，有以下几行代码是用来创建global对象的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a reference to the global object</span></span><br><span class="line">Local&lt;Object&gt; global = env-&gt;<span class="built_in">context</span>()-&gt;<span class="built_in">Global</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose the global object as a property on itself</span></span><br><span class="line"><span class="comment">// (Allows you to set stuff on `global` from anywhere in JavaScript.)</span></span><br><span class="line">global-&gt;<span class="built_in">Set</span>(<span class="built_in">FIXED_ONE_BYTE_STRING</span>(env-&gt;<span class="built_in">isolate</span>(), <span class="string">&quot;global&quot;</span>), global);</span><br></pre></td></tr></table></figure><p>其中env-&gt;context()-&gt;Global()获取了当前context中的Global全局对象，global-&gt;Set(FIXED_ONE_BYTE_STRING(env-&gt;isolate(), “global”), global)将全局对象本身挂载在其global对象上，这样全局对象中有了一个global对象指向了全局对象本身，我们在该context中可以直接使用global对全局对象的引用进行访问。以上程序之后，这样我们就可以在context的任何地方对全局对象进行操作。</p><p>初始化在bootstrap&#x2F;node.js中的setupGlobalVariables进行，其在上述逻辑执行后被执行，所以可以直接操作全局对象。这个函数中将process、Buffer直接放在global对象上，因此我们可以直接访问这些全局对象了。进一步地，setTimeout等定时器通过setupGlobalTimeouts方法放在global上。</p><h2 id="为什么cluster开启多个worker的时候可以监听同一个端口不会报错"><a href="#为什么cluster开启多个worker的时候可以监听同一个端口不会报错" class="headerlink" title="为什么cluster开启多个worker的时候可以监听同一个端口不会报错"></a>为什么cluster开启多个worker的时候可以监听同一个端口不会报错</h2><p>master进程内部启动了一个TCP服务器，真正监听端口的只有这个服务器，当来自前端的请求触发服务器的connection事件后，master会将对应的socket句柄发送给worker子进程。cluster内部的负载均衡均衡算法是Round-robin。master进程监听端口，将请求分发给下面的worker进程。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>参考<a href="https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810">国外大神写的一系列文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(foo, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure><p>上面的代码为什么不会导致栈溢出？</p><p>因为我们是把函数放在一个<em>异步</em>的环境中了，foo 将一个函数通知给了计时线程后就不管了，foo 函数就执行完了，其执行栈就被清空了！计时线程等时间到了之后将 foo 加入事件队列，取出来执行，执行的过程和第一次执行一模一样！</p><h3 id="怎么实现一个精准的-setInterval"><a href="#怎么实现一个精准的-setInterval" class="headerlink" title="怎么实现一个精准的 setInterval"></a>怎么实现一个精准的 setInterval</h3><p>首先要明白为什么不精准？</p><ol><li>事件循环影响回调的执行时机</li><li>嵌套 5 层以上有最小 4ms 的限制</li><li>失活页面间隔会被强制调整到 1s</li></ol><p>解决方案：</p><ol><li>每次回调的时候重新调整时间偏差，Date.now, perfermance.now</li><li>requestAnimationFrame 不受页面失活影响，但是其他因素影响（os 本身的忙碌程度，正在玩游戏）</li><li>web worker：运行在后台线程中，不受主线程事件循环的影响，但是封装费事</li></ol><h2 id="CommonJS-和-ESM-的区别是什么"><a href="#CommonJS-和-ESM-的区别是什么" class="headerlink" title="CommonJS 和 ESM 的区别是什么"></a>CommonJS 和 ESM 的区别是什么</h2><p>从标准来源上说：CJS 是 node 社区标准，定义了一个 require 函数，一个全局可用的 module 对象，上面有一个 exports 属性；ESM 是官方标准，是新增的语法。<br>从时态上面来说：CJS 是运行时确定依赖关系，ESM 同时支持编译时（静态）和运行时(<code>import()</code>语法)。</p><p>因此 <code>import a from 变量</code> 这种写法在 ESM 中会直接语法报错，在函数中使用 <code>import</code> 关键字也是错误的！</p><p>静态导入带来了非常多的好处，最显著的就是不用等到运行时就能确定依赖关系。前端技术中常见的树摇优化（Tree Sharking）就使用了静态分析依赖关系从而移除不必要的导入来减少了代码体积。</p><h1 id="一些场景设计题"><a href="#一些场景设计题" class="headerlink" title="一些场景设计题"></a>一些场景设计题</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNzk1MjQ0Ng==&mid=2247483725&idx=1&sn=bde0ecb991c7b3f43cf2ac1a51ff2719&chksm=f991079ccee68e8addc32955997acef2119cb064ea9dc8ce172f1cc9985c8febd54abc904504&scene=21#wechat_redirect">一道面试题引发的事件循环深入思考</a></li><li><a href="https://developer.aliyun.com/article/592878">解读V8 gc log</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试套路 — Linux</title>
      <link href="/2020/05/12/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-Linux/"/>
      <url>/2020/05/12/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-Linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>弱小和无知不是生存的障碍，傲慢才是。</p></blockquote><blockquote><p>SHELL 所能支持的最大字符串的长度是 1024 字符。</p></blockquote><h1 id="删除文件是否需要对该文件具有写权限，为什么？"><a href="#删除文件是否需要对该文件具有写权限，为什么？" class="headerlink" title="删除文件是否需要对该文件具有写权限，为什么？"></a>删除文件是否需要对该文件具有写权限，为什么？</h1><p>删除文件<strong>不需要该文件的写权限</strong>，需要文件所在<strong>目录的写权限以及执行权限</strong>。因为删除文件修改的该文件父级即其所在目录的内容，所以需要目录的写权限。 同时，删除文件先要进入到目录，进入是目录的一个操作，所以需要该目录的执行操作。</p><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>每次打开文件都会返回一个新的文件描述符，即使是针对的同一个文件，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fd = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">openSync</span>(<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中每次都打开根目录（注意linux中的文件是泛指），最后肯定会由于打开的文件描述符(使用<code>ulimit -n</code>)过多而报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Error</span>: <span class="attr">ENFILE</span>: file table overflow, open <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    at <span class="title class_">Object</span>.<span class="property">openSync</span> (fs.<span class="property">js</span>:<span class="number">447</span>:<span class="number">3</span>)</span><br><span class="line">    at <span class="title class_">Object</span>.&lt;anonymous&gt; (<span class="regexp">/Users/</span>node-test/tests/fs.<span class="property">js</span>:<span class="number">2</span>:<span class="number">30</span>)</span><br><span class="line">    at <span class="title class_">Module</span>.<span class="property">_compile</span> (internal/modules/cjs/loader.<span class="property">js</span>:<span class="number">777</span>:<span class="number">30</span>)</span><br><span class="line">    at <span class="title class_">Object</span>.<span class="property">Module</span>.<span class="property">_extensions</span>..<span class="property">js</span> (internal/modules/cjs/loader.<span class="property">js</span>:<span class="number">788</span>:<span class="number">10</span>)</span><br><span class="line">    at <span class="title class_">Module</span>.<span class="property">load</span> (internal/modules/cjs/loader.<span class="property">js</span>:<span class="number">643</span>:<span class="number">32</span>)</span><br><span class="line">    at <span class="title class_">Function</span>.<span class="property">Module</span>.<span class="property">_load</span> (internal/modules/cjs/loader.<span class="property">js</span>:<span class="number">556</span>:<span class="number">12</span>)</span><br><span class="line">    at <span class="title class_">Function</span>.<span class="property">Module</span>.<span class="property">runMain</span> (internal/modules/cjs/loader.<span class="property">js</span>:<span class="number">840</span>:<span class="number">10</span>)</span><br><span class="line">    at internal/main/run_main_module.<span class="property">js</span>:<span class="number">17</span>:<span class="number">11</span> &#123;</span><br><span class="line">  <span class="attr">errno</span>: -<span class="number">23</span>,</span><br><span class="line">  <span class="attr">syscall</span>: <span class="string">&#x27;open&#x27;</span>,</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;ENFILE&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><blockquote><p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p></blockquote><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。查看每个硬盘分区的inode总数和已经使用的数量，可以使用<code>df</code>命令。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6644b470-ee6f-11e9-b73d-6f36e477271f.png" alt="image.png"></p><p>由于每个文件都必须有一个inode，因此有可能发生<a href="https://blog.csdn.net/fdipzone/article/details/41558685">inode已经用光，但是硬盘还未存满</a>的情况。这时，就无法在硬盘上创建新文件。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix&#x2F;Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2290f070-ee71-11e9-b73d-6f36e477271f.png" alt="image.png"></p><p>当inode节点中的链接数减为0的时候表示没有任何文件名指向这个inode，系统就会<strong>回收这个inode号码</strong>，以及所对应的block区域。</p><p>需要注意的是：inode是唯一的这句话是说：绝对路径到inode号的映射在<strong>同一时刻是唯一的</strong>。因为当指向inode号没有任何文件指向的时候，它就会被系统回收，这个inode可能被重新分配给新创建的文件。唯一的概念并不是uuid的概念。</p><h3 id="硬链接-1"><a href="#硬链接-1" class="headerlink" title="硬链接"></a>硬链接</h3><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接 “（symbolic link）。这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/29bdae50-ee72-11e9-b73d-6f36e477271f.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>由于inode号码与文件名分离，这种机制导致了一些Unix&#x2F;Linux系统特有的现象。</p><ol><li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li><li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li><li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li></ol><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><p>参考：<a href="http://www.361way.com/rm-file-use-inode/4187.html">使用inode删除文件</a></p><blockquote><p>这个世界是有捷径可走的，但是从不属于那些傲慢的人。</p></blockquote><h1 id="linux中的nobody用户有什么用"><a href="#linux中的nobody用户有什么用" class="headerlink" title="linux中的nobody用户有什么用"></a>linux中的nobody用户有什么用</h1><p>nobody在linux中是一个不能登陆的帐号，一些服务进程如apache，aquid等都采用一些特殊的帐号来运行，比如nobody,news,games等等，这是就可以防止程序本身有安全问题的时候，不会被黑客获得root权限。它们是用来完成特定任务的，比如nobody和ftp等，我们访问 <a href="http://www.111cn.net的网页程序时,官网的服务器就是让客户以/">www.111cn.net的网页程序时，官网的服务器就是让客户以</a> nobody 身份登录的(相当于Windows系统中的匿名帐户);我们匿名访问ftp时，会用到用户ftp或nobody。nobody是一个普通用户，非特权用户。 使用nobody用户名的’目的’是，使任何人都可以登录系统，但是其 UID 和 GID 不提供任何特权，即该uid和gid只能访问人人皆可读写的文件。其次，许多系统中都按惯例地默认创建一个nobody，尽量’限制它的权限至最小’，当服务器向外服务时，可能会让client以nobody的身份登录。nobody就是一个普通账户，因为默认登录shell是<code>/sbin/nologin</code>，所以这个用户是无法直接登录系统的，也就是黑客很难通过漏洞连接到你的服务器来做破坏。此外这个用户的权限也给配置的很低。因此有比较高的安全性。一切都只给最低权限。这就是nobody存在的意义。</p><h1 id="grep妙用"><a href="#grep妙用" class="headerlink" title="grep妙用"></a>grep妙用</h1><p>可以用于过滤配置文件中的注释和空行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> redis.conf | grep -v <span class="string">&quot;#&quot;</span> | grep -v <span class="string">&quot;^$&quot;</span></span><br></pre></td></tr></table></figure><h1 id="tee-命令"><a href="#tee-命令" class="headerlink" title="tee 命令"></a>tee 命令</h1><blockquote><p>注意：uniq命令只是对相邻两行进行去重，所以要先使用sort进行排序之后再uniq</p></blockquote><p>一个不是很常用，但是我觉得蛮有用的一个命令。可以将标准输入的内容输出到文件。例如一个常用的统计命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat randdata | awk &#x27;&#123;print $2&#125;&#x27; | sort | uniq -c 这条命令的结果会同时输出到标准输出和sortdata文件</span></span><br><span class="line"><span class="built_in">cat</span> randdata | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">tee</span> sortdata</span><br></pre></td></tr></table></figure><p>下面的一个例子展示了将用户输入内容输出到2个文件：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/32de43b3-4b5d-45e6-80af-59d17c9aceff.png" alt="tee命令"></p><h1 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a>nc命令</h1><p>这个命令非常容易开启一个网络测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在8888端口启动一个TCP监听</span></span><br><span class="line">nc -lk 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外启动一个终端将文件内容发送到8888端口</span></span><br><span class="line">nc 127.0.0.1 8888 &lt; a.txt</span><br></pre></td></tr></table></figure><p>可以非常方便向特定端口发送内容,也可以非常方便实现echo功能。</p><h1 id="yes命令"><a href="#yes命令" class="headerlink" title="yes命令"></a>yes命令</h1><p>该命令可以向终端不断输出字符串，常用于测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">yes</span> <span class="string">&quot;&lt;44&gt;May 19 18:30:17 snack jls: foo bar 32&quot;</span> | nc localhost 3000</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些想读的书</title>
      <link href="/2020/05/09/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6/"/>
      <url>/2020/05/09/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>软件具有<strong>熵</strong>的特质，长期迭代维护的项目总会遇到可维护性逐渐降低的问题。</p></blockquote><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><ul><li><input checked="" disabled="" type="checkbox"> 《码农翻身》</li><li><input checked="" disabled="" type="checkbox"> 《编码》</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li><input disabled="" type="checkbox"> 《算法新解》</li><li><input disabled="" type="checkbox"> 《计算机程序的构造和解释》</li><li><input disabled="" type="checkbox"> 《我的第一本算法书》</li><li><input disabled="" type="checkbox"> 《算法图解》</li><li><input disabled="" type="checkbox"> 《素数之恋》</li><li><input disabled="" type="checkbox"> 《啊哈·灵机一动》</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ul><li><input checked="" disabled="" type="checkbox"> 《图解 TCP&#x2F;IP》</li><li><input checked="" disabled="" type="checkbox"> 《图解 HTTP》 @2025-05-21</li><li><input disabled="" type="checkbox"> 《http 权威指南》</li></ul><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://book.douban.com/subject/25900156/">《Redis设计与实现》</a> @2025-04-20</li><li><input checked="" disabled="" type="checkbox"> <a href="https://book.douban.com/subject/26937390/">《Node.js硬实战：115个核心技巧》</a> @2025-06-19</li><li><input checked="" disabled="" type="checkbox"> <a href="https://book.douban.com/subject/26382780/">《JavaScript设计模式与开发实践》</a> @2025-06-28</li></ul><h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><ul><li><input disabled="" type="checkbox"> <a href="https://book.douban.com/subject/27605366/">《前端工程化：体系设计与实践》</a></li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><ul><li><input disabled="" type="checkbox"> <a href="https://book.douban.com/subject/30335935/">《从零开始学架构》</a></li><li><input disabled="" type="checkbox"> 《大型网站性能优化实践》</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.thebyte.com.cn/">《深入高可用系统原理与设计》</a> @2025-04-06</li><li><input checked="" disabled="" type="checkbox"> 《重构 - 改善既有代码的设计》 @2025-05-25</li><li><input disabled="" type="checkbox"> 《修改代码的艺术》</li></ul><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><ul><li><input disabled="" type="checkbox"> 《硅谷产品-36讲直通世界级产品经理》</li><li><input disabled="" type="checkbox"> 《用数据讲故事》</li><li><input disabled="" type="checkbox"> 《硬战-人工智能时代的爆款产品》</li><li><input disabled="" type="checkbox"> 《人人都是产品经理 2.0》</li><li><input disabled="" type="checkbox"> 《阿里巴巴四十大道》</li><li><input disabled="" type="checkbox"> 《吴军的谷歌方法论》</li><li><input disabled="" type="checkbox"> 《见识》吴军</li></ul><h1 id="管理学"><a href="#管理学" class="headerlink" title="管理学"></a>管理学</h1><ul><li><input disabled="" type="checkbox"> 《一个世纪的发明 —— 3M 的故事》</li><li><input disabled="" type="checkbox"> 《韦尔奇自传》</li></ul><h1 id="科幻"><a href="#科幻" class="headerlink" title="科幻"></a>科幻</h1><ul><li><input disabled="" type="checkbox"> 《人工智能简史》</li><li><input disabled="" type="checkbox"> 《人类群星闪耀时》</li></ul><h1 id="文学"><a href="#文学" class="headerlink" title="文学"></a>文学</h1><ul><li><input disabled="" type="checkbox"> 《天浴》</li><li><input disabled="" type="checkbox"> 《房思琪的初恋乐园》</li><li><input disabled="" type="checkbox"> 《过劳时代》</li><li><input disabled="" type="checkbox"> 《生命3.0》</li></ul><h1 id="经济学"><a href="#经济学" class="headerlink" title="经济学"></a>经济学</h1><ul><li><input disabled="" type="checkbox"> 《无节制消费的元凶》</li><li><input disabled="" type="checkbox"> 《超级顾客》</li><li><input disabled="" type="checkbox"> 《英国人的消费秘密》</li><li><input disabled="" type="checkbox"> 《金钱与我》</li><li><input disabled="" type="checkbox"> 《隐性亿万富翁》</li><li><input disabled="" type="checkbox"> 《致富之道》</li><li><input disabled="" type="checkbox"> 《亿万富翁们的饕餮盛宴》</li><li><input disabled="" type="checkbox"> 《经济机器是如何运行的》</li><li><input disabled="" type="checkbox"> 《聪明的投资者》</li><li><input disabled="" type="checkbox"> 《漫步华尔街》</li><li><input disabled="" type="checkbox"> 《工作、消费主义和新穷人》</li></ul><blockquote><p>罐头是 1810 发明出来的，可是开罐器呢，却在 1858 年才发明出来。有时就是这样，重要的东西可能迟来一步，但却一定会到。生活和爱情，都是如此。程序，当然也不例外。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你真的会二分查找么</title>
      <link href="/2020/04/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%88/"/>
      <url>/2020/04/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>这几天刷LeetCode中二分查找相关的题目，思想总是没什么问题，总是被各种边界条件折磨地死去活来，提交1次错一次，完全是面向测试编程，好不容易把下标调整对了，可是当下次遇到这个题目的时候还是需要从头再错一边😿。我们先来看一下最朴素的二分查找，看看存在怎样的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">arr, target</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span>, r = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">const</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> num = arr[mid];</span><br><span class="line">    <span class="keyword">if</span> (target === num) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; num) &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为啥是l &#x3D; mid + 1,r &#x3D;  mid - 1，而不是l &#x3D; mid,r &#x3D; mid。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 中的位运算</title>
      <link href="/2020/04/28/LeetCode%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/04/28/LeetCode%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="No136只出现1次的数字"><a href="#No136只出现1次的数字" class="headerlink" title="No136只出现1次的数字"></a>No136只出现1次的数字</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/10e25ec0-8919-11ea-a4ce-5fa96f96177c.png" alt="image.png"></p><h2 id="使用计数器"><a href="#使用计数器" class="headerlink" title="使用计数器"></a>使用计数器</h2><p>比较朴素的解法是对每个元素进行计数，最后统计出数量为1的那个数，这种算法比较通用，可以解决任意多元素出现任意次，因为可以解决的问题比较多，所以往往不是最好的算法，需要维护一个HashMap，占用O(N)的空间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = counter.<span class="title function_">get</span>(num) || <span class="number">0</span>;</span><br><span class="line">    counter.<span class="title function_">set</span>(num, ++count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用Set"><a href="#使用Set" class="headerlink" title="使用Set"></a>使用Set</h2><p>事实上我们也不需要真的用HashMap维护一下元素的数量，因为题目提高只有一个元素只有1个，别的元素都有两个，可以使用Set来巧妙处理：当第一次需要该数字的时候将其放进set，第二次遇到的时候将其移除，这样下来set中保存的就是只出现1次的数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            set.<span class="title function_">delete</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.<span class="title function_">add</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...set][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用数学计算"><a href="#使用数学计算" class="headerlink" title="使用数学计算"></a>使用数学计算</h2><p>其基本数学公式是：2*(a+b+c) - (a  + a + b + b + c) &#x3D; c,我们只需要对原数组去重后求和乘以2再减去原来数组的和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 数学法:2*(a+b+c) - (a  + a + b + b + c)  = c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="title function_">sum</span>([...<span class="keyword">new</span> <span class="title class_">Set</span>(nums)]) - <span class="title function_">sum</span>(nums);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h2><p>这是这道题效率最高也是最让人惊艳的解法，它基于这样一个事实:a ^ a &#x3D; 0,a ^ a ^ b &#x3D; a ^ b ^ a &#x3D; b，异或运算满足交换律，两个相同的数异或结果为0，0和任何数异或等于任何数本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 位操作：异或法</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        result = result ^ num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="面试题56-1"><a href="#面试题56-1" class="headerlink" title="面试题56-1"></a>面试题56-1</h1><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这<strong>两个只出现一次的数字</strong>。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/b74edd30-891c-11ea-a4ce-5fa96f96177c.png" alt="image.png"></p><p>和上道题一样，解法1和解法2也同样可以解决这道题，题目要求空间复杂度为O(1)，也就是不能使用额外的空间，能不能也使用位运算这种骚操作来解决呢？我在评论区找到了一个非常精美的<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jie-di-qi-jiang-jie-fen-zu-wei-yun-suan-by-eddievi/">答案</a>：</p><p>由于数组中存在着两个数字不重复的情况，我们将所有的数字异或操作起来，最终得到的结果是这两个数字的异或结果：(相同的两个数字相互异或，值为0)) 最后结果一定不为0，因为有两个数字不重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 ^ 1 ^ 4 ^ 6 =&gt; 1 ^ 6</span><br><span class="line"></span><br><span class="line">6 对应的二进制： 110</span><br><span class="line">1 对应的二进制： 001</span><br><span class="line">1 ^ 6  二进制： 111</span><br></pre></td></tr></table></figure><p>此时我们无法通过 111（二进制），去获得 110 和 001。那么当我们可以把数组分为两组进行异或，那么就可以知道是哪两个数字不同了。我们可以想一下如何分组：</p><ul><li>重复的数字进行分组，很简单，只需要有一个统一的规则，就可以把相同的数字分到同一组了。例如：奇偶分组。因为重复的数字，数值都是一样的，所以一定会分到同一组！</li><li>此时的难点在于，对两个不同数字的分组。此时我们要找到一个操作，让两个数字进行这个操作后，分为两组。我们最容易想到的就是<code>&amp; 1</code>操作， 当我们对奇偶分组时，容易地想到<code>&amp; 1</code>，即用于判断最后一位二进制是否为1。来辨别奇偶。</li></ul><p>你看，通过<code>&amp;</code>运算来判断一位数字不同即可分为两组，那么我们随便两个不同的数字至少也有一位不同吧！我们只需要找出那位不同的数字mask，即可完成分组（<code>&amp; mask</code>）操作。为了操作方便，我们只去找最低位的mask:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1: 101110    110     1111</span><br><span class="line">num2: 111110    001     1001</span><br><span class="line">mask: 010000    001     0010</span><br></pre></td></tr></table></figure><p>由于<strong>两个数异或的结果就是两个数数位不同结果的直观表现</strong>，所以我们可以通过异或后的结果去找最低位的mask！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumbers = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有数进行亦或得到的结果就是那两个不同数的结果 1^4^4^6 = 1^6</span></span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        k ^= num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得k中最低位的1</span></span><br><span class="line">    <span class="comment">// mask = k &amp; (-k) 这种方法也可以得到mask（树状数组的lowbit函数），具体原因百度 哈哈哈哈哈</span></span><br><span class="line">    <span class="keyword">let</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((k &amp; mask) === <span class="number">0</span>) &#123;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; mask) === <span class="number">0</span>) &#123;</span><br><span class="line">            a ^= num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [a, b];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.55 跳跃游戏</title>
      <link href="/2020/04/17/LeetCode-No55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/04/17/LeetCode-No55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:<br>输入: <code>[2,3,1,1,4]</code><br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: <code>[3,2,1,0,4]</code><br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>首先想到的是暴力法，针对每个位置可能走的步数一个个进行测试，如果这个步数能到达或者超过最后一个位置说明就可以到达，写代码的过程中注意将已经计算过的缓存起来，使用<strong>记忆化搜索</strong>防止重复计算。还可以从最大可能走的步数开始减少代替自增这样的小技巧来优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从i位置向后跳</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">i</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">jump</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[i] !== <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line">    <span class="comment">// 跳到最后位置了</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= nums.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> step = nums[i];</span><br><span class="line">    <span class="keyword">if</span> (step === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i + step &gt;= nums.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (step &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> flag = <span class="title function_">jump</span>(i + step);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[i] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      step--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">jump</span>(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><p>解题思路如下：</p><ol><li>如果某一个作为<strong>起跳点</strong>的格子可以跳跃的距离是3，那么表示后面3个格子都可以作为起跳点。</li><li>可以对每一个能作为起跳点的格子都尝试跳一次，把<strong>能跳到最远的距离</strong>不断更新。</li><li>如果可以一直跳到最后，就成功了。</li></ol><p>代码写出来非常精简，效率更是秒杀回溯法，有没有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k = <span class="title class_">Math</span>.<span class="title function_">max</span>(k, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= nums.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法的核心依据是：<strong>从当前位置能够到达某一个位置，那么从当前位置都可以到达某一位置左侧的所有位置</strong>。因此我们每次算的时候直接尝试最大步数就行了.例如<code>nums[i] == 3</code>，我们就不需要计算走一步，走两步了。</p><p>举个例子：如果从位置 3 可以跳到 位置 8，那么中间的 4、5、6、7 都可到达， 但是如果遇到下一个位置 i ，超过了目前可跳的最远距离 k ，那么直接返回 false 即可， 因为 i 位置左侧可跳的最远距离 k 都到达不了下一个位置 i，那么 i 和 i 后面的 位置皆不可到达。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.542 寻找 0-1 矩阵中的最小距离</title>
      <link href="/2020/04/15/LeetCode-No-542-%E5%AF%BB%E6%89%BE0-1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
      <url>/2020/04/15/LeetCode-No-542-%E5%AF%BB%E6%89%BE0-1%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><p>示例 1:<br>输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><p>示例 2:<br>输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure><p>注意:</p><p>给定矩阵的元素个数不超过 10000。<br>给定矩阵中至少有一个元素是 0。<br>矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p><p>方法一：多源广度优先搜索</p><p>对于矩阵中的每一个元素，如果它的值为0，那么离它最近的0就是它自己。如果它的值为1，那么我们就需要找出离它最近的0，并且返回这个距离值。那么我们如何对于矩阵中的每一个1，都快速地找到离它最近的0呢？</p><p>我们不妨从一个简化版本的问题开始考虑起。假设这个矩阵中恰好只有一个0，我们应该怎么做？由于矩阵中只有一个0，那么对于每一个1，离它最近的0就是那个唯一的0。如何求出这个距离呢？我们可以想到两种做法：</p><ul><li><p>如果0在矩阵中的位置是(i<del>0</del>, j<del>0</del>)，1在矩阵中的位置是 (i<del>1</del>, j<del>1</del>)，那么我们可以直接算出0和1之间的距离。因为我们从1到0需要在水平方向走 |i<del>0</del> - i<del>1</del>| 步，竖直方向走 |j<del>0</del> - j<del>1</del>| 步，那么它们之间的距离就为 |i<del>0</del> - i<del>1</del>| + |j<del>0</del> - j<del>1</del>|；</p></li><li><p>我们可以从0的位置开始进行<strong>广度优先搜索</strong>。广度优先搜索可以找到从起点到其余所有点的<strong>最短距离</strong>，因此如果我们从0开始搜索，每次搜索到一个1，就可以得到0到这个1的最短距离（从所有的0开始一圈一圈 向外扩散，因为每个1都是被离他最近的0扩散到的），也就离这个1最近的0的距离了（因为矩阵中只有一个0）</p></li></ul><p>举个例子，如果我们的矩阵为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ _ _ _</span><br><span class="line">_ 0 _ _</span><br><span class="line">_ _ _ _</span><br><span class="line">_ _ _ _</span><br></pre></td></tr></table></figure><p>其中只有一个0，剩余的1我们用短横线表示。如果我们从0开始进行广度优先搜索，那么结果依次为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ _ _ _         _ 1 _ _         2 1 2 _         2 1 2 3         2 1 2 3</span><br><span class="line">_ 0 _ _   ==&gt;   1 0 1 _   ==&gt;   1 0 1 2   ==&gt;   1 0 1 2   ==&gt;   1 0 1 2</span><br><span class="line">_ _ _ _         _ 1 _ _         2 1 2 _         2 1 2 3         2 1 2 3</span><br><span class="line">_ _ _ _         _ _ _ _         _ 2 _ _         3 2 3 _         3 2 3 4</span><br></pre></td></tr></table></figure><p>也就是说，在广度优先搜索的每一步中，如果我们从矩阵中的位置x搜索到了位置y，并且y还没有被搜索过，那么位置y离0的距离就等于位置x离0的距离加上1。</p><p>对于上面的两种做法，第一种看上去简洁有效，只需要对每一个位置计算一下就行；第二种需要实现广度优先搜索，会复杂一些。但是，别忘了我们的题目中会有不止一个0，这样以来，如果我们要使用第一种做法，就必须对于每个1计算一次它到所有的0的距离，再从中取一个最小值，时间复杂度会非常高，无法通过本地。而对于第二种做法，我们可以很有效地处理有多个0的情况。</p><p>处理的方法很简单：我们在进行广度优先搜索的时候会使用到队列，在只有一个0的时候，我们在搜索前会把这个0的位置加入队列，才能开始进行搜索；如果有多个0，我们只需要把这些0的位置<strong>都</strong>加入队列就行了。下面的做法是<strong>多源BFS</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateMatrix = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!matrix || matrix.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> visited = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    res.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n));</span><br><span class="line">    visited.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> d = [[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]]; <span class="comment">// 4个方向数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bfs</span></span><br><span class="line">  <span class="comment">// 1.将等于0的位置直接放入结果集并入队作为广度优先的起点(多起点的BFS)</span></span><br><span class="line">  <span class="keyword">const</span> q = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        res[i][j] = <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="title function_">push</span>([i, j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.多起点的广度优先</span></span><br><span class="line">  <span class="keyword">while</span> (q.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [x, y] = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [offsetX, offsetY] <span class="keyword">of</span> d) &#123;</span><br><span class="line">      <span class="keyword">const</span> newX = x + offsetX;</span><br><span class="line">      <span class="keyword">const</span> newY = y + offsetY;</span><br><span class="line">      <span class="comment">// 没有访问过的地方一定是1，因为第一步中值为0的位置全部被标记了</span></span><br><span class="line">      <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">        <span class="comment">// (newX,newY) 是 (x,y)的相邻节点</span></span><br><span class="line">        res[newX][newY] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">        visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="title function_">push</span>([newX, newY]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="方法二：记录层数的广度优先搜索"><a href="#方法二：记录层数的广度优先搜索" class="headerlink" title="方法二：记录层数的广度优先搜索"></a>方法二：记录层数的广度优先搜索</h1><p>我们知道不需要知道层数的BFS的模板如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while queue 不空：</span><br><span class="line">    cur = queue.pop()</span><br><span class="line">    for 节点 in cur的所有相邻节点：</span><br><span class="line">        if 该节点有效且未访问过：</span><br><span class="line">            queue.push(该节点)</span><br></pre></td></tr></table></figure><p>如果要确定当前遍历到了哪一层，BFS模板如下。这里增加了level表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">level = 0</span><br><span class="line">while queue 不空：</span><br><span class="line">    size = queue.size()</span><br><span class="line">    while (size --) &#123;</span><br><span class="line">        cur = queue.pop()</span><br><span class="line">        for 节点 in cur的所有相邻节点：</span><br><span class="line">            if 该节点有效且未被访问过：</span><br><span class="line">                queue.push(该节点)</span><br><span class="line">    &#125;</span><br><span class="line">    level ++;</span><br></pre></td></tr></table></figure><p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p><p>上面说了这个题是多个起始点的BFS，不要害怕，就是需要先遍历一遍矩阵，把所有0先放进队列中，然后再利用模板二。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> updateMatrix = <span class="keyword">function</span> (<span class="params">matrix</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!matrix || matrix.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> visited = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n));</span><br><span class="line">        visited.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> q = [];</span><br><span class="line">    <span class="comment">// 如果(i,j)元素为0，则 距离为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                res[i][j] = <span class="number">0</span>;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="title function_">push</span>([i, j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> d = [[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = q.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 将同一层的东西全部处理完（每次处理的都是同一层）</span></span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            <span class="keyword">const</span> [x, y] = q.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] === <span class="number">1</span>) &#123;</span><br><span class="line">                res[x][y] = level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [offsetX, offsetY] <span class="keyword">of</span> d) &#123;</span><br><span class="line">                <span class="keyword">const</span> newX = x + offsetX;</span><br><span class="line">                <span class="keyword">const</span> newY = y + offsetY;</span><br><span class="line">                <span class="comment">// 没有访问过的地方一定是1，因为第一步中值为0的位置全部被标记了</span></span><br><span class="line">                <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; !visited[newX][newY]) &#123;</span><br><span class="line">                    visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="title function_">push</span>([newX, newY]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.234 回文链表</title>
      <link href="/2020/04/14/LeetCode-No-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/14/LeetCode-No-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h1 id="转化成数组后使用双指针"><a href="#转化成数组后使用双指针" class="headerlink" title="转化成数组后使用双指针"></a>转化成数组后使用双指针</h1><p>首先想到的方法是遍历链表，将链表中的元素添加进数组，然后使用双指针解法，一个指针从前向后扫描，另一个指针从后向前扫描，一旦发现两个指针所指向的元素不同则不是回文，否则两个指针向中间靠拢，如果两个指针相遇，则是回文。这种思路其实是判断回文字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(cur.<span class="property">val</span>);</span><br><span class="line">    cur = cur.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[j]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>请看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="title function_">print</span>(node.<span class="property">next</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">val</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l = &#123;</span><br><span class="line">  <span class="attr">val</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">next</span>: &#123;</span><br><span class="line">      <span class="attr">val</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">next</span>: &#123;</span><br><span class="line">        <span class="attr">val</span>: <span class="number">4</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">print</span>(l);</span><br></pre></td></tr></table></figure><p>上面的算法其实是深度优先遍历，在二分搜索树中遍历中相当于后续遍历的过程，它总是先递归到最深处（这里就是链表的尾节点），然后一层一层返回，因此输出顺序为4-3-2-1。和原来链表的顺序相反。自然 而然可以想到：如果维护一个从前向后的指针，到递归到最深处的时候，最深处的节点和第一个节点比较；倒数第二层的节点和第二个节点比较也可以完成回文的判断。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> frontPointer = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">recursiveCheck</span>(<span class="params">curNode</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">    <span class="comment">// 这个检测放在第一行保证递归到最深处  </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="title function_">recursiveCheck</span>(curNode.<span class="property">next</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (curNode.<span class="property">val</span> !== frontPointer.<span class="property">val</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            frontPointer = frontPointer.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">recursiveCheck</span>(head);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以起作用的原因是递归处理节点的顺序是相反的（记住上面打印的算法）。由于递归，从本质上，我们同时在正向和逆向迭代。</p><p>这种方法看似非常惊艳，其实受限于栈空间的大小，限制了能处理的链表的大小。</p><h1 id="反转后半部分链表"><a href="#反转后半部分链表" class="headerlink" title="反转后半部分链表"></a>反转后半部分链表</h1><p>先反转后半部分链表，然后将前半部分和后半部分进行比较，比较完成后复原链表（为了不改变链表）.</p><p>我们可以分为以下几个步骤：</p><ol><li>找到前半部分链表的尾节点。</li><li>反转后半部分链表。</li><li>判断是否为回文。</li><li>恢复链表。</li><li>返回结果。</li></ol><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。或者可以<em>使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分</em>。若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p>步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。</p><p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="keyword">function</span> (<span class="params">head</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转后半部分链表</span></span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> firstHalfEnd = <span class="title function_">endOfFirstHalf</span>(head);</span><br><span class="line">    <span class="keyword">const</span> secondHalfStart = <span class="title function_">reverseList</span>(firstHalfEnd.<span class="property">next</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p1 = head;</span><br><span class="line">    <span class="keyword">let</span> p2 = secondHalfStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.<span class="property">val</span> !== p2.<span class="property">val</span>) &#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.<span class="property">next</span>;</span><br><span class="line">        p2 = p2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstHalfEnd.<span class="property">next</span> = <span class="title function_">reverseList</span>(secondHalfStart);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>,</span><br><span class="line">            cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = cur.<span class="property">next</span>;</span><br><span class="line">            cur.<span class="property">next</span> = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">endOfFirstHalf</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> fast = head,</span><br><span class="line">            slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.<span class="property">next</span> &amp;&amp; fast.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">            fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            slow = slow.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快慢指针求中点的原理是：同化成一个路程问题，同一段路程，A的速度是B的两倍，他们同时出发，当A走完全程时，B也就刚好走过一半。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No.19 删除链表中的倒数第 k 个元素</title>
      <link href="/2020/04/13/LeetCode-No-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2020/04/13/LeetCode-No-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>很容易想到的是先求出链表中元素的总个数，然后删除正数第n-k个元素，代码如下（下面的代码使用了虚拟头结点优化判断删除头结点的情况）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    cur = cur.<span class="property">next</span>;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">  dummyHead.<span class="property">next</span> = head;</span><br><span class="line">  <span class="keyword">let</span> prev = dummyHead;</span><br><span class="line">  cur = head;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (cnt &lt; count - n) &#123;</span><br><span class="line">    prev = cur;</span><br><span class="line">    cur = cur.<span class="property">next</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125;</span><br><span class="line">  prev.<span class="property">next</span> = cur.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">return</span> dummyHead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题目提示可以使用一次遍历的方法，这里百思不得其解，最后查看评论区使用了一种<strong>快慢指针</strong>。上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/eeb81490-7d6d-11ea-a1d0-559acca67d5f.png" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span> (<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">const</span> dummyHead = <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.<span class="property">next</span> = head;</span><br><span class="line">    <span class="keyword">let</span> first = dummyHead, second = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first) &#123;</span><br><span class="line">        first = first.<span class="property">next</span>;</span><br><span class="line">        second = second.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    second.<span class="property">next</span> = second.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode No22.括号生成</title>
      <link href="/2020/04/09/LeetCode-No22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2020/04/09/LeetCode-No22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目</a>描述如下：</p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><p>初看这一题，首先想到的是n个左括号和n个右括号的数组进行全排列得到所有的序列，然后从序列中过滤出合法的括号序列和重复序列(因为字符是有重复的，可能导致全排列本身中出现序列重复)，</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="comment">// 方案1：获取数组全排列，判断全排列中合法的括号</span></span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    arr.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isValid</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> balance = <span class="number">0</span>; <span class="comment">// 不使用显式的栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        balance++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        balance--;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> balance === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === arr.<span class="property">length</span>) &#123;</span><br><span class="line">      set.<span class="title function_">add</span>(arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      [arr[index], arr[i]] = [arr[i], arr[index]];</span><br><span class="line">      <span class="title function_">dfs</span>(index + <span class="number">1</span>);</span><br><span class="line">      [arr[index], arr[i]] = [arr[i], arr[index]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isValid</span>(item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))) &#123;</span><br><span class="line">      ret.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上暴力破解的复杂度为O(2N!)，提交后超时了。</p><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>方案1的改进，只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像方案1那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果左括号数量小于n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s, l, r</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span> * n) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(s.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n) &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        <span class="title function_">backtrack</span>(s, l + <span class="number">1</span>, r);</span><br><span class="line">        s.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; l) &#123;</span><br><span class="line">        s.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        <span class="title function_">backtrack</span>(s, l, r + <span class="number">1</span>);</span><br><span class="line">        s.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">backtrack</span>([], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ea60b020-7a32-11ea-ba6c-834b91f09992.png" alt="image.png"></p><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>我们以 n &#x3D; 2 为例，画树形结构图。方法是 “做减法”。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/0661e0a0-7a33-11ea-ba6c-834b91f09992.png" alt="image.png"></p><p>画图以后，可以分析出的结论：</p><ul><li>当前左右括号都有大于0个可以使用的时候，才产生分支；</li><li>产生左分支的时候，只看当前是否还有左括号可以使用；</li><li>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；</li><li>在左边和右边剩余的括号数都等于0的时候结算。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="comment">// 方案2：DFS</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> curStr 从根节点到当前节点的路径字符串</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> leftRemain 左括号还可以使用的个数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rightRemain 右括号还可以使用的个数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">curStr, leftRemain, rightRemain</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftRemain === <span class="number">0</span> &amp;&amp; rightRemain === <span class="number">0</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(curStr);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span></span><br><span class="line">    <span class="keyword">if</span> (leftRemain &gt; rightRemain) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftRemain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯，常用的回溯算法是改变状态，下一次尝试，完成后撤销状态更改</span></span><br><span class="line">      <span class="title function_">dfs</span>(curStr + <span class="string">&#x27;(&#x27;</span>, leftRemain - <span class="number">1</span>, rightRemain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightRemain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">dfs</span>(curStr + <span class="string">&#x27;)&#x27;</span>, leftRemain, rightRemain - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dfs</span>(<span class="string">&#x27;&#x27;</span>, n, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们不用减法，使用加法，即 leftUsed 表示“左括号用掉几个”，rightUsed 表示“右括号用掉几个”，可以画出另一棵递归树。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7040c610-7a35-11ea-ba6c-834b91f09992.png" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfs2</span>(<span class="params">curStr, leftUsed, rightUsed</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftUsed === n &amp;&amp; rightUsed === n) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(curStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftUsed &lt; rightUsed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftUsed &lt; n) &#123;</span><br><span class="line">        <span class="title function_">dfs2</span>(curStr + <span class="string">&#x27;(&#x27;</span>, leftUsed + <span class="number">1</span>, rightUsed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightUsed &lt; n) &#123;</span><br><span class="line">        <span class="title function_">dfs2</span>(curStr + <span class="string">&#x27;)&#x27;</span>, leftUsed, rightUsed + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>通过编写广度优先遍历的代码，读者可以体会一下，为什么搜索几乎都是用深度优先遍历（回溯算法）。</p><p>广度优先遍历，得程序员自己编写结点类，显示使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。</p><p>下面的代码，可以把 Queue 换成 Stack，提交以后，也可以得到 Accept。</p><p>读者可以通过比较：</p><p>1、广度优先遍历；</p><p>2、自己使用栈编写深度优先遍历；</p><p>3、使用系统栈的深度优先遍历（回溯算法）。</p><p>来理解 “回溯算法” 作为一种 “搜索算法” 的合理性。</p><p>还是上面的题解配图（1），使用广度优先遍历，结果集都在最后一层，即叶子结点处得到所有的结果集，编写代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">str, leftRemain, rightRemain</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leftRemain</span> = leftRemain;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rightRemain</span> = rightRemain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> q = [<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&#x27;&#x27;</span>, n, n)]; <span class="comment">// 队列换成栈就变成了深度优先搜索</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; str, leftRemain, rightRemain &#125; = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">if</span> (leftRemain === <span class="number">0</span> &amp;&amp; rightRemain === <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftRemain &gt; rightRemain) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftRemain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Node</span>(str + <span class="string">&#x27;(&#x27;</span>, leftRemain - <span class="number">1</span>, rightRemain));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightRemain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Node</span>(str + <span class="string">&#x27;)&#x27;</span>, leftRemain, rightRemain - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现 async/await</title>
      <link href="/2020/03/26/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0async-await/"/>
      <url>/2020/03/26/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0async-await/</url>
      
        <content type="html"><![CDATA[<p>基于 <code>Promise</code> 的异步处理虽然解决了基于 callback 的过多嵌套的问题，但是可读性也并没有强多少，流程控制也不是特别方便，所以 ES7 提出了 <code>async</code> 函数完美解决了上述问题。<strong>async&#x2F;await实际上是对Generator 的封装，是生成器函数的语法糖</strong>。</p><p><code>async</code>函数是<code>AsyncFunction</code>构造函数的实例，并且在函数体中允许使用 <code>await</code> 关键字。<code>await</code> 操作符用于等待 Promise 兑现并获取它兑现之后的值，智能在 async 函数或者顶层模块中使用。<code>async</code> 和 <code>await</code> 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 Promise</p><blockquote><p>ES6 新引入了 Generator 函数，可以通过 <code>yield</code> 关键字，把函数的执行流程挂起，通过<code>next()</code>方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p></blockquote><blockquote><p><code>yield</code> 表达式本身没有返回值（或者总是返回 <code>undefined</code>），<code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 表达式的返回值。这个功能有非常重要的语法意义。生成器函数从暂停状态到恢复运行，它的上下文状态（context）是不变的，通过 <code>next</code> 方法的参数，就有办法在生成器函数开始运行后，继续向函数体内部注入值。—— 可以在生成器函数运行的不同阶段，通过 <code>next</code> 传递参数注入不同的值，从而调整函数的行为。</p></blockquote><blockquote><p>注意：由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 表达式的返回值，因此第一次调用 <code>next</code> 方法的时候传递参数是无效的（引擎会直接忽略掉），从语义上来说第一次调用 <code>next</code> 函数是用来启动遍历器对象，是不能带参数的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="title function_">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="title function_">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">mygen</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yield1 -&gt;&#x27;</span>, a);</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yield2 -&gt;&#x27;</span>, b);</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yield3 -&gt;&#x27;</span>, c);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">mygen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空参数&#x27;</span>, g.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数1&#x27;</span>, g.<span class="title function_">next</span>(<span class="string">&#x27;arg1&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数2&#x27;</span>, g.<span class="title function_">next</span>(<span class="string">&#x27;arg2&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数3&#x27;</span>, g.<span class="title function_">next</span>(<span class="string">&#x27;arg3&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 空参数 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// yield1 -&gt; arg1</span></span><br><span class="line"><span class="comment">// 参数1 &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">// yield2 -&gt; arg2</span></span><br><span class="line"><span class="comment">// 参数2 &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="comment">// yield3 -&gt; arg3</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// 参数3 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>可以看出<code>yield</code>和<code>async/await</code>已经非常相似了，他们都提供了暂停执行的功能，但是二者又有以下几点不同：</p><ul><li><code>async/await</code>自带执行器，不需要手动调用<code>next()</code>就能自动执行下一步</li><li><code>async</code>函数返回值是 Promise 对象，而 Generator 返回的是生成器对象</li><li><code>await</code>能够返回 Promise 的 resolve&#x2F;reject 的值</li></ul><p>我们对 <code>async/await</code> 的实现，其实也就是对应以上三点封装 Generator</p><h1 id="自动执行"><a href="#自动执行" class="headerlink" title="自动执行"></a>自动执行</h1><p>我们先来看一下，对于这样一个 Generator，手动执行是怎样一个流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">myGenerator</span>();</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    gen.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">        gen.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出1,2,3</span></span><br></pre></td></tr></table></figure><p>我们也可以通过给 gen 生成器的 <code>next</code> 方法传值的方式，让<code>yield</code>能返回 resolve 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret1 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret1&#x27;</span>, ret1);</span><br><span class="line">    <span class="keyword">const</span> ret2 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret2&#x27;</span>, ret2);</span><br><span class="line">    <span class="keyword">const</span> ret3 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret3&#x27;</span>, ret3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过给gen.next()传值的方式，让 yield 能返回 resolve 的值</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">myGenerator</span>();</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val1</span> =&gt;</span> &#123;</span><br><span class="line">    gen.<span class="title function_">next</span>(val1).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val2</span> =&gt;</span> &#123;</span><br><span class="line">        gen.<span class="title function_">next</span>(val2).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val3</span> =&gt;</span> &#123;</span><br><span class="line">            gen.<span class="title function_">next</span>(val3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ret1 1</span></span><br><span class="line"><span class="comment">// ret2 2</span></span><br><span class="line"><span class="comment">// ret3 3</span></span><br></pre></td></tr></table></figure><p>显然，手动执行的写法看起来既笨拙又丑陋，我们希望生成器函数能自动往下执行，且<code>yield</code>能返回 resolve 的值，基于这两个需求，我们进行一个基本的封装，由于<code>async/await</code>是关键字，无法重写，我们用函数来模拟：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">gen</span>();  <span class="comment">// 由于每次gen()获取到的都是最新的迭代器,因此获取迭代器操作要放在step()之前,否则会进入死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装一个方法，递归执行next()</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = g.<span class="title function_">next</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">done</span>) <span class="keyword">return</span> res.<span class="property">value</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="comment">// Promise的then方法是实现自动迭代的前提</span></span><br><span class="line">        <span class="comment">// 等待Promise完成就自动执行下一个next，并传入resolve的值</span></span><br><span class="line">        res.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="title function_">step</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次执行</span></span><br><span class="line">    <span class="title function_">step</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于之前的例子，我们就可以这样执行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">myGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ret1 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret1&#x27;</span>, ret1);</span><br><span class="line">    <span class="keyword">const</span> ret2 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret2&#x27;</span>, ret2);</span><br><span class="line">    <span class="keyword">const</span> ret3 = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ret3&#x27;</span>, ret3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">runGen</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> it = <span class="title function_">gen</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = it.<span class="title function_">next</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            value.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">next</span>(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runGen</span>(myGenerator);</span><br></pre></td></tr></table></figure><p>这样我们就初步实现了一个 <code>async/await</code></p><p>上边的代码只有五六行，但并不是一下就能看明白的，我们之前用了四个例子来做铺垫，也是为了让读者更好地理解这段代码。简单的说，我们封装了一个 runGen 方法，runGen 方法里我们把执行下一步的操作封装成 next()，每次 Promise.then() 的时候都去执行 next()，实现自动迭代的效果。在迭代的过程中，我们还把 resolve 的值传入 it.next，使得 <code>yield</code> 得以返回 Promise 的 resolve 的值。</p><h1 id="返回-Promise-异常处理"><a href="#返回-Promise-异常处理" class="headerlink" title="返回 Promise &amp; 异常处理"></a>返回 Promise &amp; 异常处理</h1><p>虽然我们实现了 Generator 的自动执行以及让 <code>yield</code> 返回 resolve 的值，但上边的代码还存在着几点问题：</p><ul><li>需要兼容基本类型：这段代码能自动执行的前提是<code>yield</code>后面跟<code>Promise</code>，为了兼容后面跟着基本类型值的情况，我们需要把<code>yield</code>跟的内容<code>(gen().next.value)</code>都用<code>Promise.resolve()</code>转化一遍</li><li>缺少错误处理:上边代码里的<code>Promise</code>如果执行失败，就会导致后续执行直接中断，我们需要通过调用<code>Generator.prototype.throw()</code>，把错误抛出来，才能被外层的<code>try-catch</code>捕获到</li><li>返回值是Promise:<code>async/await</code>的返回值是一个<code>Promise</code>，我们这里也需要保持一致，给返回值包一个<code>Promise</code></li></ul><p>改造后的 <code>run</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="comment">// 把返回值包装成Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 错误处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> res = g.<span class="title function_">next</span>(val);</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(res.<span class="property">value</span>);</span><br><span class="line">                <span class="comment">// res.value包装为promise，以兼容yield后面跟基本类型的情况</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(res.<span class="property">value</span>).<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">step</span>(value),</span><br><span class="line">                    <span class="comment">// 抛出错误</span></span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> g.<span class="keyword">throw</span>(err)</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">step</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/e311eef0-6ff7-11ea-8d70-bd1d29de8613.png" alt="image.png"></p><p>到这里，一个基本的<code>async/await</code>就实现完成了,但是直到结尾，我们也不知道<code>await</code>到底是如何暂停执行的，有关<code>await</code>暂停执行的秘密，我们还要到 Generator 的实现中去寻找答案。</p><h1 id="Generator的实现"><a href="#Generator的实现" class="headerlink" title="Generator的实现"></a>Generator的实现</h1><p>例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>);</span><br></pre></td></tr></table></figure><p>我们可以在<a href="https://www.babeljs.cn/repl">babel官网</a>找到其在ES5下的实现：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/51d35420-6ffb-11ea-8d70-bd1d29de8613.png" alt="image.png"></p><p>代码咋一看不长，但如果仔细观察会发现有两个不认识的东西 —— <code>regeneratorRuntime.mark</code>和<code>regeneratorRuntime.wrap</code>，这两者其实是 <code>regenerator-runtime</code> 模块里的两个方法，<code>regenerator-runtime</code> 模块来自 facebook 的 <code>regenerator</code> 模块。直接看源码是有点懵，接下来我们实现一下它的低配版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen$</span>(<span class="params">_context</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 取next并将next赋值给下一次执行的prev</span></span><br><span class="line">        <span class="keyword">switch</span> (_context.<span class="property">prev</span> = _context.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                _context.<span class="property">next</span> = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result1&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                _context.<span class="property">next</span> = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result2&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                _context.<span class="property">next</span> = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;result3&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;end&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> _context.<span class="title function_">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版context</span></span><br><span class="line"><span class="keyword">const</span> context = &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">prev</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低配版invoke</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">next</span> () &#123;</span><br><span class="line">            <span class="keyword">const</span> value = context.<span class="property">done</span> ? <span class="literal">undefined</span> : <span class="title function_">gen$</span>(context);</span><br><span class="line">            <span class="keyword">const</span> done = context.<span class="property">done</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;value, done&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3774b340-6fff-11ea-8d70-bd1d29de8613.png" alt="image.png"></p><p>从中我们可以看出，Generator 实现的核心在于<strong>上下文的保存</strong>，这其实是一个状态机。函数并没有真的被挂起，每一次<code>yield</code>，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个<code>context</code>对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://juejin.im/post/5bd85cfbf265da0a9e535c10">ES6 系列之 Babel 将 Generator 编译成了什么样子</a></li><li><a href="https://segmentfault.com/a/1190000043371796">理解 async&#x2F;await 原理</a></li><li><a href="https://es6.ruanyifeng.com/#docs/async">ES6 async</a></li><li><a href="https://es6.ruanyifeng.com/#docs/generator">ES6 Generator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现 Promise</title>
      <link href="/2020/03/25/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Promise/"/>
      <url>/2020/03/25/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Promise/</url>
      
        <content type="html"><![CDATA[<p>先来看下 Promise 的常见应用：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/f66cf600-6e4b-11ea-820f-7db7c768e84c.png" alt="image.png"></p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>观察上面的这个例子，我们来分析 Promise 的调用流程：</p><ul><li>构造方法接受一个 executor 函数，在 new Promise 的时候这个 executor 立即执行</li><li>executor 内部的异步任务被放入微任务队列等待执行</li><li>then 被执行，收集成功&#x2F;失败回调，放入成功&#x2F;失败队列</li><li>executor 的异步任务被执行，触发resolve&#x2F;reject，从成功&#x2F;失败队列中取出回调依次执行</li></ul><p>由上面的分析得知这是一种典型的<strong>观察者模式</strong>。这是典型的“收集依赖-&gt;触发依赖-&gt;取出依赖执行”的方式，在 Promise 中执行顺序是 “then收集依赖-&gt;异步触发resolve-&gt;resolve执行依赖”。由此我们可以勾勒出 Promise 的大致形状：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveQueue</span> = []; <span class="comment">// then收集执行成功的回调队列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectQueue</span> = []; <span class="comment">// then收集执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">resolve</span> = val =&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                <span class="title function_">callback</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">reject</span> = val =&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                <span class="title function_">callback</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">executor</span>(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受一个成功的回调和一个失败的回调并push进对应的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">resolveFn</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">rejectFn</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolveFn,rejectFn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">push</span>(resolveFn);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">push</span>(rejectFn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+规范"></a>Promise A+规范</h1><p>以上，我们用观察者模式简单实现了能够在then方法的回调中取得异步操作的返回值，下面我们使用Promise A+规范来补充下这个Promise。</p><blockquote><p>Promise 本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆<br>then方法接收两个可选参数，分别对应状态改变时触发的回调。then 方法返回一个 promise。then 方法可以被同一个 promise 调用多次</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/d8633dc0-6e6b-11ea-820f-7db7c768e84c.png" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveQueue</span> = []; <span class="comment">// then收集执行成功的回调队列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectQueue</span> = []; <span class="comment">// then收集执行失败的回调队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">resolve</span> = val =&gt; &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>; <span class="comment">// 状态只能由pending转为fulfilled</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>; <span class="comment">// 状态变更</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                <span class="title function_">callback</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">reject</span> = val =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                <span class="title function_">callback</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">executor</span>(resolve,reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接受一个成功的回调和一个失败的回调并push进对应的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">resolveFn</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">rejectFn</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolveFn,rejectFn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">push</span>(resolveFn);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">push</span>(rejectFn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="then的链式调用"><a href="#then的链式调用" class="headerlink" title="then的链式调用"></a>then的链式调用</h1><p>先来看个简单的例子：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/cae66990-6e6d-11ea-820f-7db7c768e84c.png" alt="image.png"></p><p>思考下如何实现这种链式调用：</p><ol><li>promise可以不断地then下去，说明<strong>then方法本身会返回一个Promise，那些直接return 一个值的也会被包装为Promise</strong></li><li>then的回调需要按顺序执行。以上面的代码为例，虽然中间return了一个Promise，但执行的顺序仍然要保证是1-2-3，我们需要等待Promise的状态变更后再执行下一个then收集的回调</li></ol><p>对then方法进行如下改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">resolveFn, rejectFn</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下在放入 resolve 队列 ，这是为了能够获取then中的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">fulfilledFn</span> = value =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行当前的Promise的成功回调，并获取返回值</span></span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">resolveFn</span>(value);</span><br><span class="line">                <span class="comment">// 分类讨论返回值 ，如果是Promise，那么等待Promise的状态变更，否则直接resolve</span></span><br><span class="line">                x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 把后续then收集的依赖都放入当前Promise的 回调队列中，这是为了保证顺序调用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">push</span>(fulfilledFn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">rejectedFn</span> = error =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">rejectFn</span>(error);</span><br><span class="line">                x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">push</span>(rejectedFn);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="值穿透-状态已变更情况"><a href="#值穿透-状态已变更情况" class="headerlink" title="值穿透 &amp; 状态已变更情况"></a>值穿透 &amp; 状态已变更情况</h1><p>值穿透：根据规范，如果then接受的函数不是function，那么我们应该忽略它。如果没有忽略，当then回调不为function的时候会抛出异常，导致链式调用中断。<br>处理状态为resolve&#x2F;reject的情况：其实我们上边 then() 的写法是对应状态为pendding的情况，但是有些时候，resolve&#x2F;reject 在 then() 之前就被执行（比如Promise.resolve().then()），如果这个时候还把 then()回调 push 进 resolve&#x2F;reject 的执行队列里，那么回调将不会被执行，因此对于状态已经变为fulfilled或rejected的情况，我们直接执行 then 回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">resolveFn, rejectFn</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(reason <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? reason.<span class="property">message</span> : reason);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把resolveFn重新包装一下在放入 resolve 队列 ，这是为了能够获取then中的返回值进行分类讨论</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">fulfilledFn</span> = value =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行当前的Promise的成功回调，并获取返回值</span></span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">resolveFn</span>(value);</span><br><span class="line">                <span class="comment">// 分类讨论返回值 ，如果是Promise，那么等待Promise的状态变更，否则直接resolve</span></span><br><span class="line">                x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">rejectedFn</span> = error =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = <span class="title function_">rejectFn</span>(error);</span><br><span class="line">                x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">status</span>) &#123;</span><br><span class="line">            <span class="comment">//  当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">            <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">resolveQueue</span>.<span class="title function_">push</span>(fulfilledFn);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rejectQueue</span>.<span class="title function_">push</span>(rejectedFn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">            <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">                <span class="title function_">fulfilledFn</span>(<span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// this.value是上一个then回调return的值（见完整代码）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">                <span class="title function_">rejectedFn</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="兼容同步任务"><a href="#兼容同步任务" class="headerlink" title="兼容同步任务"></a>兼容同步任务</h1><p>完成了 then 的链式调用以后，我们再处理一个前边的细节，然后放出完整代码。上文我们说过，Promise 的执行顺序是 new Promise -&gt; then()回调收集 -&gt; resolve&#x2F;reject执行回调。这一顺序是建立在<strong>executor是异步任务</strong>的前提上的。如果executor是一个同步任务，那么执行顺序会变成new Promise -&gt; resolve&#x2F;reject的回调 -&gt; then收集回调（即resolve的执行跑到then前面去了，从而导致我们无法在then中得到Promise的resolve的值）。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/d6b35b20-6e7c-11ea-820f-7db7c768e84c.png" alt="image.png"></p><p>为了兼容上述情况，我们给resolve&#x2F;reject执行回调的操作包装一个setTimeout让其异步执行：</p><blockquote><p>这里插一句，有关这个 setTimeout，其实还有一番学问。虽然规范没有要求回调应该被放进宏任务队列还是微任务队列，但其实 Promise 的默认实现是放进了微任务队列，我们的实现（包括大多数 Promise 手动实现和 polyfill 的转化）都是使用 setTimeout 放入了宏任务队列（当然我们也可以用 MutationObserver 模拟微任务）</p></blockquote><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">PENDING</span>;    <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span>;<span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_resolveQueue</span> = [];    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rejectQueue</span> = [];     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">_resolve</span> = val =&gt; &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">FULFILLED</span>;            <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_value</span> = val;                  <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                    <span class="title function_">callback</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">_reject</span> = val =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">REJECTED</span>;             <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_value</span> = val;                   <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                    <span class="title function_">callback</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        <span class="title function_">executor</span>(_resolve, _reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolveFn, rejectFn</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">thrownewError</span>(reason <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? reason.<span class="property">message</span> : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">fulfilledFn</span> = value =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">resolveFn</span>(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejectedFn</span> = error =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">rejectFn</span>(error);</span><br><span class="line">                    x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">_status</span>) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">push</span>(fulfilledFn);</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">push</span>(rejectedFn);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">                    <span class="title function_">fulfilledFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>);    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">                    <span class="title function_">rejectedFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/a0853300-6e7e-11ea-820f-7db7c768e84c.png" alt="image.png"></p><h1 id="Promise中的其他方法"><a href="#Promise中的其他方法" class="headerlink" title="Promise中的其他方法"></a>Promise中的其他方法</h1><p>以上我们就实现了Promise的主要功能，剩下的几个方法都非常简单：</p><p><code>Promise.prototype.catch</code>，返回一个 Promise，并且处理拒绝的情况。它的行为与调用<code>Promise.prototype.then(undefined, onRejected)</code>相同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line"><span class="keyword">catch</span> (rejectFn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, rejectFn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Promise.prototype.finally()</code>返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。在 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的then。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">callback</span>())).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> reason))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>返回一个以给定值解析后的 Promise 对象。如果该值为 promise，返回这个 promise；如果这个值是 thenable（即带有”then” 方法)），返回的 promise 会“跟随”这个 thenable 的对象，采用它的最终状态；否则返回的 promise 将以此值完成。此函数将类 promise 对象的多层嵌套展平。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">    <span class="keyword">return</span> value <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? value : <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的 Promise 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.all(iterable)方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArr[i]).<span class="title function_">then</span>(</span><br><span class="line">                <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    results[i] = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                    <span class="keyword">if</span> (index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(results);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 有一个Promise被reject时，Promise的状态变为reject</span></span><br><span class="line">                    <span class="title function_">reject</span>(err);</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise.race(iterable)方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">    <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新Promise的状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">                <span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">resolve</span>(value),</span><br><span class="line">                <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(err)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise/A+规定的三种状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法接收一个回调</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">PENDING</span>;    <span class="comment">// Promise状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = <span class="literal">undefined</span>;<span class="comment">// 储存then回调return的值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_resolveQueue</span> = [];    <span class="comment">// 成功队列, resolve时触发</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_rejectQueue</span> = [];     <span class="comment">// 失败队列, reject时触发</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于resolve/reject是在executor内部被调用, 因此需要使用箭头函数固定this指向, 否则找不到this._resolveQueue</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">_resolve</span> = val =&gt; &#123;</span><br><span class="line">            <span class="comment">//把resolve执行回调的操作封装成一个函数,放进setTimeout里,以兼容executor是同步代码的情况</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">FULFILLED</span>;            <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_value</span> = val;                  <span class="comment">// 储存当前value</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里之所以使用一个队列来储存回调,是为了实现规范要求的 &quot;then 方法可以被同一个 promise 调用多次&quot;</span></span><br><span class="line">                <span class="comment">// 如果使用一个变量而非队列来储存回调,那么即使多次p1.then()也只会执行一次回调</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                    <span class="title function_">callback</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 实现同resolve</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">_reject</span> = val =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;<span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_status</span> = <span class="variable constant_">REJECTED</span>;             <span class="comment">// 变更状态</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_value</span> = val;                   <span class="comment">// 储存当前value</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="keyword">const</span> callback = <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">shift</span>();</span><br><span class="line">                    <span class="title function_">callback</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="built_in">setTimeout</span>(run);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// new Promise()时立即执行executor,并传入resolve和reject</span></span><br><span class="line">        <span class="title function_">executor</span>(_resolve, _reject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then方法,接收一个成功的回调和一个失败的回调</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolveFn, rejectFn</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据规范，如果then的参数不是function，则我们需要忽略它, 让链式调用继续往下执行</span></span><br><span class="line">        <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">value</span> =&gt;</span> value : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">thrownewError</span>(reason <span class="keyword">instanceof</span> <span class="title class_">Error</span> ? reason.<span class="property">message</span> : reason);</span><br><span class="line">        &#125; : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return一个新的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 把resolveFn重新包装一下,再push进resolve执行队列,这是为了能够获取回调的返回值进行分类讨论</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">fulfilledFn</span> = value =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行第一个(当前的)Promise的成功回调,并获取返回值</span></span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">resolveFn</span>(value);</span><br><span class="line">                    <span class="comment">// 分类讨论返回值,如果是Promise,那么等待Promise状态变更,否则直接resolve</span></span><br><span class="line">                    x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reject同理</span></span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejectedFn</span> = error =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = <span class="title function_">rejectFn</span>(error);</span><br><span class="line">                    x <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? x.<span class="title function_">then</span>(resolve, reject) : <span class="title function_">resolve</span>(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">_status</span>) &#123;</span><br><span class="line">                <span class="comment">// 当状态为pending时,把then回调push进resolve/reject执行队列,等待执行</span></span><br><span class="line">                <span class="keyword">case</span> <span class="attr">PENDING</span>:</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">_resolveQueue</span>.<span class="title function_">push</span>(fulfilledFn);</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">_rejectQueue</span>.<span class="title function_">push</span>(rejectedFn);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当状态已经变为resolve/reject时,直接执行then回调</span></span><br><span class="line">                <span class="keyword">case</span> <span class="attr">FULFILLED</span>:</span><br><span class="line">                    <span class="title function_">fulfilledFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>);    <span class="comment">// this._value是上一个then回调return的值(见完整版代码)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="attr">REJECTED</span>:</span><br><span class="line">                    <span class="title function_">rejectedFn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// catch方法其实就是执行一下then的第二个回调</span></span><br><span class="line">    <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, rejectFn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">            <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">callback</span>())).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">            <span class="function"><span class="params">reason</span> =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> reason))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据规范, 如果参数是Promise实例, 直接return这个实例</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? value : <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(reason));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> results = [];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// Promise.resolve(p)用于处理传入值不为Promise的情况</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArr[i]).<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                        index++;</span><br><span class="line">                        results[i] = value;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 所有then执行后, resolve结果</span></span><br><span class="line">                        <span class="keyword">if</span> (index === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">                            <span class="title function_">resolve</span>(results);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 有一个Promise被reject时，Promise的状态变为reject</span></span><br><span class="line">                        <span class="title function_">reject</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promiseArr</span>) &#123;</span><br><span class="line">        <span class="comment">// 同时执行Promise,如果有一个Promise的状态发生改变,就变更新Promise的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p).<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">resolve</span>(value),</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(err)</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些好用的轮子和工具</title>
      <link href="/2019/09/10/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E5%92%8C%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/09/10/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E5%92%8C%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>凡是现实的都是合理的，凡是合理的都是现实的。—— 黑格尔</p></blockquote><h1 id="canvas绘图"><a href="#canvas绘图" class="headerlink" title="canvas绘图"></a>canvas绘图</h1><p>阿里的数据可视化的底层框架<a href="https://antv.alipay.com/zh-cn/g2/3.x/index.html">g2</a>，无需从头到尾操作原生canvas api了，画线、矩形、圆形、贴图等非常便利。</p><h1 id="提高效率的chrome拓展"><a href="#提高效率的chrome拓展" class="headerlink" title="提高效率的chrome拓展"></a>提高效率的chrome拓展</h1><ul><li>双向修改CSS的工具<a href="http://livestyle.io/">livestyle</a></li></ul><h1 id="常见的网关"><a href="#常见的网关" class="headerlink" title="常见的网关"></a>常见的网关</h1><ul><li>Openresty：基于 Nginx 的高性能 Web 平台，集成了大量模块，用来处理 HTTP 请求，被许多企业作为内部网关的基础框架</li><li>Kong：构建在 OpenResty 上的网关平台，有丰富的插件体系，支持身份认证、限流、日志记录、监控等功能</li></ul><h1 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h1><ul><li><a href="https://www.bilibili.com/video/BV1qWwke5E3K/?vd_source=664c38ac43734b4498828309a0ebd40b">从 0 开始写大模型</a></li><li><a href="https://midscenejs.com/zh/">基于 AI 的浏览器自动化</a></li></ul><h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><p>github 文件加速:</p><ul><li><a href="https://ghproxy.link/">https://ghproxy.link/</a></li><li><a href="https://ghfast.top/">https://ghfast.top/</a></li><li><a href="https://github.com/jvxiao/speed-github.git">https://github.com/jvxiao/speed-github.git</a></li></ul><h1 id="优秀的开源项目"><a href="#优秀的开源项目" class="headerlink" title="优秀的开源项目"></a>优秀的开源项目</h1><ul><li><a href="https://github.com/leaper-one/MultiPost-Extension">https://github.com/leaper-one/MultiPost-Extension</a></li><li><a href="https://github.com/dgtlmoon/changedetection.io">https://github.com/dgtlmoon/changedetection.io</a></li></ul><h1 id="windows-必备软件"><a href="#windows-必备软件" class="headerlink" title="windows 必备软件"></a>windows 必备软件</h1><ul><li>SumatraPDF</li><li>QQ 影音</li><li>NVM for windows</li><li>DBeaver</li><li>Docker Desktop</li><li>Cursor</li><li>Vscode</li><li>Windows Terminal</li><li>搜狗拼音（微软自带的拼音太简陋了，中文模式下括号不能自动匹配）</li></ul><h1 id="Mac-必备软件"><a href="#Mac-必备软件" class="headerlink" title="Mac 必备软件"></a>Mac 必备软件</h1><ul><li>NVM</li><li>IINA</li><li>Vscode</li><li>Chrome</li><li>Docker</li><li>WPS（查看 PDF，视图，适应宽度，并且开启连续阅读，看 PDF 的体验会比较好）</li><li>搜狗拼音</li><li>bat：替代 cat</li><li>jq: 命令行 json 查看器</li></ul><h1 id="Git-上的一些必要配置"><a href="#Git-上的一些必要配置" class="headerlink" title="Git 上的一些必要配置"></a>Git 上的一些必要配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防止中文文件名显示为 8 进制，人类不可读</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先配置成自己的，一般公司项目有限，在公司的仓库下按照公司的要求进行配置</span></span><br><span class="line">git config --global user.name consoles</span><br><span class="line">git config --global user.email consoles.me@gmail.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Git 全局配置</span></span><br><span class="line">git config --list --global</span><br></pre></td></tr></table></figure><h1 id="终端-json-工具"><a href="#终端-json-工具" class="headerlink" title="终端 json 工具"></a>终端 json 工具</h1><p>使用 curl 查看 api 的返回结果，json 的格式不友好，可以使用 Perl 自带的 json_pp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://api.json | json_pp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些生活技能</title>
      <link href="/2019/09/10/%E4%B8%80%E4%BA%9B%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD/"/>
      <url>/2019/09/10/%E4%B8%80%E4%BA%9B%E7%94%9F%E6%B4%BB%E6%8A%80%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我当然不喜欢贫穷，人穷志短，成天为衣食住行操心是很毁人的。但我从不梦想着大富大贵，因为人一旦把赚钱当作目的，就永远也不会觉得够。富了终归可以更富，走上这条路的人，很少能够自己停下来。有大量触目惊心的权钱交易的案例已经证明，对金钱的贪欲会使人不顾一切，甚至不要性命。千万不要以为，这些一失足成千古恨的人是天生的坏人。事实上，他们与我们中间许多人的区别只在于，他们恰好处在一个直接面对巨大诱惑的位置上。赚多少钱是个够？永远也没够！不管是谁，赚钱的目的，不过是为了更幸福。但有时候，我们走得太远，慢慢忘记了为什么出发。</p></blockquote><h1 id="健身食材"><a href="#健身食材" class="headerlink" title="健身食材"></a>健身食材</h1><p>香蕉 燕麦 鸡胸 鸡蛋 西兰花</p><h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><p>出境：</p><ul><li>菲律宾长滩岛</li><li>法国罗浮宫：三件镇宫之宝：蒙娜丽莎、维纳斯、胜利女神。</li></ul><p>国内：</p><p>罗湖的国贸上面有个旋转餐厅，邓小平曾在那里吃过饭，现在那里的价格很便宜，自助才70多一个人，可以带外地来的朋友去那里吃饭。罗湖有个翡翠明珠可以去玩玩。</p><h1 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a>物理学</h1><p>任何坚固的天体在接近另一个比它大得多的天体的时候都会受到强大的潮汐力作用而最终被扯成碎片。</p><p>物体的温度是由分子振动产生的。</p><p>小孔成像说明了光沿直线传播。</p><p>E&#x3D;mc^2将时间和空间结合为一个整体。</p><p>爱因斯坦关于广义相对论的4个预测：光线弯曲、水星进动、引力红移、引力波。</p><p>地球上的时钟比真空中的时钟慢，所以GPS卫星需要定期修正时间。这是广义相对论的实际应用。</p><p>对于一个电磁波而言时间是不存在的，因为在其路径上的一切（宇宙中任何地方）无不是同时的；也可以说距离是不存在的，因为它即时接触到宇宙中任何事物。</p><p>一个质子由2个上夸克和1个下夸克由基本力结合在一起；一个中子由2个下夸克和一个上夸克组成。一个上夸克带有2&#x2F;3正电荷,一个下夸克带有1&#x2F;3负电荷。因此一个质子带有1个正电荷，一个中子不带电。</p><p>4种基本作用力：强相互作用力（夸克构成质子和中子，质子和中子构成原子核）、弱相互作用力（使原子具有辐射性）、万有引力、电磁力</p><p>马赫：速度相对于声速的大小。1马赫就是340m&#x2F;s</p><p>由于瑞利散射的强度与波长四次方成反比，所以太阳光谱中波长较短的蓝紫光比波长较长得红光散射更明显，而短波中又以蓝光能量最大，所以在雨过天晴或秋高气爽时（空中较粗微粒比较少，以分子散射为主），在大气分子的强烈散射作用下，蓝色光被散射至弥漫天空，天空即呈现蔚蓝色。</p><h1 id="趣谈"><a href="#趣谈" class="headerlink" title="趣谈"></a>趣谈</h1><p>**万宝路(Marlboro)**香烟品牌,名称来自“Man Always Remember Love Because Of Romance Only“的缩写，即“男人只因浪漫铭记爱情”。</p><p><strong>皮格马利翁效应</strong>的典故取自希腊神话，一位名叫皮格马利翁的雕刻家，爱上了自己的女神雕像，结果雕像真的变成了女神。这一效应用来指代由于心理预期的好或坏，导致结果真的向着这一方向发展，是自我预言的实现的延伸。我们在无意识中，对他人以及自身在他人世界中角色的设定，导致了我们行为和认知沿着这一设定发展。</p><p>来瓶雪花，让我们勇闯天涯。</p><p>解耦：你用水的时候，并不会关心这个水的水源地是丹江口水库还是密云水库。你用电的时候，也不会关心这个电是用山西的煤发出来的，还是用大庆的天然气发出来的。同样，一个理想的云计算系统，底层硬件也不必须使用特定品牌的服务器、交换机。所谓“只要能抓住老鼠，白猫黑猫随你大小便”。也就是说：上层技术和下层技术之间完全没有依赖关系，这就叫做“解耦”。</p><h1 id="职场工作"><a href="#职场工作" class="headerlink" title="职场工作"></a>职场工作</h1><p>工作中的一些谦辞：非常荣幸和大家一起工作。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa 源码解析</title>
      <link href="/2019/09/05/Koa%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/09/05/Koa%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Context-上下文对象"><a href="#Context-上下文对象" class="headerlink" title="Context 上下文对象"></a>Context 上下文对象</h1><p>ctx -&gt; Koa Context<br>ctx.req -&gt; req -&gt; IncommingMessage<br>ctx.res -&gt; res -&gt; ServerResponse </p><p>ctx.req 是 node 原生的，ctx.request 是 koa 封装的请求对象，提供了更高级的 API 和更友好的方法（内部实现是 <code>ctx.req</code>）</p><p>在 lib&#x2F;context.js 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Request delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">delegate</span>(proto, <span class="string">&#x27;request&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;acceptsLanguages&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;acceptsEncodings&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;acceptsCharsets&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;accepts&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">  .<span class="title function_">method</span>(<span class="string">&#x27;is&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;idempotent&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;socket&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;search&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;method&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line">  .<span class="title function_">access</span>(<span class="string">&#x27;accept&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;origin&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;subdomains&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;protocol&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;host&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;hostname&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;URL&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;header&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;headers&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;secure&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;stale&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;fresh&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;ips&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getter</span>(<span class="string">&#x27;ip&#x27;</span>)</span><br></pre></td></tr></table></figure><p>koa 将 request 对象上的方法、访问器、getter 代理到 context 对象上，这使得开发者可以直接使用 ctx.xx 来访问 request.xx</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法委托</span></span><br><span class="line">.<span class="title function_">method</span>(<span class="string">&#x27;accepts&#x27;</span>)</span><br><span class="line">.<span class="title function_">method</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">.<span class="title function_">method</span>(<span class="string">&#x27;is&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种写法效果相同</span></span><br><span class="line">ctx.<span class="property">request</span>.<span class="title function_">accepts</span>(<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">ctx.<span class="title function_">accepts</span>(<span class="string">&#x27;json&#x27;</span>);  <span class="comment">// 更简洁的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问器委托（读写）</span></span><br><span class="line">.<span class="title function_">access</span>(<span class="string">&#x27;method&#x27;</span>)</span><br><span class="line">.<span class="title function_">access</span>(<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line">.<span class="title function_">access</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">.<span class="title function_">access</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都是等价的</span></span><br><span class="line">ctx.<span class="property">request</span>.<span class="property">path</span></span><br><span class="line">ctx.<span class="property">path</span></span><br><span class="line"></span><br><span class="line">ctx.<span class="property">request</span>.<span class="property">method</span> = <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">ctx.<span class="property">method</span> = <span class="string">&#x27;POST&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 委托（只读）</span></span><br><span class="line">.<span class="title function_">getter</span>(<span class="string">&#x27;protocol&#x27;</span>)</span><br><span class="line">.<span class="title function_">getter</span>(<span class="string">&#x27;host&#x27;</span>)</span><br><span class="line">.<span class="title function_">getter</span>(<span class="string">&#x27;hostname&#x27;</span>)</span><br><span class="line">.<span class="title function_">getter</span>(<span class="string">&#x27;header&#x27;</span>)</span><br><span class="line">.<span class="title function_">getter</span>(<span class="string">&#x27;ip&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种写法效果相同</span></span><br><span class="line">ctx.<span class="property">request</span>.<span class="property">ip</span></span><br><span class="line">ctx.<span class="property">ip</span></span><br></pre></td></tr></table></figure><h1 id="洋葱圈的实现"><a href="#洋葱圈的实现" class="headerlink" title="洋葱圈的实现"></a>洋葱圈的实现</h1><p>我们这样使用中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">const</span> rt = ctx.<span class="property">response</span>.<span class="title function_">get</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;rt&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>(); <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>(); <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">const</span> ms = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start; <span class="comment">// 5</span></span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello World&#x27;</span>; <span class="comment">// 6</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>中间件都是<code>async</code>函数，koa 能够保证这些中间件是按照你加入中间件的顺序执行，这到底是怎么做到的？<code>app.use</code>的方法将所有的函数放入了自身维护的<code>middleware</code>数组。<code>app.listen</code>创建了一个<code>httpServer</code>并将<code>onRequest</code>回调指定为<code>app.callback</code>，<code>app.callback</code>主要做了2件事：添加<code>onerror</code>，处理用户请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 组合中间件</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>);</span><br><span class="line">  <span class="comment">// 处理onerror</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">listeners</span>(<span class="string">&#x27;error&#x27;</span>).<span class="property">length</span>) <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onerror</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span>.<span class="title function_">createContext</span>(req, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 请求处理器</span></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出组合中间件的方法中使用了<code>compose</code>，这个函数的实现如下（在 koa-compose 模块中）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">middleware</span>) &#123;</span><br><span class="line">  <span class="comment">// 检测</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware stack must be an array!&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Middleware must be composed of functions!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Promise</span>&#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@api</span> <span class="variable">public</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">i</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">dispatch</span>(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的高阶函数内部递归调用了<code>dispatch</code>函数，一直迭代所有的中间件。本文开篇的那个例子中1处的<code>await next</code>将代码的执行权交给了2处记录下开始时间，接着执行4处的await，将代码的执行权交给了6接下来4处的await执行完了执行5，最后1处的await执行完了，至此中间完成了。</p><p>原理如下：</p><p>首先，我们在写中间时会有<code>await next()</code>的用法（注意，<code>await</code>会等到后面的<code>Promise resolve</code>或<code>reject</code>后才厚向下继续执行），那么执行<code>await next()</code>就会转而执行<code>dispatch(i + 1)</code> ，直到最后一个中间件；当执行到最后一个再执行<code>dispatch</code>时，会触发<code>if(!fn) return Promise.resolve()</code>, 最后一个中间件开始执行<code>await next()</code>后面的逻辑，完成后，执行倒数第二个，依次执行到第一个中间件。</p><p>注意，当中间件中有两处<code>await next()</code>时，会触发<code>if(i &lt;= index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))</code>, 抛出错误。</p><p>这个过程有点像深度优先遍历，递归到树的最深处，然后逐层返回，最后的结果是初始调用第一层的结果（对应在koa中是我们use的第一个中间件）。其实和下面的代码是一个意思：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1 start&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1 end&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2 start&#x27;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2 end&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn3&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">fn1</span>(<span class="function">() =&gt;</span> <span class="title function_">fn2</span>(<span class="function">() =&gt;</span> <span class="title function_">fn3</span>()));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn1 start</span><br><span class="line">fn2 start</span><br><span class="line">fn3</span><br><span class="line">fn2 end</span><br><span class="line">fn1 end</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>整个函数的返回值是最外层函数的值。改写成递归就是如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fns = [fn1, fn2, fn3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">fns</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = fns[i];</span><br><span class="line">    <span class="keyword">if</span> (!fn) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(<span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">dfs</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 可以进一步简化</span></span><br><span class="line">    <span class="comment">// return fn(dfs.bind(null,i+1));</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">compose</span>(fns);</span><br></pre></td></tr></table></figure><h1 id="Koa-和-Express-中间件的区别"><a href="#Koa-和-Express-中间件的区别" class="headerlink" title="Koa 和 Express 中间件的区别"></a>Koa 和 Express 中间件的区别</h1><ol><li>Express 中间件是基于回调函数的，使用 next() 控制流程;中间件按顺序同步执行，直到调用 next() 才会进入下一个中间件;通过 next(err) 传递错误，需要在专门的错误处理中间件中捕获。</li><li>Koa 中间件是基于 async&#x2F;await 的，使用 await next() 控制流程；中间件按顺序执行，但支持“洋葱模型”，即先进入的中间件最后退出（请求在经过中间件的时候会执行 2 次，可以很方便进行前置和后置的处理）；通过 try&#x2F;catch 捕获错误，或使用 Koa 的全局错误处理机制。</li><li>Express 使用 req（请求对象）和 res（响应对象）分别处理请求和响应, 需要在 req 或 res 上挂载数据，手动传递；Koa 使用 ctx（上下文对象）统一处理请求和响应，可以直接在 ctx 上挂载数据（例如：traceId 这种需贯穿整个请求（之后在任何地方进行其他调用都需使用）的属性便可挂载上去），无需手动传递。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息推送系统的设计与实现</title>
      <link href="/2019/09/02/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/02/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所有真理的成长都需要经过 3 个阶段：首先是遭到无情地嘲笑，然后是激烈地反对，最终被当成理所当然所接受。</p></blockquote><h1 id="弹幕系统的技术挑战"><a href="#弹幕系统的技术挑战" class="headerlink" title="弹幕系统的技术挑战"></a>弹幕系统的技术挑战</h1><h2 id="技术复杂度"><a href="#技术复杂度" class="headerlink" title="技术复杂度"></a>技术复杂度</h2><h3 id="系统调用的瓶颈"><a href="#系统调用的瓶颈" class="headerlink" title="系统调用的瓶颈"></a>系统调用的瓶颈</h3><p>以一个直播间为例，假设在线人数为 100W，每秒发送的弹幕数量为 1000 条，据此可以推算出单个直播间的吞吐量要达到 100W * 1000条 &#x3D; 10亿条&#x2F;秒，把问题延伸到 N 个直播间，则系统的吞吐量为 N*10亿&#x2F;秒。</p><p>根据经验值，Linux 系统在处理 TCP 网络调用的时候大概每秒只能处理 100W 左右的包，这么看的话发送一条弹幕就达到了单机的处理能力上限，这是第一个难点。</p><p>解决：假设在线人数为 100W，推送 1 条消息就达到了系统极限，假设推送 100 条消息仍旧使用单机处理，如何优化呢？很简单：将 100 条消息合并成 1 条消息进行发送，这样对于 100W 人在线的系统推送吞吐量<em>固定</em>为每秒 100W 次。当然合并消息不可能无限大，当超过一定<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83">阈值</a>之后，TCP&#x2F;IP 层会进行大包拆分，此时底层实际包频就会超过每秒 100W 次，再次到达系统调用的极限。</p><h3 id="锁瓶颈"><a href="#锁瓶颈" class="headerlink" title="锁瓶颈"></a>锁瓶颈</h3><p>在推送的时候，需要遍历所有的在线连接，这些连接通常放在一个集合里。遍历 100W 个连接去发送消息，肯定需要花费一个可观的时间，而在推送期间客户端仍旧在不停的上线与下线，所以这个集合是需要上锁做并发保护的。可见，遍历期间上锁的时间会非常长，而且只能有一个线程顺序遍历集合，这个耗时是无法接受的。</p><p>解决：在做海量服务架构设计的时候，一个很有用的思路就是：<strong>分而治之</strong>。既然 100W 连接放在一个集合里导致锁粒度太大，那么我们就可以把连接通过哈希的方式散列到多个集合中，每个集合有自己的锁。当我们推送的时候，可以通过多个线程，分别负责若干个集合的推送任务。因为推送的集合不同，所以线程之间没有锁竞争关系。而对于同一个集合并发推送多条不同的消息，我们可以把互斥锁换成读写锁，从而支持多线程并发遍历同一个集合发送不同的消息。其实操作系统管理 CPU 也是分时的，就像我们的推送任务被拆分成若干小集合一样，每个集合只需要占用一点点的时间片快速完成，而多个集合则尽可能的利用多核的优势实现真并行。</p><h3 id="CPU-瓶颈"><a href="#CPU-瓶颈" class="headerlink" title="CPU 瓶颈"></a>CPU 瓶颈</h3><p>一般客户端和服务器是基于 JSON 协议进行通信，给每个客户端推消息的时候需要对消息进行 JSON Encode。当在线连接比较少（比如 1W）而推送消息比较频繁（10W&#x2F;s）的情况下，我们可以计算得到每秒要 json encode 编码的次数是：10000 * 100000 &#x3D; 10^9 次。即便我们提前对 10W 条消息做 json encode 后，再向 1 万个连接做分发，那么每秒也需要 10W 次的编码。JSON 编码是一个纯 CPU 计算行为，非常耗费 CPU，我们仍旧面临不小的优化压力。</p><p>解决：其实当我们通过消息合并的方式减少网络系统调用的时候，我们已经完成了对<strong>sys cpu</strong>的优化，操作系统用来处理网络系统调用的 CPU 时间大幅减少。但是<strong>user CPU</strong>需要我们继续做优化，我们如果在每个连接级别做 json encode，那么 1 条消息就会带来 100 万次 encode，是完全无法接受的性能。因为业务上消息推送分 2 类，一种是按客户端关注的主题做推送，一种是推送给所有客户端。基于上述特点，我们可以把消息合并动作提前到消息入口层，即把近一段时间所有要推往某个主题、推给所有在线的消息做消息合并成 batch，每个batch 可能包含 100 条消息。当 1 个 batch 塞满后或者超时后，经过对其进行一次 json encode 编码后，即可直接向目标客户端做遍历分发。经过消息合并前置，编码的 CPU 消耗不再与在线的连接数有关，也不再直接与要推送的消息条数有关，而是与打包后的 batch 个数有关，具有量级上的锐减效果。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/42c108b0-cf24-11e9-9935-abafe8495676.png" alt="image.png"></p><h2 id="单机架构的瓶颈"><a href="#单机架构的瓶颈" class="headerlink" title="单机架构的瓶颈"></a>单机架构的瓶颈</h2><ul><li>维护海量长连接会花费不少内存</li><li>消息推送瞬时会消耗大量 CPU 资源</li><li>消息推送瞬时带宽高达 400<del>600MB(4</del>6Gbits，一般的服务器网卡是千兆网卡只能跑到 100MB)，<strong>带宽是主要瓶颈</strong>！</li></ul><blockquote><p>HTTP2 支持连接复用，用作 RPC 性能更佳，例如 google 的 gRPC。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/38bbf620-cf26-11e9-9935-abafe8495676.png" alt="image.png"></p><p>上面的这个架构定向向某个用户推送的时候需要将逻辑层的消息广播到网关层，一般可以在逻辑服务器后面加一层 session 层，记录用户在哪个 gateway 上，从而减少不必要的广播。</p><blockquote><p>负载均衡设备为什么不存在性能瓶颈？负载均衡可以配置多个，前端通过 DNS 控制。</p></blockquote><h2 id="pull-or-push"><a href="#pull-or-push" class="headerlink" title="pull or push"></a>pull or push</h2><p>拉模型比较简单，客户端定时轮询获取最新的数据，但是拉模式存在以下弊病：</p><ul><li>如果数据更新频率低，则大多数请求是无效的</li><li>在线数量多，则服务端的查询负载很高（每秒百万次请求，相当于 DDOS 攻击，几乎不可能实现）</li><li>无法满足时效性</li></ul><p>综上所述，推模型比较靠谱。</p><h1 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h1><blockquote><p>Upgrade 是 HTTP 协议中的一个请求头字段，用于客户端向服务器提出升级当前连接协议的请求。通常情况下，它被用来协商从 HTTP&#x2F;1.1 升级到其他协议，如 WebSocket、HTTP&#x2F;2 等。这个机制允许客户端和服务端在不中断现有 TCP 连接的情况下，转换通信协议，从而可以更灵活地支持不同的应用层协议。</p></blockquote><h2 id="通讯流程"><a href="#通讯流程" class="headerlink" title="通讯流程"></a>通讯流程</h2><p>客户端和服务器首先要完成一次握手，握手的本身是基于 HTTP 完成的：客户端首先发起一个 HTTP 请求到服务端，这个请求的特殊之处在于其在 header 中带了 upgrade 字段告诉服务器想升级成 websocket 协议，服务器收到之后就会给客户端发送一个握手的确认 switching(允许向 websocket 协议转换)，协议升级后会继续复用 HTTP 底层的 socket 完成后续通信，服务器和客户端可以进行全双工通信。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/4c2ea510-cd94-11e9-9935-abafe8495676.png" alt="websocket 协议升级流程"></p><p>message 底层被分成多个 Frame 传输，我们编程的时候只需关注 message 即可，至于发送的消息会不会被切分成小的帧是由协议和库本身去做。</p><h2 id="抓包观察"><a href="#抓包观察" class="headerlink" title="抓包观察"></a>抓包观察</h2><p>服务器代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>: <span class="number">7777</span>&#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> seq = <span class="number">0</span>;</span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> <span class="title function_">incoming</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">`echo:<span class="subst">$&#123;message&#125;</span>,now = <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">`heartbeat from server,seq = <span class="subst">$&#123;seq++&#125;</span>,now = <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toString()&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">2e3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> ws;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        d.<span class="property">innerHTML</span> = message;</span></span><br><span class="line"><span class="language-javascript">        output.<span class="title function_">appendChild</span>(d);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;open&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (ws) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7777/connect&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">print</span>(<span class="string">&quot;OPEN&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">print</span>(<span class="string">&quot;CLOSE&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          ws = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">print</span>(<span class="string">&quot;RESPONSE: &quot;</span> + evt.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">print</span>(<span class="string">&quot;ERROR: &quot;</span> + evt.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;PING&quot;</span>, <span class="attr">data</span>: &#123;&#125;&#125;))</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">10000</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;close&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!ws) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;join&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!ws) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">print</span>(<span class="string">&quot;JOIN: &quot;</span> + input.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;JOIN&quot;</span>, <span class="attr">data</span>: &#123;<span class="attr">room</span>: input.<span class="property">value</span>&#125;&#125;));</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;leave&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!ws) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">print</span>(<span class="string">&quot;LEVAE: &quot;</span> + input.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">type</span>: <span class="string">&quot;LEAVE&quot;</span>, <span class="attr">data</span>: &#123;<span class="attr">room</span>: input.<span class="property">value</span>&#125;&#125;));</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">valign</span>=<span class="string">&quot;top&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Click &quot;Open&quot; to create a connection to the server,</span><br><span class="line">      &quot;Send&quot; to send a message to the server and &quot;Close&quot; to close the connection.</span><br><span class="line">      You can change the message and send multiple times.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;open&quot;</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;close&quot;</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认房间&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;join&quot;</span>&gt;</span>JOIN<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;leave&quot;</span>&gt;</span>LEAVE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">valign</span>=<span class="string">&quot;top&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/db29a250-ce5d-11e9-9935-abafe8495676.png" alt="image.png"></p><p>注意 GET 请求头中有个 Upgrade 字段，值为 websocket，响应头中也有个 Upgrade 字段，值为websocket，表示服务器允许客户端进行服务升级，经过这一轮握手协议之后后续就是基于 websocket 通信了。返回码为 101。websocket 的底层最小传输单元是 Frame，见下图：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/f92da7b0-ce5d-11e9-9935-abafe8495676.png" alt="websocket 基于 Frame 传输"></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀系统的设计与实现</title>
      <link href="/2019/08/26/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/08/26/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="特征与难点"><a href="#特征与难点" class="headerlink" title="特征与难点"></a>特征与难点</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/miaosha-qps.png" alt="QPS分析"></p><ul><li>写强一致性：抢购商品的时候不能出现超卖现象</li><li>读弱一致性：可能读到有库存，但是实际下单会失败</li><li>抢购人数远多于库存，读写并发巨大</li><li>库存少导致有效写少（真正形成订单的比较少）</li></ul><p>难点在于极致性能的实现以及高可用的保证。</p><ul><li>高并发下，某个小依赖可能直接造成雪崩</li><li>流量预估难精确，过高也造成雪崩</li><li>分布式集群，机器多，出故障的概率高</li></ul><h1 id="秒杀原理"><a href="#秒杀原理" class="headerlink" title="秒杀原理"></a>秒杀原理</h1><ul><li>合理利用 CDN：例如订单详情页，有效减少回源流量</li><li>Nginx 限流：过载保护</li><li>异步队列：高并发的流量 -&gt; 均匀的流量</li><li>Nginx 负载均衡：接入层分摊流量到<em>无状态</em> service 层提供服务</li></ul><h2 id="CDN原理"><a href="#CDN原理" class="headerlink" title="CDN原理"></a>CDN原理</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/cdn.png" alt="cdn.png"></p><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址.</li><li>LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)</li><li>ROOT DNS将域名授权dns记录回应给 LocalDns</li><li>LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址</li><li>域名授权dns查询域名记录后(一般是<em>CNAME</em>)，回应给 LocalDns</li><li>LocalDns得到域名记录后,向智能调度DNS查询域名的ip地址</li><li>智能调度DNS根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns</li><li>LocalDns 将得到的域名ip地址，回应给用户端</li><li>用户得到域名ip地址后，访问站点服务器</li><li>CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li></ol><p>为了实现对普通用户透明(使用缓存后用户客户端无需进行任何设置)访问，需要使用DNS(域名解析)来引导用户来访问Cache服务器，以实现透明的加速服务. 由于用户访问网站的第一步就是域名解析,所以通过修改dns来引导用户访问是最简单有效的方式.</p><p>对于普通的Internet用户，每个CDN节点就相当于一个放置在它周围的网站服务器. 通过对dns的接管，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求. 由于它离用户更近，因而响应时间必然更快.从上面图中虚线圈起来的那块，就是CDN层,这层是位于客户端和源站之间.</p><p>智能调度DNS（例如F5中的3DNS）是CDN服务中的关键系统.当用户访问加入CDN服务的网站时，域名解析请求将最终由 “智能调度DNS”负责处理。它通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户可以得到快速的服务。同时它需要与分布在各地的CDN节点保持通信，跟踪各节点的健康状态、容量等信息，确保将用户的请求分配到就近可用的节点上。</p><blockquote><p>CNAME即别名(Canonical Name)。可以用来把一个域名解析到另一个域名，当 DNS 系统在查询 CNAME 左面的名称的时候，都会转向 CNAME 右面的名称再进行查询，一直追踪到最后的 PTR 或 A 名称，成功查询后才会做出回应，否则失败。例如，你有一台服务器上存放了很多资料，你使用docs.example.com去访问这些资源，但又希望通过documents.example.com也能访问到这些资源，那么你就可以在您的DNS解析服务商添加一条CNAME记录，将documents.example.com指向docs.example.com，添加该条CNAME记录后，所有访问documents.example.com的请求都会被转到docs.example.com，获得相同的内容。接入CDN时，在CDN提供商控制台添加完加速域名后，您会得到一个CDN给您分配的CNAME域名， 您需要在您的DNS解析服务商添加CNAME记录，将自己的加速域名指向这个CNAME域名，这样该域名所有的请求才会都将转向CDN的节点，达到加速效果。</p></blockquote><h2 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并<strong>允许突发数据</strong>的发送。</p><p>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。（因此，如果桶中有足够多的令牌，就可以以峰值流量进行处理，但是长期来看流量速率是恒定的）从原理上看，令牌桶算法和漏桶算法是相反的，一个“进水”，一个是“漏水”。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/rate_limit_token_bucket.png" alt="rate_limit_token_bucket.png"></p><p>Google 的 Guava 包中的 RateLimiter 类就是令牌桶算法的实现。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>这种算法可以<em>强制限制数据的传输速率</em>，而令牌桶算法除了能够限制<strong>平均传输速率</strong>，还允许<strong>一定程度的突发传输</strong>。</p><p>漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。<br>如图所示，把请求比作是水，水来了都先放进桶里，并以限定的速度出水，当水来得过猛而出水不够快时就会导致水直接溢出，即拒绝服务。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/rate_limit_leak_bucket.png" alt="rate_limit_leak_bucket.png"></p><p>可以看出，漏桶算法可以很好的控制流量的访问速度，一旦超过该速度就拒绝服务。</p><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。</p><p>需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。</p><p>应用层面可以使用计数器限流</p><p><a href="https://www.cnblogs.com/biglittleant/p/8979915.html">nginx限流配置</a></p><h2 id="CDN加速的原理"><a href="#CDN加速的原理" class="headerlink" title="CDN加速的原理"></a>CDN加速的原理</h2><p><a href="https://www.jianshu.com/p/1dae6e1680ff">CDN加速原理</a></p><h2 id="常用负载均衡算法"><a href="#常用负载均衡算法" class="headerlink" title="常用负载均衡算法"></a>常用负载均衡算法</h2><p>例如nginx作为接口接入层主要有以下的几种算法</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><h3 id="带权轮询"><a href="#带权轮询" class="headerlink" title="带权轮询"></a>带权轮询</h3><p>这种算法用得比较多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ServerWeight</span> = &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="number">1</span>, <span class="comment">// A服务器权重1</span></span><br><span class="line">    <span class="attr">B</span>: <span class="number">3</span> <span class="comment">// B服务器权重3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wA = wB = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">weightRoundRobin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wA += <span class="title class_">ServerWeight</span>.<span class="property">A</span>;</span><br><span class="line">    wB += <span class="title class_">ServerWeight</span>.<span class="property">B</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wA &gt; wB) &#123;</span><br><span class="line">        target = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        wA -= <span class="title class_">ServerWeight</span>.<span class="property">A</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">        wB -= <span class="title class_">ServerWeight</span>.<span class="property">B</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码可以用爬楼梯来形象理解：有些人一次能走3步，但是有些人一次只能走一步，每次取走在前面的同学，走得最快的人被取到的次数越多。</p><h3 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h3><p>一个非常大的缺陷：当一个IP作为一个学校的公网出口的时候，命中到后台的服务器的流量可能非常大，并不是一种均匀的策略，比较少使用。</p><h1 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h1><ul><li>减少第三方依赖，同时自身服务部署也要做到隔离</li><li>压测、降级、限流方案、确保核心服务可用</li><li>需要健康度检查机制（分布式环境中及时摘除有问题的节点），整个链路避免单点</li><li>缩短请求访问路径、减少 IO</li><li>减少接口数、降低吞吐数据量、减少请求次数</li></ul><h1 id="秒杀服务核心实现"><a href="#秒杀服务核心实现" class="headerlink" title="秒杀服务核心实现"></a>秒杀服务核心实现</h1><ul><li>满足基本需求，做到单服务的极致性能</li><li>请求链路优化，从客户端到服务器每层的优化（流量是一个逐层衰减的过程）</li></ul><h2 id="扣库存的方案"><a href="#扣库存的方案" class="headerlink" title="扣库存的方案"></a>扣库存的方案</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/miaosha-koukucun.png" alt="扣库存的方案"></p><p>方案一：其中创建订单、扣库存在一个事务中，一个订单肯定会减一个库存，不会超卖，但是可能存在恶意下单但是不支付，这样商品就卖不出去了<br>方案二：支付和扣库存放在一个事务中，可以有效解决方案一中的订单超卖问题，但是可能存在订单超卖的问题，有一部分订单必然是支付不了的<br>方案三：这种方案并发量更大，因为扣库存相对来讲是一个比较简单耗时少的操作，可以尽早拦截无效请求。设置一个订单超时，如果不支付的话订单自动取消</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c745dc10-c8de-11e9-84dc-5b83b5de5b34.png" alt="扣库存的2种实现"></p><p>去IO之后的减库存直接修改的是内存，并且推送到MQ中的数据只是扣库存成功的用户。性能非常高，IO非常低，并且可以解耦创建订单和减库存。</p><p>单机器如果扛不住请求（即使是内存也有QPS上限）可以把库存分摊到多台服务器。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/91abb690-c8e0-11e9-84dc-5b83b5de5b34.png" alt="库存分摊到多个节点"></p><p>入上图所示，假设有1000个库存，可以10台机器各分配100个库存，通过接入层进行负载均衡。即使客户端来了100W的请求，均摊到每个减库存的服务每个处理10W的量，最后流入MQ中的QPS最多为1000。大部分流量被拦截了。这种方式肯定不会超卖，但是可能存在减库存的时候挂了导致<em>少卖</em>。我们可以采用如下的方式：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/2fb659d0-c9a4-11e9-84dc-5b83b5de5b34.png" alt="预留buff统一减库存"></p><p>统一库存如果为1000，有10个节点的本地库存，这10个节点库存总数必须大于1000，最理想的状态是，某个节点挂掉后，其它9个节点的库存加起来还能等于1000，如果没有节点挂点，所有的请求在统一库存那里也会被合理拦截，最终控制在1000，本地库存主要是为了减轻库存查询压力，大于等于实际的库存即可，但是不能超过太多。</p><p>对于这样的恶意用户可以记录下来，让其在以后的秒杀中丧失资格。</p><ol><li>初始化库存到本地</li><li>本地减库存，成功则进行统一减库存（相当于做了一个汇总，防止少卖和超卖），失败则返回</li><li>统一减库存(边界情况下超卖可以用redis lua脚本解决)成功才写入MQ,异步创建订单</li><li>告知用户抢购成功</li></ol><h2 id="抢购进度查询的实现"><a href="#抢购进度查询的实现" class="headerlink" title="抢购进度查询的实现"></a>抢购进度查询的实现</h2><p>假设成功创建订单的有1000个用户。维护一个容量为1000的数组记为A和一个容量为1000的哈希表记为B。</p><ol><li>数组A存储排队中，待创建订单的用户，哈希表B存储uid对应的在A中的索引</li><li>每次从数组A中依次消费数据，并记录最近的消费索引值X</li><li>当用户来查排队进度的时候从哈希表B中取出该uid对应的存储索引值Y</li><li>Y - X即为排队进度</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mp.weixin.qq.com/s/veK1nn_0O5HYwkvAEZJG9w">https://mp.weixin.qq.com/s/veK1nn_0O5HYwkvAEZJG9w</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短地址服务的设计与实现</title>
      <link href="/2019/08/26/%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/08/26/%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>有不少网站可以提供长链转短链的服务,例如<a href="http://www.sina.lt/">新浪短地址服务</a>、<a href="https://bitly.com/">bitly</a>。背后的原理其实是将长链和短链进行一一映射。换而言之，各家短链服务商的短链和长链是一一对应的。其中的关键点在于如何根据长链生成短链，以及当用户访问短链后怎么处理。</p><h1 id="如何生成短地址"><a href="#如何生成短地址" class="headerlink" title="如何生成短地址"></a>如何生成短地址</h1><p>比较直观想到的解法是使用哈希函数，但是无论怎样构造哈希函数，都存在<em>哈希碰撞</em>的问题。再次想到碰撞之后可以在 hash 字符串后面补充其他字符串来实现，但是需要补充多少位呢？这种方案显然不是那么方便。联想到全局唯一，以及数据存储我们很容易想到数据库的自增 id，其实这样也是可以的，这里为了实现简单(主要是天然的过期时间)，采用了 redis 来存储数据，其 key 设计如下：</p><p>globalId:全局自增 id，用于保证短链的唯一性<br>shortToLong:短地址到长地址的映射,key 为短地址，可以很方便通过短地址找到长地址<br>longToShortInfo:长链到短链的映射，如果这个键存在值就无需重复生成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Redis</span> = <span class="built_in">require</span>(<span class="string">&#x27;ioredis&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> base62 = <span class="built_in">require</span>(<span class="string">&quot;base62&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortLinkService</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">redis</span> = <span class="keyword">new</span> <span class="title class_">Redis</span>(<span class="string">&#x27;192.168.3.118&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 长地址 -&gt; 短地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">longUrlToShortLink</span>(<span class="params">url, ttl</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> linkInfo = (<span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">exists</span>(<span class="string">`longToShortInfo:<span class="subst">$&#123;url&#125;</span>`</span>)) &amp;&amp; <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">hgetall</span>(<span class="string">`longToShortInfo:<span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span> (linkInfo) &#123;</span><br><span class="line">            <span class="keyword">return</span> linkInfo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> id = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">incr</span>(<span class="string">&#x27;globalID&#x27;</span>);</span><br><span class="line">        linkInfo = &#123;</span><br><span class="line">            <span class="attr">shortLink</span>: base62.<span class="title function_">encode</span>(id),</span><br><span class="line">            <span class="attr">created</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">            ttl</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 存储短地址对应的长地址</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">set</span>(<span class="string">`shortToLong:<span class="subst">$&#123;linkInfo.shortLink&#125;</span>`</span>, url,<span class="string">&#x27;EX&#x27;</span>, ttl);</span><br><span class="line">        <span class="comment">// 存储长地址对应的短地址（防止重复生成）</span></span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">hmset</span>(<span class="string">`longToShortInfo:<span class="subst">$&#123;url&#125;</span>`</span>, linkInfo);</span><br><span class="line">        <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">expire</span>(<span class="string">`longToShortInfo:<span class="subst">$&#123;url&#125;</span>`</span>,ttl);</span><br><span class="line">        <span class="keyword">return</span> linkInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过短地址反解长地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">resolveShortLink</span>(<span class="params">shortLink</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">redis</span>.<span class="title function_">get</span>(<span class="string">`shortToLong:<span class="subst">$&#123;shortLink&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实短地址的核心就是将一个地址对应了一个整数，之所以将 id 转化为 base62 编码是因为 base62 将每个短链对应一个 62 进制的数(数字 10 个，大小写字母一共 52)。这样单个位能表示的信息量就更多了，意味着我们可以用更少的位数表示更大的整数。</p><h1 id="如何解析短连接"><a href="#如何解析短连接" class="headerlink" title="如何解析短连接"></a>如何解析短连接</h1><p>当收短链转长链的请求的时候去 redis 中查找短链对应的长链，并且向浏览器发送<em>302跳转</em>。注意不使用 301 的原因是 301 是永久重定向，浏览器会缓存（虽然 301 符合 HTTP 语义并且对服务器的压力更小），这样我们就没法追踪用户了。</p><h1 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h1><p>上面的代码的问题是我们的发号器是一个单点。如果要做成分布式就需要多个节点保持同步加 1，这个以 CAP 理论来看本身是不可能真正做到的，况且存在比较大的数据冗余。其实这个问题的解决非常简单，我们可以退一步考虑，我们是否可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，我们可以实现 1000 个逻辑发号器，分别发尾号为 0 到 999 的号。每发一个号，每个发号器加 1000，而不是加 1。这些发号器独立工作，互不干扰即可。而且在实现上，也可以先是逻辑的，真的压力变大了，再拆分成独立的物理机器单元。1000 个节点，估计对人类来说应该够用了。如果你真的还想更多，理论上也是可以的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://jiayi797.github.io/2018/02/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9FTiny-URL/">系统设计-设计短网址系统Tiny-URL</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常用套路</title>
      <link href="/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/"/>
      <url>/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>墨菲定理：任何事情都没有表面看起来那么简单；所有的事情都会比你预估的时间长；会出错的事情总会出错；你总是担心的事情，它总会发生的。</p></blockquote><h1 id="如何规范写日志"><a href="#如何规范写日志" class="headerlink" title="如何规范写日志"></a>如何规范写日志</h1><h2 id="日志要有分隔符"><a href="#日志要有分隔符" class="headerlink" title="日志要有分隔符"></a>日志要有分隔符</h2><p>大多数时候使用<code>|</code>作为分隔符。分析数据的时候直接用分隔符拆分对应的字段和属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 正确例子</span><br><span class="line">类名|方法名|输入参数|输出参数</span><br><span class="line"># 错误例子1（不用分隔符）</span><br><span class="line">类名方法名输入参数输出参数</span><br><span class="line"># 错误例子2（用多种分隔符）</span><br><span class="line">类名#方法名 输入参数|输出参数</span><br></pre></td></tr></table></figure><h2 id="通过UUID编号来保证日志的连贯性"><a href="#通过UUID编号来保证日志的连贯性" class="headerlink" title="通过UUID编号来保证日志的连贯性"></a>通过UUID编号来保证日志的连贯性</h2><p>每次请求都应该有一个唯一编号，每记录一次日志还应该有一个唯一编号。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api.ERROR: 79a8ea37dceff105|0|responseObj is error:&#123;&quot;return_code&quot;:&quot;SUCCESS&quot;,&quot;return_msg&quot;:&quot;OK&quot;&#125;</span><br><span class="line">api.ERROR: 79a8ea37dceff105|1|App\Request|&#123;&quot;subject&quot;:&quot;201906179ae&quot;&#125;</span><br></pre></td></tr></table></figure><p><code>79a8ea37dceff105</code>是本次请求的全局uuid，0,1表示记录的顺序编号。这样能保证一次请求的所有日志都<em>可追踪</em>，可查看<em>链路信息</em>。下面是一个简单的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">uuid</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.uuid&#125;</span>|<span class="subst">$&#123;<span class="variable language_">this</span>.id++&#125;</span>|<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印日志的时候会自动添加请求编号实现日志链路的追踪。</p><h2 id="对于数组、对象类型统一用JSON格式"><a href="#对于数组、对象类型统一用JSON格式" class="headerlink" title="对于数组、对象类型统一用JSON格式"></a>对于数组、对象类型统一用JSON格式</h2><p>比较通用，方便解析。特别是添加字段的时候节省大量的维护成本。</p><h2 id="重要日志要脱敏"><a href="#重要日志要脱敏" class="headerlink" title="重要日志要脱敏"></a>重要日志要脱敏</h2><p>用户绑定手机号或者邮箱时，会把手机号和邮箱作为参数传到服务端，我们在记录日志时应该把用户手机号和邮箱做脱敏处理，比如中间几位用*号代替。还有密码，身份证等敏感信息更要脱敏。日志是最容易泄露的数据，很难去保护，如果哪天大量用户的手机号等信息泄露可能就是日志未脱敏惹的祸，这个严重的大锅只能自己背。</p><h1 id="怎么限制文件上传大小？原理是什么"><a href="#怎么限制文件上传大小？原理是什么" class="headerlink" title="怎么限制文件上传大小？原理是什么"></a>怎么限制文件上传大小？原理是什么</h1><p>express中使用的是<a href="https://github.com/expressjs/multer">multer</a>处理文件上传(multipart&#x2F;form-data)，用户上传大文件不仅会占用大量的内存资源，也会浪费带宽和磁盘。multer内部依赖的是busboy，这是一个解析stream为HTML的模块，代码比较简单：Busboy继承了可写流，并重写了<code>_write</code>方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Busboy</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Busboy</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Busboy</span>(opts);</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">highWaterMark</span> !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="title class_">WritableStream</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, &#123; <span class="attr">highWaterMark</span>: opts.<span class="property">highWaterMark</span> &#125;);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="title class_">WritableStream</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_done</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_finished</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">opts</span> = opts;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">headers</span> &amp;&amp; <span class="keyword">typeof</span> opts.<span class="property">headers</span>[<span class="string">&#x27;content-type&#x27;</span>] === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">parseHeaders</span>(opts.<span class="property">headers</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing Content-Type&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inherits</span>(<span class="title class_">Busboy</span>, <span class="title class_">WritableStream</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Busboy</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_write</span> = <span class="keyword">function</span>(<span class="params">chunk, encoding, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_parser</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">cb</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not ready to parse. Missing Content-Type?&#x27;</span>));</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span>.<span class="title function_">write</span>(chunk, cb);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在parseHeaders方法中根绝HTTP的header选择合适的parser:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Busboy</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">parseHeaders</span> = <span class="keyword">function</span>(<span class="params">headers</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (headers[<span class="string">&#x27;content-type&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> parsed = <span class="title function_">parseParams</span>(headers[<span class="string">&#x27;content-type&#x27;</span>]),</span><br><span class="line">        matched, type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable constant_">TYPES</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      type = <span class="variable constant_">TYPES</span>[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> type.<span class="property">detect</span> === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        matched = type.<span class="title function_">detect</span>(parsed);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        matched = type.<span class="property">detect</span>.<span class="title function_">test</span>(parsed[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (matched)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">      <span class="keyword">var</span> cfg = &#123;</span><br><span class="line">        <span class="attr">limits</span>: <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">limits</span>,</span><br><span class="line">        <span class="attr">headers</span>: headers,</span><br><span class="line">        <span class="attr">parsedConType</span>: parsed,</span><br><span class="line">        <span class="attr">highWaterMark</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">fileHwm</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">defCharset</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">preservePath</span>: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">highWaterMark</span>)</span><br><span class="line">        cfg.<span class="property">highWaterMark</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">highWaterMark</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">fileHwm</span>)</span><br><span class="line">        cfg.<span class="property">fileHwm</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">fileHwm</span>;</span><br><span class="line">      cfg.<span class="property">defCharset</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">defCharset</span>;</span><br><span class="line">      cfg.<span class="property">preservePath</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">preservePath</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="title function_">type</span>(<span class="variable language_">this</span>, cfg);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported content type: &#x27;</span> + headers[<span class="string">&#x27;content-type&#x27;</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般上传文件的content-type是multipart，所以调用的是Multipart，先看下这个类的初始化，中间有一个计算文件限制大小的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileSizeLimit = (limits &amp;&amp; <span class="keyword">typeof</span> limits.<span class="property">fileSize</span> === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">                       ? limits.<span class="property">fileSize</span></span><br><span class="line">                       : <span class="title class_">Infinity</span>)</span><br></pre></td></tr></table></figure><p>上面计算的这个文件大小阈值会在onData回调函数中用到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onData = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((nsize += data.<span class="property">length</span>) &gt; fileSizeLimit) &#123;</span><br><span class="line">        <span class="keyword">var</span> extralen = (fileSizeLimit - (nsize - data.<span class="property">length</span>));</span><br><span class="line">        <span class="keyword">if</span> (extralen &gt; <span class="number">0</span>)</span><br><span class="line">            file.<span class="title function_">push</span>(data.<span class="title function_">slice</span>(<span class="number">0</span>, extralen));</span><br><span class="line">        file.<span class="title function_">emit</span>(<span class="string">&#x27;limit&#x27;</span>);</span><br><span class="line">        file.<span class="property">truncated</span> = <span class="literal">true</span>;</span><br><span class="line">        part.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!file.<span class="title function_">push</span>(data))</span><br><span class="line">        self.<span class="property">_pause</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出当文件大小超过限制的时候<em>移除了data的事件监听</em>，从而后续不会触发data事件了，并且触发了limit，事件，这个事件在multer层接收，并返回错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileStream.<span class="title function_">on</span>(<span class="string">&#x27;limit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    aborting = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">abortWithCode</span>(<span class="string">&#x27;LIMIT_FILE_SIZE&#x27;</span>, fieldname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将错误回调到express中返回给前端。原理就是流式读取，当发现读取的字节数超过限制的时候立即结束，关闭流，并且报错。</p><h1 id="如何理解-NIO-中的-Selector"><a href="#如何理解-NIO-中的-Selector" class="headerlink" title="如何理解 NIO 中的 Selector"></a>如何理解 NIO 中的 Selector</h1><p>selector是多路复用器，是NIO中的核心。</p><h1 id="API-网关有什么用"><a href="#API-网关有什么用" class="headerlink" title="API 网关有什么用"></a>API 网关有什么用</h1><p>SpringCloud中的API网关可以实现认证登陆、授权、限流、日志、监控。常见的组件有：</p><ul><li>基于nginx的二次开发：KONG,API Umbrella</li><li>Zuul:netflix提供的，包括Zuul1,Zuul2</li><li>Spring Cloud Gateway</li><li>Linkerd</li></ul><h1 id="如何进行接口的鉴权"><a href="#如何进行接口的鉴权" class="headerlink" title="如何进行接口的鉴权"></a>如何进行接口的鉴权</h1><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>由于HTTP的无状态性，客户端需要携带凭证来调用接口。传统web依赖cookie和session。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/027661b0-d1d6-11e9-9676-959a1e7188dd.png" alt="image.png"></p><p>而原生app不是基于浏览器的，常用的解决方案是<a href="https://jwt.io/">JWT</a>。它的原理是服务端认证完成后生成一个JSON对象，返回给用用户，后续客户端的所有请求都会带上这个JSON对象。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ea98cdc0-d1d6-11e9-9676-959a1e7188dd.png" alt="image.png"></p><p>如上图所示，一个JWT分为3个部分：Header,Payload,Signature。左边的字符串以<code>.</code>分割后解码（Base64）可以得到右边的部分。其中最关键的是Signature：编码后的header和编码后的payload以及一个秘钥使用header中指定的签名算法进行签名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature = <span class="title class_">HMACSHA256</span>(<span class="title function_">base64Encode</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64Encode</span>(payload),secert)</span><br></pre></td></tr></table></figure><p>因为秘钥secert保存在服务器，即使别人拿到之后篡改了token中的数据，整个字符串就发生了变化，服务端就会鉴权失败，这样就可以保证安全性。一个基于Koa的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;sdfihu83u84283&amp;^$#43243#@@&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ApiError，业务中直接throw，经过koa的错误处理中间件统一处理，不用再controller中手动构造JSON返回了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123;code, message, httpStatus&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">code</span> = code;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">httpStatus</span> = httpStatus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ERRORS</span> = &#123;</span><br><span class="line">  <span class="attr">AUTH_FAILURE</span>: &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;认证失败，非法token&#x27;</span>,</span><br><span class="line">    <span class="attr">httpStatus</span>: <span class="number">401</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户权限的中间件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userAuth</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = ctx.<span class="property">query</span>.<span class="property">token</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, privateKey);</span><br><span class="line">    ctx.<span class="property">state</span>.<span class="property">uid</span> = <span class="built_in">parseInt</span>(decoded.<span class="property">uid</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApiError</span>(<span class="variable constant_">ERRORS</span>.<span class="property">AUTH_FAILURE</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>([<span class="string">&#x27;/users&#x27;</span>, <span class="string">&#x27;/admin&#x27;</span>], userAuth);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;uid, password&#125; = ctx.<span class="property">query</span>;</span><br><span class="line">  <span class="comment">// 验证uid和密码，通过后下发token，客户端拿到token后可以放到自己的本地缓存中，以后请求的时候每次带上这个token即可</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123;uid&#125;, privateKey, &#123;<span class="attr">expiresIn</span>: <span class="string">&#x27;2h&#x27;</span>&#125;);</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用户授权中间件通过后执行下面的逻辑</span></span><br><span class="line">  <span class="keyword">const</span> uid = ctx.<span class="property">state</span>.<span class="property">uid</span>;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    uid,</span><br><span class="line">    <span class="attr">uname</span>: <span class="string">&#x27;公孙龙&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">32</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;code, message, httpStatus&#125; = err;</span><br><span class="line">      httpStatus = httpStatus || <span class="number">500</span>;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123;code, message&#125;;</span><br><span class="line">      ctx.<span class="property">status</span> = httpStatus;</span><br><span class="line">      <span class="comment">// 做一些定制化处理</span></span><br><span class="line">      <span class="comment">// if (err instanceof ApiError) &#123;</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>())</span><br><span class="line">  .<span class="title function_">listen</span>(<span class="number">9999</span>);</span><br></pre></td></tr></table></figure><p>进行统一错误处理的时候其实遇到了一个坑：原先采用的不是错误处理中间件而是使用监听koa的全局onerror事件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>,<span class="function">(<span class="params">err,ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;这句话会执行，error occur&#x27;</span>,err);</span><br><span class="line">    ctx.<span class="property">body</span> = &#123;<span class="attr">message</span>:<span class="string">&#x27;这两句话不会执行&#x27;</span>&#125;;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是在路由中抛出错误的时候捕获到了错误，但是前端还是得到的字符串是<code>Internal Server Error</code>，状态码也是500，仔细查看源码发现<strong>koa对于每个请求中的错误调用的是其Context上的onerror</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Handle request in callback.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.<span class="property">res</span>;</span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onerror</span> = err =&gt; ctx.<span class="title function_">onerror</span>(err);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleResponse</span> = (<span class="params"></span>) =&gt; <span class="title function_">respond</span>(ctx);</span><br><span class="line">    <span class="title function_">onFinished</span>(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fnMiddleware</span>(ctx).<span class="title function_">then</span>(handleResponse).<span class="title function_">catch</span>(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Default error handling.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">onerror</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t do anything if there is no error.</span></span><br><span class="line">    <span class="comment">// this allows you to pass `this.onerror`</span></span><br><span class="line">    <span class="comment">// to node-style callbacks.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> <span class="title class_">Error</span>)) err = <span class="keyword">new</span> <span class="title class_">Error</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;non-error thrown: %j&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> headerSent = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">headerSent</span> || !<span class="variable language_">this</span>.<span class="property">writable</span>) &#123;</span><br><span class="line">        headerSent = err.<span class="property">headerSent</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, err, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothing we can do here other</span></span><br><span class="line">    <span class="comment">// than delegate to the app-level</span></span><br><span class="line">    <span class="comment">// handler and log.</span></span><br><span class="line">    <span class="keyword">if</span> (headerSent) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; res &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first unset all headers</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res.<span class="property">getHeaderNames</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        res.<span class="title function_">getHeaderNames</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> res.<span class="title function_">removeHeader</span>(name));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="property">_headers</span> = &#123;&#125;; <span class="comment">// Node &lt; 7.7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then set those specified</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">set</span>(err.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// force text/plain</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ENOENT support</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;ENOENT&#x27;</span> == err.<span class="property">code</span>) err.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default to 500</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;number&#x27;</span> != <span class="keyword">typeof</span> err.<span class="property">status</span> || !statuses[err.<span class="property">status</span>]) err.<span class="property">status</span> = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// respond</span></span><br><span class="line">    <span class="keyword">const</span> code = statuses[err.<span class="property">status</span>];</span><br><span class="line">    <span class="keyword">const</span> msg = err.<span class="property">expose</span> ? err.<span class="property">message</span> : code;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = err.<span class="property">status</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(msg);</span><br><span class="line">    res.<span class="title function_">end</span>(msg);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>ctx中的onerror事件通过<code>this.app.emit(&#39;error&#39;, err, this);</code>将错误委托给application，接下来移除了httpHeaders，设置http状态码，最后最关键的一句话是<code>res.end(msg)</code>，这句话关闭http的输入流，所以即使我们后面自己设置ctx.body也不会响应任何信息给前端了，而msg默认就是<strong>Internal Server Error</strong>。所以这里使用application的的onerror事件处理错误其实是有坑的，而对于ctx的onerror方法这是个私有api官方并没有提供重写的方法。所以错误处理还是尽量选用中间件吧。</p><h1 id="系统调优"><a href="#系统调优" class="headerlink" title="系统调优"></a>系统调优</h1><ul><li>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。说明：操作系统默认 240s 后才会关闭 time_wait 状态的连接。在高并发访问下，服务器端会因为处于 time_wait 的连接数过多，而无法建立新的连接，所以需要在服务器上调小此等待值。</li><li>给 JVM 设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。</li><li>在线上生产环境，JVM 的 Xms 和 Xms 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</li></ul><h1 id="为什么-DNS-服务器要采用分层结构"><a href="#为什么-DNS-服务器要采用分层结构" class="headerlink" title="为什么 DNS 服务器要采用分层结构"></a>为什么 DNS 服务器要采用分层结构</h1><p>互联网的规模太大，域名数量更是不胜枚举。一台DNS Server存储是不现实的。因此DNS在设计的时候就是分层架构，每一部分存储下一级的相关信息。</p><p>举个例子，我们想知道 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址是什么，将这个请求发送给了我们的 DNS Server。</p><p>DNS Server 需要先问根域名服务器，谁负责管理 .com？然后再问 .com 域名服务器，谁负责管理 example.com？最后，再问 example.com 域名服务器，<a href="http://www.example.com/">www.example.com</a> 的 IP 地址是什么，从而获得答案返回给我们。</p><p>以上就是域名的分级架构，域名查询需要从根开始，一级一级向下，直到找到答案。当然，因为域名查询是一个高频词的动作，无时无刻都在发生，如果每次都是这样一层一层获取，效率将十分低下，因此，DNS 系统中<em><strong>大量使用缓存</strong></em>，每一个中间环节都会缓存相关结果来节省时间提高效率。在不考虑缓存的情况下，我们每次都需要询问根域名服务器，那么DNS服务器是如何知道根域名服务器的地址呢？它其实采用了一个非常简单的做法——使用配置文件写死。全世界一共13组根域名服务器：<code>[a-m].root-servers.net</code>。IINA提供的<a href="http://www.internic.net/domain/named.root">配置文件</a>。下载下来之后配置相关的DNS软件即可。</p><h2 id="DNS-域名解析的流程"><a href="#DNS-域名解析的流程" class="headerlink" title="DNS 域名解析的流程"></a>DNS 域名解析的流程</h2><ol><li>检查浏览器缓存</li><li>检查 OS 缓存</li><li>检查 hosts 文件</li><li>请求本地 DNS 服务器</li><li>请求根域名服务器</li></ol><p>DNS 查询的方式可以分为迭代查询和递归查询。</p><ul><li>迭代查询：向 DNS 服务器查询的时候如果对方无法给出答案，会返回<strong>下一级服务器的地址</strong>，由解析器自行继续查询</li><li>递归查询：客户端向 DNS 服务器（例如 ISP 的 DNS）发起请求后，<strong>必须返回最终答案</strong>。期间解析器会代替客户端完成所有层级的查询。</li></ul><p>为什么需要 2 种查询？</p><ul><li>递归查询：简化客户端逻辑，适合终端用户</li><li>迭代查询：分散 DNS 层级压力，避免根&#x2F;TLD 服务器过载。</li></ul><h1 id="CDN-的原理以及如何更新缓存"><a href="#CDN-的原理以及如何更新缓存" class="headerlink" title="CDN 的原理以及如何更新缓存"></a>CDN 的原理以及如何更新缓存</h1><p><a href="https://zhuanlan.zhihu.com/p/113037678">CDN原理简介</a></p><p>更新缓存本质上回源操作，一般的CDN控制台都有这个功能。</p><h1 id="谈谈-TCP-中的状态机"><a href="#谈谈-TCP-中的状态机" class="headerlink" title="谈谈 TCP 中的状态机"></a>谈谈 TCP 中的状态机</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3b1b1020-df5e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待来自远程TCP应用程序的请求</td></tr><tr><td>SYN_SENT</td><td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td></tr><tr><td>SYN-RECEIVED</td><td>该端点已经接收到连接请求并发送确认。该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td></tr><tr><td>ESTABLISHED</td><td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td></tr><tr><td>FIN_WAIT_1</td><td>等待来自远程TCP的终止连接请求或终止请求的确认</td></tr><tr><td>FIN_WAIT_2</td><td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td></tr><tr><td>CLOSE_WAIT</td><td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td></tr><tr><td>CLOSING</td><td>等待来自远程TCP的连接终止请求确认</td></tr><tr><td>LAST_ACK</td><td>等待先前发送到远程TCP的连接终止请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td></tr></tbody></table><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ul><li>第一次握手：客户端发送 SYN 包（SYN &#x3D; J）,并进入 SYN_SENT 状态，等待服务器确认。</li><li>第二次握手：服务端收到 SYN 包，确认客户端的 SYN（ACK &#x3D; J + 1），同时发送自己的 SYN 包(SYN &#x3D; k)，即服务器发送 SYN + ACK 包，此时服务器进入 SYN_RCVD 状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK 包,向服务器发送确认包(ACK &#x3D; K + 1)。此包发送完毕后客户端和服务器进入 ESTABLISHED 状态，握手完成。</li></ul><p>下图显示了 TCP 三次握手的过程，以及客户端和服务端状态的变化。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/e5993bb0-df60-11e9-8e7b-996bccbf78ea.png" alt="三次握手"></p><blockquote><p>如果在握手的过程中，某个阶段莫名中断，TCP 会再次以相同的顺序发送相同的数据包。</p></blockquote><h2 id="半连接队列是什么"><a href="#半连接队列是什么" class="headerlink" title="半连接队列是什么"></a>半连接队列是什么</h2><p>服务器第一次收到客户端的SYN之后就会进入到SYN_RCVD状态，此时双方还没有完全建立连接，服务器会把这种状态下的请求放入到一个队列中，这种队列就是<strong>半连接队列</strong>。与此对应，全连接队列指的就是已经完成3次握手，建立起连接的请求。<strong>如果队列满了（backlog）就可能出现丢包</strong>。</p><blockquote><p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过<strong>系统规定的最大重传次数</strong>，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p></blockquote><p>正因为TCP设计的有这些缺陷，有一种针对半连接的攻击叫做SYN攻击，大量构造三次握手中的第一次握手包SYN包浪费服务器CPU和内存资源，造成半连接队列溢出从而正常客户端发送的请求直接被服务器丢了，这样对于正常客户端服务就不可用了，检测SYN攻击也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | grep SYN_RECV</span><br></pre></td></tr></table></figure><p>当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p><h3 id="为什么需要3次握手"><a href="#为什么需要3次握手" class="headerlink" title="为什么需要3次握手"></a>为什么需要3次握手</h3><p>为什么要三次握手，我握两次不行吗？我觉得我说发，你说好，不就完了吗，非要矫情一下，握第三次手的意义是什么？</p><p>首先我们先来理解一下为什么需要握手？</p><p>客户端和服务器端通信前需要连接，而”握手“作用就是为了证明，客户端的发送能力和服务器端的接受能力都是正常的，这是”握手“来达到的目的。</p><p>第一次握手:客户端发送网络包，服务器端收到了，这样服务器端就能证明：客户端的发送能力、以及服务器端的接收能力都是正常的。</p><p>第二次握手:服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 <strong>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</strong></p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7748f470-896a-11ea-b9d1-b352894464ae.png" alt="image.png"></p><ul><li>第一次挥手：客户端主动关闭方发送一个FIN（此报文中指定一个序列号），此时客户端处于 FIN_WAIT1 状态。用来关闭客户端到服务器端的数据传送，也就是客户端告诉服务器端：我已经不会再给你发数据了， (当然，在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 确认报文，客户端依然会重发这些数据)，但是，<strong>此时客户端还可以接受数据</strong>。</li><li>第二次挥手:服务端收到 FIN 包后，发送一个 ACK 给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）.此时服务器处于 CLOSE_WAIT 状态。</li><li>第三次挥手：服务器端发送一个 FIN，用来关闭服务器端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发送数据了！！！这一次其实就和客户端第一次挥手一样发送 FIN 报文携带序列号，发送完毕后服务器处于 LAST_ACK 状态。</li><li>第四次挥手：客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号 +1，至此，完成四次挥手。此时客户端处于 TIME_WAIT 阶段。需要过一阵子确保服务器收到自己的 ACK 报文之后才会进入到 CLOSED 状态.</li><li>服务器收到 ACK 之后就关闭连接了，处于 CLOSED 状态。</li></ul><p>这里特别需要主要的就是 TIME_WAIT 这个状态了，这个是面试的高频考点，就是要理解，<strong>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭</strong>。这其中的原因就是，*要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，*客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>至于 <strong>TIME_WAIT 持续的时间至少是一个报文的来回时间</strong>。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p><p>注意：上述描述中的客户端和服务器的角色是对等的，以主动断开连接的一方作为客户端。</p><p>关于 3 次握手和 4 次挥手的网络抓包如下：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c459fcb0-e009-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p><p>以上的客户端和服务器在同一台机器上。但是我们仅在客户端抓包可能会出现如下的情况：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/bcb233b0-e00e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p><h2 id="为什么建立连接时-3-次握手，而关闭连接时-4-次挥手"><a href="#为什么建立连接时-3-次握手，而关闭连接时-4-次挥手" class="headerlink" title="为什么建立连接时 3 次握手，而关闭连接时 4 次挥手"></a>为什么建立连接时 3 次握手，而关闭连接时 4 次挥手</h2><p>这是因为服务器在 LISTEN 状态下，收到<strong>建立连接请求</strong>的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定。因此，一般 ACK 和 FIN 一般都会分开发送。</p><h2 id="为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态"><a href="#为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态" class="headerlink" title="为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态"></a>为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态</h2><p>两个存在的理由：</p><ol><li>无法保证最后发送的 ACK 报文会一定被对方收到，所以需要重发可能丢失的 ACK 报文。</li><li>当关闭当前的 TCP 连接时，最后发送出去的数据报可能被路由器的转发队列缓存，如果立马切换到 CLOSED 状态，可能使用相同窗口的新的 TCP 连接收到的数据报还是前一个 TCP 连接缓存在路由器中的数据。2MSL 足以让分组最多存活MSL 秒被丢弃。</li></ol><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><ul><li>TCP: 面向连接，可靠，面向字节流</li><li>UDP: 面向非连接，不可靠，面向报文, 限制报文大小为 64k</li></ul><h1 id="如何设计一个高并发系统"><a href="#如何设计一个高并发系统" class="headerlink" title="如何设计一个高并发系统"></a>如何设计一个高并发系统</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c0b29530-e29e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p><h2 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h2><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>大部分的高并发场景，都是读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的。</p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。<strong>读流量太多的时候，还可以加更多的从库</strong>。</p><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验才是难能可贵的。</p><h2 id="为什么-Protocol-Buffer-的效率是最高的"><a href="#为什么-Protocol-Buffer-的效率是最高的" class="headerlink" title="为什么 Protocol Buffer 的效率是最高的"></a>为什么 Protocol Buffer 的效率是最高的</h2><ul><li>使用proto编译器，自动进行序列化和反序列化，速度非常快，比XML和JSON快20-100倍</li><li>数据压缩效果非常好，序列化后的数据量非常小，传输起来占用更少的带宽</li></ul><h2 id="ZK的使用场景有哪些"><a href="#ZK的使用场景有哪些" class="headerlink" title="ZK的使用场景有哪些"></a>ZK的使用场景有哪些</h2><p>统一命名服务（Name Service）、配置管理（Configuration Management）、集群管理（Group Membership）、共享锁（Locks）、队列管理。</p><ul><li>Zookeeper是一个类似linux、hdfs的树形文件结构，zookeeper可以用来保证数据在(Zookeeper)集群之间的数据的事务性一致性，zookeeper也是我们常说的CAP理论中的CP（强一致性）。</li><li>Zookeeper有一个概念叫watch（也称之为事件），是一次性触发的，当watch监视的数据发生变化时，通知设置了该watch的client端，即watcher实例对象（用于改变节点的变化而做出相应的行为）</li><li>Zookeeper有三个角色：Leader，Follower，Observer</li><li>Leader：数据总控节点，用于接收客户端连接请求，分发给所有的Follower节点后，各个Follower节点进行更新数据操作并返回给Leader节点，如果满足半数以上（所以Zookeeper集群一般是奇数个节点）更新成功则此次操作成功；</li><li>Follower：相当于跟随者的角色，Zookeeper的Leader宕机（挂掉）时，所有的Follower角色内部会产生选举机制，选举出新的Leader用于总控；</li><li>Observer：顾名思义，就是我们的客户端，用于观察Zookeeper集群的数据发送变化，如果产生变化则zookeeper会主动推送watch事件给Observer（客户端），用于对数据变化的后续处理；当然Observer（客户端）也可以发送数据变更请求；</li></ul><h3 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h3><p>简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3711e6d0-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/5c06cf00-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><p>某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p><p><a href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/zookeeper/DistributedLockImpl.java">Twitter的分布式锁的实现</a></p><p>与redis分布式锁的对比：</p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk分布式锁，获取不到锁，注册个监听器即可，不需要主动尝试获取锁，性能开销小。</li></ul><p>另外一点就是，如果是 redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。redis分布式锁好麻烦:遍历上锁，计算时间等等……zk 的分布式锁语义清晰实现简单。综上所述zk的分布式锁比redis的分布式锁牢靠，而且模型简单易用。</p><h3 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h3><p>zookeeper可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持zookeeper么？</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/aeabbae0-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h3 id="HA高可用"><a href="#HA高可用" class="headerlink" title="HA高可用"></a>HA高可用</h3><p>比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个<strong>重要进程一般会做主备</strong>两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/07289f80-e337-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><blockquote><p>好的架构不是设计出来的，而是进化出来的。过早将一个系统划分为微服务的代价是非常高的（尤其是面对一个全新的领域时）。很多时候将一个已有的单体架构划分成微服务比从头开始构建微服务要简单得多！</p></blockquote><p>微服务的一大特点就是<strong>异构</strong>，不同的服务可以采用不同的语言，不同的 DB。</p><h2 id="不适用的场景"><a href="#不适用的场景" class="headerlink" title="不适用的场景"></a>不适用的场景</h2><ol><li>强事务</li><li>业务相对稳定、迭代周期长，几个月都不会更新 1 次</li><li>访问压力不大，可用性要求不高，例如中小型公司的内部系统</li></ol><h1 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h1><h2 id="电商网站详情页系统架构"><a href="#电商网站详情页系统架构" class="headerlink" title="电商网站详情页系统架构"></a>电商网站详情页系统架构</h2><p>小型电商网站的页面展示采用页面全量静态化的思想。数据库中存放了所有的商品信息，页面静态化系统，将数据填充进静态模板中，形成静态化页面，推入 Nginx 服务器。用户浏览网站页面时，取用一个已经静态化好的 html 页面，直接返回回去，不涉及任何的业务逻辑处理。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/80ec7620-e350-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><p>这样做，好处在于，用户每次浏览一个页面，不需要进行任何的跟数据库的交互逻辑，也不需要执行任何的代码，直接返回一个 html 页面就可以了，速度和性能非常高。对于小网站，页面很少，很实用，非常简单，Java 中可以使用 velocity、freemarker、thymeleaf 等等，然后做个 cms 页面内容管理系统，模板变更的时候，点击按钮或者系统自动化重新进行全量渲染。坏处在于，仅仅适用于一些小型的网站，比如页面的规模在几十到几万不等。对于一些大型的电商网站，亿级数量的页面，你说你每次页面模板修改了，都需要将这么多页面全量静态化，靠谱吗？每次渲染花个好几天时间，那你整个网站就废掉了。</p><p>大型电商网站商品详情页的系统设计中，当商品数据发生变更时，会将变更消息压入 MQ 消息队列中。缓存服务从消息队列中消费这条消息时，感知到有数据发生变更，便通过调用数据服务接口，获取变更后的数据，然后将整合好的数据推送至 redis 中。Nginx 本地缓存的数据是有一定的时间期限的，比如说 10 分钟，当数据过期之后，它就会从 redis 获取到最新的缓存数据，并且缓存到自己本地。</p><p>用户浏览网页时，动态将 Nginx 本地数据渲染到本地 html 模板并返回给用户。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/a768c1a0-e350-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p><p>虽然没有直接返回 html 页面那么快，但是因为数据在本地缓存，所以也很快，其实耗费的也就是动态渲染一个 html 页面的性能。如果 html 模板发生了变更，不需要将所有的页面重新静态化，也不需要发送请求，没有网络请求的开销，直接将数据渲染进最新的 html 页面模板后响应即可。</p><p>在这种架构下，我们需要保证系统的高可用性。如果系统访问量很高，Nginx 本地缓存过期失效了，redis 中的缓存也被 LRU 算法给清理掉了，那么会有较高的访问量，从缓存服务调用商品服务。但如果此时商品服务的接口发生故障，调用出现了延时，缓存服务全部的线程都被这个调用商品服务接口给耗尽了，每个线程去调用商品服务接口的时候，都会卡住很长时间，后面大量的请求过来都会卡在那儿，此时缓存服务没有足够的线程去调用其它一些服务的接口，从而导致整个大量的商品详情页无法正常显示。这其实就是一个商品接口服务故障导致缓存服务资源耗尽的现象。</p><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="设计实现一个-LRU"><a href="#设计实现一个-LRU" class="headerlink" title="设计实现一个 LRU"></a>设计实现一个 LRU</h2><p>该结构支持2个操作：访问和删除。访问操作会将不存在于数据结构中的元素插入（或者数据结构中存在该元素，则该元素放在头部），删除操作会返回最近最少访问的元素。</p><p>思考：取得最近访问元素就像是FIFO，可以想到栈，但是删除最老的数据就需要遍历整个栈了。我们需要一种快速访问容器头部并快速移除尾部元素的结构，自然而然可以想到队列，但是LRU还有一个特性：如果容器中已经有元素，需要将元素移动到头部，队列对于这样的操作需要从头遍历到指定元素，删除元素，再在 对头插入。显然是低效的。联想到双端链表删除元素只需要O(1)，（单链表删除元素为O(N),因为要遍历链表）。因此LRU的底层可以采用双向链表存储。快速根据key找到node节点就需要使用hash表了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value, prev, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = prev;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insertFirst</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">tail</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newTail = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!newTail) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newTail.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把节点移动到头部</span></span><br><span class="line">  <span class="title function_">moveToFront</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || node === <span class="variable language_">this</span>.<span class="property">head</span>) <span class="keyword">return</span>; <span class="comment">// 已经在头部了</span></span><br><span class="line">    <span class="keyword">const</span> &#123;prev, next&#125; = node;</span><br><span class="line">    <span class="comment">// 这个判断其实没有必要，因为前面已经判断过不是头结点了，前驱节点一定存在,写这个的目的是</span></span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">      prev.<span class="property">next</span> = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      next.<span class="property">prev</span> = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// key =&gt; 元素 ；value，双向链表中的节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将不存在数据结构中的元素插入</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">access</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      node = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">insertFirst</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(value, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">moveToFront</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除并返回最近最少访问的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">deleteLast</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">const</span> values = [];</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(cur.<span class="property">value</span>);</span><br><span class="line">      cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values.<span class="title function_">join</span>(<span class="string">&#x27; -&gt; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:<a href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></p><h1 id="如何回退代码到指定版本"><a href="#如何回退代码到指定版本" class="headerlink" title="如何回退代码到指定版本"></a>如何回退代码到指定版本</h1><p>方式一：可以新建一个分支，然后选择你想回退到到那个版本，切换到新分支之后，代码就是那个版本了，可以对那个版本进行操作，修改等，如果想回到之前最新版本，直接切换分支到原来到分支即可，这杨相互不影响，Reset master to this commit 只有是hard的时候，项目里代码内容才是你想切到的版本内容，不过这样会把你新改的代码丢失了.</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/a1a074a0-52bf-11ea-99cb-bf4e2c176816.png" alt="image.png"></p><p>方式二：git reset</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/bebba0a0-52bf-11ea-99cb-bf4e2c176816.png" alt="image.png"></p><p>注意如果需要保留后面commit的更改就选mixed，不然选hard。</p><p>注意：从这个reset 之后，再push服务器，会<strong>提示落后xx个版本</strong>，这个时候需要强制push。<code>git push --force</code>。</p><h1 id="一个-TCP-连接能发几个-HTTP-请求"><a href="#一个-TCP-连接能发几个-HTTP-请求" class="headerlink" title="一个 TCP 连接能发几个 HTTP 请求"></a>一个 TCP 连接能发几个 HTTP 请求</h1><p>如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 和 Keep-Alive 首部，在请求头带上 Connection: Keep-Alive，并且可以通过 Keep-Alive 通用首部中指定的，用逗号分隔的选项调节 keep-alive 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。<br>而如果是 HTTP 1.1 版本协议，支持了长连接，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限；<br>同样，如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送</p><h1 id="HTTP2-HTTP3"><a href="#HTTP2-HTTP3" class="headerlink" title="HTTP2&#x2F;HTTP3"></a>HTTP2&#x2F;HTTP3</h1><h2 id="什么是-TCP-的队头阻塞"><a href="#什么是-TCP-的队头阻塞" class="headerlink" title="什么是 TCP 的队头阻塞"></a>什么是 TCP 的队头阻塞</h2><p>TCP 协议中的一个<em>性能问题</em>。当一个 TCP 连接中的某个数据包丢失或延迟时，后续的数据包即使已经到达接收端，也无法被处理，必须等待丢失或者延迟的数据包重传并到达。这种现象会导致整个连接的吞吐量下降和延迟增加。</p><p>原因：</p><ol><li>TCP 的可靠性机制：TCP 是可靠协议，要求数据按照顺序到达接收端。如果某个数据包丢失或者乱序，接收端会将其缓存，直到丢失的数据包到达。</li><li>单一路径传输：TCP 连接中的所有数据包通过<em>同一条路径</em>传输，某个包丢失会导致整个连接的性能受影响。</li><li>滑动窗口机制：使用这种机制来进行流控。某个数据包丢失，发送端的窗口会被阻塞，直到丢失的数据包被确认。</li></ol><p>解决方案：</p><ol><li>使用多路复用协议：在应用层使用多路复用协议（如 HTTP2）可以在同一个 TCP 连接上同时传输多个请求和响应，但是 HTTP2 仍然受限于 TCP 的队头阻塞</li><li>使用 QUIC：基于 UDP 不存在 TCP 层面的队头阻塞，支持多路复用，每个数据流是独立的，丢失的数据包只会影响当前数据流不会阻塞其他数据流。</li><li>使用多个 TCP 连接：可以减少单个连接中队头阻塞的影响，但是这种方法会增加连接管理的复杂性和资源开销。</li><li>前向纠错(Forward Error Correction, FEC)：发送端可以附加冗余数据，接收端可以通过冗余数据恢复丢失的数据包，减少重传请求。</li></ol><h2 id="HTTP2-特点"><a href="#HTTP2-特点" class="headerlink" title="HTTP2 特点"></a>HTTP2 特点</h2><ol><li>二进制分帧(Binary Framing)：将数据转为二进制格式（而非 HTTP 1.1 的文本格式），分为更小的帧(Frame) 传输。解析高效，错误率低，支持多路复用。</li><li>多路复用(Multiplexing)：在单个 TCP 连接上并行传输多个请求和响应，避免 HTTP 1.1 的队头阻塞。显著提升页面加载速度，减少连接数（无需维护多个 TCP 连接）。</li><li>头部压缩(HPACK)：使用 HPACK 算法压缩 http header，减少数据冗余。降低带宽，尤其对小文件（如 API 请求）性能提升明显。</li><li>服务器推送(Server Push)：主动向客户端推送资源（例如 js，css），无需客户端请求。减少 RTT(往返延迟)，提前加载关键资源</li><li>流优先级(Stream Prioritization)：允许客户端为请求分配优先级（如优先加载 HTML 而非图片）。优化资源加载顺序，提升用户体验。</li><li>默认加密(基于 HTTPS)：虽不强制，但主流浏览器（如 Chrome、Firefox）仅支持 HTTP&#x2F;2 over TLS（HTTPS）。推动全站加密，增强安全性。</li><li>改进的流量控制：基于流的流量控制（而非 TCP 层的全局控制），防止单个流占用过多资源。更精细的带宽管理。</li></ol><h1 id="WebSocket-和-HTTP-之间有什么关系"><a href="#WebSocket-和-HTTP-之间有什么关系" class="headerlink" title="WebSocket 和 HTTP 之间有什么关系"></a>WebSocket 和 HTTP 之间有什么关系</h1><p>WebSocket 是一个独立的基于 TCP 的协议，它与 HTTP 之间的唯一关系就是它的握手请求可以作为一个升级请求（Upgrade request）经由 HTTP 服务器解释（也就是可以使用 Nginx 反向代理一个WebSocket）。 </p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="HTTP-重定向负载均衡"><a href="#HTTP-重定向负载均衡" class="headerlink" title="HTTP 重定向负载均衡"></a>HTTP 重定向负载均衡</h2><p>来自用户的 HTTP 请求到达负载均衡服务器以后，负载均衡服务器根据某种负载均衡算法计算得到一个应用服务器的地址，通过 HTTP 状态码 302 重定向响应，将新的 IP 地址发送给用户浏览器，用户浏览器收到重定向响应以后，重新发送请求到真正的应用服务器，以此来实现负载均衡。</p><p>实现起来非常简单，但是缺点也非常明显：</p><ol><li>客户端完成一次访问需要 2 次请求（请求负载均衡服务器+应用服务器），处理性能会受到影响</li><li>因为客户端需要连接应用服务器，所以需要<strong>将真实 IP 暴露给客户端</strong>，可能会带来安全问题</li></ol><p>这种方案在实际开发中几乎不会使用。</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>当用户从浏览器发起 HTTP 请求的时候，首先要到 DNS 域名服务器进行域名解析，解析得到 IP 地址以后，用户才能够根据IP地址建立 HTTP 连接，访问真正的数据中心的应用服务器，这时候就可以在 DNS 解析的时候进行负载均衡，也就是说，<em>不同的用户进行域名解析的时候，返回不同的 IP 地址</em>，从而实现负载均衡。</p><p>DNS 负载均衡和 HTTP 重定向负载均衡非常像，但是不会有性能问题：因为 DNS 解析之后 IP 地址就被客户端缓存了。但是会不会有安全问题呢？大型互联网应用通常并不直接通过 DNS 解析得到应用服务器 IP 地址，而是解析得到负载均衡服务器的 IP 地址。也就是说，大型网互联网应用需要<em>两次负载均衡</em>，一次通过<em>DNS负载均衡</em>，用户请求访问数据中心负载均衡服务器集群的某台机器，然后这台负载均衡服务器再进行一次负载均衡，将用户请求分发到应用服务器集群的某台服务器上。通过这种方式，应用服务器不需要用公网IP将自己暴露给外部访问者，避免了安全性问题。</p><p>DNS 域名解析是域名服务商提供的一项基本服务，<em>几乎所有的域名服务商都支持域名解析负载均衡</em>，只需要在域名服务商的服务控制台进行一下配置，不需要开发代码进行部署，就可以拥有 DNS 负载均衡服务了。目前大型的互联网应用，淘宝、百度、Google 等全部使用 DNS 负载均衡。比如用不同的电脑<code>ping www.baidu.com</code>就可以看到，不同电脑得到的 IP 地址是不同的。</p><h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>常用的 web 服务器 NGINX 就有这个功能。反向代理服务器是工作在 HTTP 协议层之上的，因此这一层的代理负载均衡也叫做<em>应用层负载均衡</em>。所以它代理的也是 HTTP 的请求和响应。作为互联网应用层的一个协议，HTTP 协议相对说来比较重，效率比较低，所以<em>反向代理负载均衡通常用在小规模的互联网系统上，只有几台或者十几台服务器的规模。</em></p><h2 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h2><p>工作在 TCP&#x2F;IP 的 IP 层，所以有时候也叫做<em>网络层负载均衡</em>。工作原理：当用户的请求到达负载均衡服务器以后，负载均衡服务器会对网络层的数据包的 IP 地址进行转换，将其修改为应用服务器的 IP 地址，然后把数据包重新发送出去，请求数据就会到达应用服务器。</p><p>在操作系统内核直接修改 IP 数据包的地址，效率比应用层的反向代理负载均衡高得多。但是它依然有一个缺陷，不管是请求还是响应的数据包，都要通过负载均衡服务器进行 IP 地址转换，才能够正确地把请求数据分发到应用服务器，或者正确地将响应数据包发送到用户端程序。请求的数据通常比较小，一个 URL 或者是一个简单的表单，但是响应的数据不管是 HTML 还是图片，或者是 JS、CSS这样的资源文件通常都会比较大，因此<em>负载均衡服务器会成为响应数据的流量瓶颈</em>。</p><h2 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h2><p>可以解决响应数据量大而导致的负载均衡服务器输出带宽不足的问题，像淘宝这种规模的应用，通常使用 Linux 内核支持的链路层负载均衡。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fadc872a-c54b-4b9c-933a-bb21d7c4ce2a.png" alt="image.png"></p><p>这种负载均衡模式也叫<strong>直接路由模式</strong>，在负载均衡服务器的 Linux 操作系统内核拿到数据包后，直接修改数据帧中的 mac 地址，将其修改为应用服务器集群中某个服务器的 mac 地址，然后将数据重新发送回服务器集群所在的局域网，这个数据帧就会被某个真实的应用服务器接收到。</p><p>负载均衡服务器和集群内的应用服务器配置相同的虚拟 IP 地址，也就是说，在网络通信的 IP 层面，负载均衡服务器变更 mac 地址的操作是透明的，不影响 TCP&#x2F;IP 的通信连接。所以真实的应用服务器处理完应用请求，发送应答响应的时候，就会直接发送回请求的客户端，不会再经过负载均衡服务器。</p><blockquote><p>Linux上实现IP负载均衡和链路层负载均衡的技术是 LVS，目前 LVS 功能已经集成到 Linux 中了，可以直接配置实现这两种负载均衡。</p></blockquote><h1 id="如何改善数据的存储能力"><a href="#如何改善数据的存储能力" class="headerlink" title="如何改善数据的存储能力"></a>如何改善数据的存储能力</h1><p>在整个互联网系统架构中，承受着最大处理压力，最难以被伸缩的，就是数据存储部分。原因主要有两方面：</p><ol><li>数据存储需要使用硬盘，而硬盘的处理速度要比其他几种计算资源，比如 CPU、内存、网卡都要慢一些；</li><li>另一方面，数据是公司最重要的资产，公司需要保证数据的高可用以及一致性，非功能性约束更多一些。</li></ol><p>因此数据存储通常都是互联网应用的瓶颈。在高并发的情况下，最容易出现性能问题的就是数据存储。目前用来改善数据存储能力的主要手段包括：数据库主从复制、数据库分片和 NoSQL 数据库。</p><h1 id="实现高可用常用的手段有哪些"><a href="#实现高可用常用的手段有哪些" class="headerlink" title="实现高可用常用的手段有哪些"></a>实现高可用常用的手段有哪些</h1><h2 id="冗余备份"><a href="#冗余备份" class="headerlink" title="冗余备份"></a>冗余备份</h2><p>提供同一服务的服务器要存在冗余，即任何服务都不能只有一台服务器，服务器之间要互相进行备份，任何一台服务器出现故障的时候，请求可以发送到备份的服务器去处理。这样，即使某台服务器失效，在用户看来，系统依然是可用的。</p><h2 id="失败隔离"><a href="#失败隔离" class="headerlink" title="失败隔离"></a>失败隔离</h2><p><em>将失败限制在一个较小的范围之内</em>，使故障影响范围不扩大。具体实现失败隔离的主要架构技术是消息队列。</p><p>一方面，消息的生产者和消费者通过消息队列进行隔离。如果消费者出现故障的时候，生产者可以继续向消息队列发送消息，而不会感知到消费者的故障，等消费者恢复正常以后再去从消息队列中消费消息，所以从用户处理的视角看，系统一直是可用的。</p><p>发送邮件消费者出现故障，不会影响生产者应用的运行，也不会影响发送短信等其他消费者正常的运行。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/f5134b9e-f481-4f9b-8626-f18cea210d95.png" alt="image.png"></p><p>另一方面，由于分布式消息队列具有削峰填谷的作用，所以在高并发的时候，消息的生产者可以将消息缓冲在分布式消息队列中，消费者可以慢慢地从消息队列中去处理，而不会将瞬时的高并发负载压力直接施加到整个系统上，导致系统崩溃。也就是<strong>将压力隔离开来</strong>，使消息生产者的访问压力不会直接传递到消息的消费者，这样可以提高数据库等对压力比较敏感的服务的可用性。</p><p>同时，<em>消息队列还使得程序解耦，将程序的调用和依赖隔离开来</em>，我们知道，低耦合的程序更加易于维护，也可以减少程序出现 Bug的几率。</p><h2 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h2><p>保护系统高可用的一种手段。比如说在电商系统中有确认收货这个功能，即便我们不去确认收货，系统也会超时自动确认收货。但际上确认收货这个操作是一个非常重的操作，因为它会对数据库产生很大的压力：它要进行更改订单状态，完成支付确认，并进行评价等一系列操作。如果在系统高并发的时候去完成这些操作，那么会对系统雪上加霜，使系统的处理能力更加恶化。</p><p>解决办法就是在系统高并发的时候，比如说像淘宝双 11 的时候，当天可能整天系统都处于一种极限的高并发访问压力之下，这时候就可以将确认收货、评价这些非核心的功能关闭，将宝贵的系统资源留下来，给正在购物的人，让他们去完成交易。</p><h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><p>主要是解决整个数据中心不可用问题的。将数据中心分布在多个不同地点的机房里，这些机房都可以对外提供服务，用户可以连接任何一个机房进行访问，这样每个机房都可以提供完整的系统服务，即使某一个机房不可使用，系统也不会宕机，依然保持可用。</p><p>异地多活的架构考虑的重点就是，用户请求如何分发到不同的机房去。这个主要可以在域名解析的时候完成，也就是用户进行域名解析的时候，会根据就近原则或者其他一些策略，完成用户请求的分发。另一个至关重要的技术点是，因为是多个机房都可以独立对外提供服务，所以也就意味着每个机房都要有完整的数据记录。用户在任何一个机房完成的数据操作，都必须同步传输给其他的机房，进行数据实时同步。</p><p>数据库实时同步最需要关注的就是数据冲突问题。同一条数据，同时在两个数据中心被修改了，该如何解决？为了解决这种数据冲突的问题，某些容易引起数据冲突的服务采用类似MySQL 的主主模式，也就是说多个机房在某个时刻是有一个主机房的，某些请求只能到达主机房才能被处理，其他的机房不处理这一类请求，以此来避免关键数据的冲突。</p><p>除了上述的高可用架构方案，还有一些高可用的运维方案：通过自动化测试减少系统的bug，通过自动化监控尽早发现系统的故障，通过预发布验证发现测试环境无法发现的bug，灰度发布降低软件错误带来的影响以及评估软件版本升级带来的业务影响等等。</p><h1 id="如何实现电子邮件的已读回执"><a href="#如何实现电子邮件的已读回执" class="headerlink" title="如何实现电子邮件的已读回执"></a>如何实现电子邮件的已读回执</h1><p>参考<a href="http://www.getnotify.com/%EF%BC%8C%E5%9C%A8%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E5%BC%A01px%E7%9A%84%E7%A9%BA%E7%99%BD%E5%9B%BE%E7%89%87%EF%BC%8C%E6%A3%80%E6%B5%8B%E8%AF%A5%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0%E3%80%82">http://www.getnotify.com/，在邮件列表插入一个随机生成的一张1px的空白图片，检测该图片链接的访问次数。</a></p><p>基于nginx_http_empty_gif借助access.log打点性能开销最小。nginx 1 px 像素gif的妙用：<a href="http://www.ttlsa.com/nginx/nginx-modules-empty_gif/">http://www.ttlsa.com/nginx/nginx-modules-empty_gif/</a> ，常用于统计打点，这种请求一般只需要单向上报数据，尽可能少返回数据。</p><h1 id="说一说你的缺点"><a href="#说一说你的缺点" class="headerlink" title="说一说你的缺点"></a>说一说你的缺点</h1><p>只需要说一说自己现在正在学的东西即可，不要傻乎乎说自己这个不行，那个不行。</p><h1 id="你有什么想要问的"><a href="#你有什么想要问的" class="headerlink" title="你有什么想要问的"></a>你有什么想要问的</h1><p>这个岗位具体会做哪些事情，会与哪些人合作？<br>进一步对工作岗位进行深入了解，以及对将来的合作伙伴有更多提前认知，同时给面试官一些尽情表达的机会，显得你是非常关心这个工作机会。</p><p>咱们团队目前面对的最大挑战&#x2F;困难是什么?<br>抓住机会深入了解团队目前的困难、痛点，利用入职前的空档期，提前做好预习与准备，以便顺利入职之后快速产出。</p><p>总之，**问太肤浅的问题，会让你显得格局小。**太细节、太琐碎的，比如作息制度、报销制度，是否管午饭，是否经常加班，团队有几个女生，有没有健身房……等等类似太具体的问题，还是留在该公司将offer发给你之后、入职已经胜券在握的时候再去问HR吧。</p><blockquote><p>太上无败，其次败而有以成，此之谓用民。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 HashMap</title>
      <link href="/2019/08/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/"/>
      <url>/2019/08/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>HashMap的底层采用的散列算法是拉链法（另一种散列算法是线性探测法）。并且在JDK1.8中使用红黑树对长链表进行优化。</p><h2 id="初始容量、负载因子、阈值"><a href="#初始容量、负载因子、阈值" class="headerlink" title="初始容量、负载因子、阈值"></a>初始容量、负载因子、阈值</h2><p>初始容量比较好理解，阈值指的是当桶的个数超过了这个值后Hash表会进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure><p>注释中说的是阈值可以通过容量乘以负载因子得到，但是实际上我们通过的是<code>tableSizeFor</code>方法初始化阈值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);  <span class="comment">// 根据初始容量得到阈值，例如初始容量为10，则阈值为16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析这个算法：<br>首先，为什么要对cap做减1操作。<code>int n = cap - 1;</code> 这是为了防止，cap已经是2的幂。如果cap已经是2的幂，又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。 </p><p>下面看看这几个无符号右移操作：<br>如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。 </p><p>这里只讨论n不等于0的情况。 </p><p><strong>第一次右移</strong></p><p>由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如000011xxxxxx</p><p><strong>第二次右移</strong></p><p>注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1; </code>操作。假设此时n为000011xxxxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如00001111xxxxxx </p><p><strong>第三次右移</strong></p><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如00001111 1111xxxxxx 。 以此类推。 </p><p>注意，容量最大也就是32bit的正数，因此最后<code>n |= n &gt;&gt;&gt; 16; </code>，最多也就32个1，但是这时已经大于了MAXIMUM_CAPACITY，所以取值到MAXIMUM_CAPACITY。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7b896d80-c4cb-11e9-a588-7b887be857df.png" alt="使用移位运算算数组的阈值"> </p><h1 id="为什么大部分hashCode都选用素数31"><a href="#为什么大部分hashCode都选用素数31" class="headerlink" title="为什么大部分hashCode都选用素数31"></a>为什么大部分hashCode都选用素数31</h1><p>String类的hashCode实现是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idea自动生成的hashCode方法调用的是Object.hash，而Object.hash调用的是Arrays.hash，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object a[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的代码中，我们也可以发现<em>HashMap是允许空键的</em></p></blockquote><p>都不约而同使用了<strong>素数31</strong>。为什么要选择这样一个素数呢？</p><ul><li>第一，31是一个不大不小的质数，是作为 hashCode 乘子的优选质数之一。另外一些相近的质数，比如37、41、43等等，也都是不错的选择。那么为啥偏偏选中了31呢？请看第二个原因。</li><li>第二、31可以被 JVM 优化，<code>31 * i = (i &lt;&lt; 5) - i</code>。</li></ul><h1 id="HashMap-的-hash-算法的实现原理"><a href="#HashMap-的-hash-算法的实现原理" class="headerlink" title="HashMap 的 hash 算法的实现原理"></a>HashMap 的 hash 算法的实现原理</h1><p>为什么右移 16 位，为什么要使用异或。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap在寻找桶的时候不会直接调用对象的hashCode取得下标，而是会使用上面的<strong>抖动函数</strong>对对象的hashCode再进行一次加工，使求得到的哈希值分布尽量平均。但是为什么移动16位，为什么异或？</p><p>在分析这个问题之前，我们需要先看看另一个事情，什么呢？就是 HashMap 如何根据 hash 值找到数组种的对象，我们看看 get 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看代码中注释下方的一行代码：<code>first = tab[(n - 1) &amp; hash]</code>。</p><p>使用数组的最后一个索引和传入的hash值进行<em>与运算</em>。这句代码就是为什么要让前面的抖动函数移位并异或。</p><p>如果不经过抖动函数的处理，假设有一种情况：</p><p>a.hashCode: 01000010001110001000001111000000<br>b.hashCode: 00111011100111000101000010100000</p><p>假设数组长度为16，也就是说上面两个数要和15(转化成二进制是28个0加4个1)进行与操作，因为a和b的后4位都是1，从而结果都是0。换而言之：<strong>如果不经过抖动函数的处理，则丢失了高位的细节，hash不均匀</strong>。但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。</p><p>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000 和 1000000000100000000000000 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。</p><h1 id="HashMap-为什么使用-与运算代替模运算"><a href="#HashMap-为什么使用-与运算代替模运算" class="headerlink" title="HashMap 为什么使用 &amp; 与运算代替模运算"></a>HashMap 为什么使用 &amp; 与运算代替模运算</h1><p>计算数组下标的方法中使用了<code>tab[(n - 1) &amp; hash]</code>。这个代码其实和<code>tab[hash % n]</code>是一样的（n是数组长度，等于2的幂）。抽象成一般情况就是：<code>a % b == (b - 1) &amp; a</code>（b是2的幂）。</p><p>我们可以这样思考：当b是2个幂的时候，b-1可以得到末位全是1的数字，例如:</p><p>(11)<del>2</del> &#x3D; 3<br>(111)<del>2</del> &#x3D; 7<br>(1111)<del>2</del> &#x3D; 15</p><p>可以看出b-1其实是掩码，和这个数字进行与运算其实是和求余数是等价的（过滤高位的结果，并且低位保持不变，数据区间[0,掩码]）。</p><h1 id="如何手动构造哈希冲突"><a href="#如何手动构造哈希冲突" class="headerlink" title="如何手动构造哈希冲突"></a>如何手动构造哈希冲突</h1><p>复用上面的概念，传入的hash与掩码进行与运算可以得到哈希桶的索引，我们只需要手动让索引全部相等即可。例如：假设此时hash桶的个数为16 &#x3D; 2^4，则掩码为(1111)<del>2</del>。</p><p>如果我们希望碰撞后的索引位于0号索引，则二进制表示就是0,10000,100000,110000 …. 我们只要保证构造的数据后4位（和掩码的位数相同）都是0即可.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> bit = <span class="number">14</span>;</span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span> &lt;&lt; bit - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line"><span class="keyword">const</span> hashCollisionKeys = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造hash冲突的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> cur = <span class="number">0</span>; cur &gt;= <span class="number">0</span> &amp;&amp; cur &lt;= max; cur += size) &#123;</span><br><span class="line">  hashCollisionKeys.<span class="title function_">push</span>(<span class="title class_">String</span>(cur));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key的长度&#x27;</span>, hashCollisionKeys.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normalKeys = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hashCollisionKeys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  normalKeys.<span class="title function_">push</span>(<span class="title class_">String</span>(_.<span class="title function_">random</span>(<span class="number">0</span>, max)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;normal#insert&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> normalKeys) &#123;</span><br><span class="line">  map1.<span class="title function_">set</span>(key, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;normal#insert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;collision#insert&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> hashCollisionKeys) &#123;</span><br><span class="line">  map2.<span class="title function_">set</span>(key, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;collision#insert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;normal#get&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  map1.<span class="title function_">get</span>(_.<span class="title function_">sample</span>(normalKeys));</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;normal#get&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;collision#get&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  map2.<span class="title function_">get</span>(_.<span class="title function_">sample</span>(hashCollisionKeys));</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;collision#get&#x27;</span>);</span><br></pre></td></tr></table></figure><p>我们知道Integer类型的hashCode等于其自身，因此以上述结果做成的键作为Hash表的key将会导致Hash冲突，性能急剧下降。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key的长度 131072</span><br><span class="line">normal#insert: 31.981ms</span><br><span class="line">collision#insert: 23341.859ms</span><br><span class="line">normal#get: 1.100ms</span><br><span class="line">collision#get: 158.040ms</span><br></pre></td></tr></table></figure><p>以这样的整数作为键插入到HashMap中会造成Hash冲突，利用这个原理可以进行<a href="https://blog.it2048.cn/article-java-hash-collision/">哈希碰撞攻击</a>。</p><h1 id="HashMap-的容量为什么建议是-2的幂次方"><a href="#HashMap-的容量为什么建议是-2的幂次方" class="headerlink" title="HashMap 的容量为什么建议是 2的幂次方"></a>HashMap 的容量为什么建议是 2的幂次方</h1><p>假设数组容量为10，即与运算的对象是10 &#x3D; (1010)<del>2</del></p><p>任何一个二进制数和以上的结果进行运算只会产生0000,0010,1000,1010，4种结果，而1111，0111 ……根本不会出现，因此<strong>和一个掩码进行与运算可以得到的散列结果最多</strong>。散列结果最多可以理解为数据分布比较均匀，不容易产生哈希碰撞。</p><p>所以，当我们为HashMap指定初始容量的时候应该向上乘以1.33倍(0.75倍扩容)，再向上取一个二进制数。</p><h1 id="为什么HashMap非线程安全而HashTable线程安全"><a href="#为什么HashMap非线程安全而HashTable线程安全" class="headerlink" title="为什么HashMap非线程安全而HashTable线程安全"></a>为什么HashMap非线程安全而HashTable线程安全</h1><p>查看源码可知HashTable大部分方法都被<code>synchronized</code>关键字修饰过。HashTable的Hash算法采用的取余，而HashMap用位运算；HashTable每次扩容的时候是原先的2倍容量加1，HashMap是2的幂。</p><p>其实应对并发场景，推荐使用<code>ConcurrentHashMap</code>，因为HashTable虽然是线程安全的，但是使用的的是<code>synchronized</code>关键字修饰方法，<strong>相当于对对象进行上锁</strong>，所以当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。</p><p>JDK 1.8中ConcurrentHashMap采用的是CAS原理。如果没有Hash冲突则进行CAS插入，否则使用syn关键字较低粒度锁住节点，进行插入。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/">为什么常用的hash算法中用31作为乘子</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情人节有感</title>
      <link href="/2019/02/14/about-love/"/>
      <url>/2019/02/14/about-love/</url>
      
        <content type="html"><![CDATA[<p>不得不感慨时间真是过得快啊，仔细回想起来已经8年没回过老家过年，今年算是第一次。家乡的变化还是挺大的：首先高速公路通向了家门口，每家每户都盖了新房子，小汽车也几乎是每家都有的了，但是反观经济来源还是和原来一样：依靠种植业和外出务工，留在家里的大多是老人。</p><p>记得好多年前有个热词“租个女友回家过年”，当时年轻气盛的我却对之嗤之以鼻：有那么难么？至于花钱骗家里人么？今年回家过年也算是见识到了所谓的“过年式提问”：在哪里工作？工资多少？有对象了没？突然意识到自己已经不再年轻了，再也没有办法专心做自己的事情了。他们还愿意问你，说明他们还是在关心你，为你操心啊！</p><p>“冥冥之中，自有天意，该有的总会有的，只不过是时间而已”。一直以来我一直对此深信不疑，也正是因为如此，身边有喜欢的女孩子也不会主动去追，母胎单身至今。</p><p>苏格拉底在向柏拉图解释爱情和婚姻的时候曾经拿过麦田的麦穗的比喻：</p><blockquote><p>到麦田中摘一颗最大最好的麦穗，要求只能摘一次并且不能往回走。第一次柏拉图空手而归：看到一颗比较好的麦穗，但是由于不太确定是不是最好的，于是一直向前，直到走到最后才发现自己一无所获；有了第一次的经验之后柏拉图第二带回了一个普普通通的麦穗。苏格拉底解释这分别就是爱情和婚姻。</p></blockquote><blockquote><p>时光流逝，人生是单行线。每个人的一生都是这样一块不能走回头路的麦田，最大的麦穗不是一种虚无的概念，而是的的确确存在于麦田的某一个位置，过早的为某一较大的麦穗诱惑或是总期冀后面有更大的麦穗，都将铸成一生的憾事。摘取最大的麦穗需要一种智慧，这智慧源于对自己的自知之明和对麦田的了然于心。</p></blockquote><blockquote><p>人生经历着无数次选择。选择前，我们要慎重。选择时，我们要果断。选择后，我们要淡定。世界精彩纷呈，充满诱惑。一定还有很多更饱满的麦穗出现，但请不要轻易抛弃你手中的这个麦穗，因为只有它才是实实在在属于你的。</p></blockquote><blockquote><p>茫茫人海，谁是你人生那颗最大的麦穗？</p></blockquote><p>一直以来我觉得两个人需要经过长时间的相处，这样才能熟悉各自的心性，进而决策出是否合适在一起组成家庭。但是过年回家老家的一件事刷新了我的认知：两个素昧蒙面的人通过别人介绍，10天之内结婚，更让我难以理解的是女方还是刚刚大学毕业，听说是个美女；男方长得又矮又丑，家境也不是特别好。不具备一见钟情的条件，也不是日久生情，就这么莫名其妙地结合到一起了，我只能说是因为爱情。</p><p>来深圳3年了，每天按部就班的上班、下班、学习、运动、睡觉，周末也是宅在家，这种情况必须改进。今年希望能更多地参加一些活动，认识更多有趣的人！</p><p>目前还处于单身状态的原因：</p><ol><li>圈子小：缺乏认识优质单身适龄异性的机会</li><li>工作忙：经常加班，没有时间脱单</li><li>注重效率：不愿意把时间花费在奔波于各种活动以及无感之人的寒暄</li><li>缺乏恋爱经验：没有恋爱经验或感情经历简单</li><li>不善展示自我：不善于和异性沟通、相处</li><li>适婚年龄：家人催促，自身着急，计划一年左右结婚</li><li>择偶需求明确：明确自身需求，想要更高效的匹配</li></ol><h1 id="相亲贴"><a href="#相亲贴" class="headerlink" title="相亲贴"></a>相亲贴</h1><ul><li><a href="https://www.zhihu.com/question/302139794/answer/530999904">https://www.zhihu.com/question/302139794/answer/530999904</a></li><li><a href="https://www.zhihu.com/question/311809792/answer/3907450458">https://www.zhihu.com/question/311809792/answer/3907450458</a></li><li><a href="https://www.zhihu.com/question/342340031/answer/2450343724">https://www.zhihu.com/question/342340031/answer/2450343724</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱情 </tag>
            
            <tag> 婚姻 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年年度小结</title>
      <link href="/2019/01/31/my-2018/"/>
      <url>/2019/01/31/my-2018/</url>
      
        <content type="html"><![CDATA[<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>不得不感慨时间过得真快，算下来16年来深圳工作到现在差不多3年了，但是仔细回想起来感觉也过得非常一般，甚至可以用“凄惨”来形容。技术方面前两年还能学到一些新的东西，最近一年感觉提升有限。</p><p>前几天看到一篇文章<a href="http://survivor.ruanyifeng.com/plan-b/mule.html">《你的命运不是一头骡子》</a>，文中说道：</p><blockquote><p>骡子并不知道，为何要把如此重的铁管背到山顶，就是因为主人要求它这么做，就任劳任怨地干了。哪怕有那么一瞬间，它的内心有过一丝抗拒或疑问，主人一施压，它就不再追问了，回到正常的状态，默默地听任摆布。</p></blockquote><p>突然感慨道好像我自己也是这样的：埋头实现产品提出的需求，别人让干什么就干什么，却没有思考为什么要这样做。有时候对需求有一点异议，和产品沟通无果后就废弃了自己的想法，默默忍受，很快就废弃了自己的想法，也没有继续追问产品两种方案的差异。</p><p>最近一段时间网上频繁曝出裁员、大厂停止社招的消息。作为一个技术水平不怎么样并且是夕阳行业的低级码农，我内心其实是非常恐惧，感觉自己可以随时被替代掉，本来这个职位的招聘需求不多，自己又毫无竞争力，第二个收入来源又没有。这不啻于将鸡蛋全部放在同一个篮子里面，冒着极大的风险。</p><p>我觉得未来的发展，一方面要提高的自己的核心竞争力：对一些业务的实现，需要想想还有没有别的实现，能不能用某一种设计模式简化代码，把代码写得更有条理，逻辑更清晰，对人更友好？一些技术沙龙、技术分享之类的也要积极参与，不一定要学会某些具体的技术落地，对于开阔视野，提升认知也是极好的，如果能认识些业界大牛也是非常不错的。</p><p>其实感觉身边有很多优秀的人，向比如说有人对产品很有想法，比如说有人代码写得很工整，比如说有人总是能很轻易发现软件可能存在的bug，这些都是可以学习的。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>在过去的一年里，我试图去改变自己太过内向的性格，但是效果还是不太理想，感觉有时候还是会因为害怕说错话而选择沉默，有句话说“江山易改，本性难移”我算是深刻理解到了这句话，不过也还好，总算是跨出去了第一步。这一年要更加积极和人交流，锻炼自己的沟通表达能力，别人说什么GET不到点就不好了。</p><p>常常有人说“好看的皮囊千篇一律，有趣的灵魂万里挑一”，可是也有人说“始于颜值、陷于才华、终于人品”。突然发现这么多年下来自己好像一直不修边幅，这是非常不好的，要慢慢学会穿衣打扮，做一个有品位，有魅力的人。</p><p>好好利用好周末时间，学一些实用的技能，比如说做饭。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>2019年以梦为马，不负韶华。做一个自律的人，遇到喜欢的人，主动一点。在这里立几个flag:</p><ul><li>养成整理的好习惯，生活和工作都是</li><li>攒点钱</li><li>好好学英语</li><li>学会做饭</li><li>学会游泳</li><li>多给家人打电话和视频，和同学朋友多联系</li><li>不要熬夜！！！！</li></ul><p>记得有个10000小时法则：真正决定一个人成就的不是天分，也不是运气，而是严格的自律和高强度的付出。成功的秘密，根本不是秘密，那就是不停地做。如果你真的努力了，你会发现自己比想象中的要优秀很多！</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的算法</title>
      <link href="/2018/12/26/awesome-alg/"/>
      <url>/2018/12/26/awesome-alg/</url>
      
        <content type="html"><![CDATA[<blockquote><p>爬虫底层的算法是广度优先搜索。</p></blockquote><h1 id="二项分布和递归"><a href="#二项分布和递归" class="headerlink" title="二项分布和递归"></a>二项分布和递归</h1><p>问题来源于算法第四版问题1.1.27。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binomial</span> = (<span class="params">N, k, p</span>) =&gt; &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">10000000</span> === <span class="number">0</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    <span class="comment">// 因为每次递归都是N-1，并且k-1，因此这种情况很难出现</span></span><br><span class="line">    <span class="keyword">if</span> (N === <span class="number">0</span> &amp;&amp; k === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最终应该会调用这个if</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - p) * <span class="title function_">binomial</span>(N - <span class="number">1</span>, k, p) + p * <span class="title function_">binomial</span>(N - <span class="number">1</span>, k - <span class="number">1</span>, p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5分钟算不出来，舍弃</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;二项分布-递归&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">binomial</span>(<span class="number">10</span>, <span class="number">50</span>, <span class="number">.25</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;二项分布-递归&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br></pre></td></tr></table></figure><p>估计上面函数的调用次数。</p><h2 id="伯努利试验（独立重复试验）"><a href="#伯努利试验（独立重复试验）" class="headerlink" title="伯努利试验（独立重复试验）"></a>伯努利试验（独立重复试验）</h2><blockquote><p>伯努利试验（Bernoulli experiment）是在同样的条件下重复地、相互独立地进行的一种随机试验，其特点是该随机试验只有两种可能结果：发生或者不发生。我们假设该项试验独立重复地进行了 n 次，那么就称这一系列重复独立的随机试验为 n 重伯努利试验，或称为伯努利概型。单个伯努利试验是没有多大意义的，然而，当我们反复进行伯努利试验，去观察这些试验有多少是成功的，多少是失败的，事情就变得有意义了，这些累计记录包含了很多潜在的非常有用的信息。</p></blockquote><p>设在一次试验中，事件 A 发生的概率为 p(0 &lt; p &lt; 1)，则在 n 重伯努利试验中，事件 A恰好发生 k 次的概率为：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/binomial.png" alt="伯努利试验"></p><p>试了一下，直接将 N 传入100，5 分钟算不出来，舍弃。将 n 从 10 开始到大规模开始测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N k time count</span><br><span class="line">10 5 0.280ms 2467</span><br><span class="line">20 10 25.045ms 2433071</span><br><span class="line">30 15 24871.999ms 2438328997</span><br></pre></td></tr></table></figure><p>当 N 到 30 的时候发现速度已经非常慢了，基本上是几何级数增长。</p><p>改进的算法，使用容器缓存已经计算过的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binomial2</span> = (<span class="params">N, k, p</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">`<span class="subst">$&#123;N&#125;</span>-<span class="subst">$&#123;k&#125;</span>`</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (cache[key] !== <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> cache[key];</span><br><span class="line">    <span class="keyword">if</span> (N === <span class="number">0</span> &amp;&amp; k === <span class="number">0</span>) <span class="keyword">return</span> cache[key] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> cache[key] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cache[key] = (<span class="number">1</span> - p) * <span class="title function_">binomial2</span>(N - <span class="number">1</span>, k, p) + p * <span class="title function_">binomial2</span>(N - <span class="number">1</span>, k - <span class="number">1</span>, p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>传入参数 100 和 50，调用次数为 7751，耗时 4.903ms。</p><h1 id="欧几里得算法及其证明"><a href="#欧几里得算法及其证明" class="headerlink" title="欧几里得算法及其证明"></a>欧几里得算法及其证明</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gcd</span> = (<span class="params">p, q</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">const</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">gcd</span>(q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gcd2</span> = (<span class="params">p, q</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (q !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = p % q;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧几里德的算法关键在于证明等式gcd(a,b)&#x3D;gcd(b,a mod b)的正确性。</p><p>定理：a，b为正整数，则gcd(a,b)&#x3D;gcd(b,a mod b)<br>证明：</p><p>k,r为整数，设r &#x3D; a mod b,则a可以表示成a&#x3D;kb+r。</p><p>假设d是{a,b}的一个公约数，<br>则 </p><p>a &#x3D; md<br>b &#x3D; nd</p><p>r &#x3D; a - kb &#x3D; md - knd &#x3D; (m - kn)d</p><p>则d整除r，即d也是b和r的公约数</p><p>同理，假设d是{b,r}的一个公约数，则d整除b,d整除r，因此d整除a, d也是a和b的公约数。</p><p>因此{a,b}和{b,r}的公因子集合是一样的。特别地，{a,b}的最大共因子和{b,r}的最大公因子是一样的，即gcd(a,b)&#x3D;gcd(b,a mod b)。</p><h1 id="字符串的回环变位"><a href="#字符串的回环变位" class="headerlink" title="字符串的回环变位"></a>字符串的回环变位</h1><p>算法1.2.6。如果字符串 s 中的字符循环移动任意位置之后能够得到另一个字符串 t，那么 s 就被称为 t 的回环变位（circular rotation）。例如，ACTGACG就是TGACGAC的一个回环变位，反之亦然。判定这个条件在基因组序列的研究中是很重要的。编写一个程序检查两个给定的字符串 s 和 t 是否互为回环变位。提示：答案只需要一行用到indexOf() ，length() 和字符串连接的代码。</p><p>思路1：将字符串分成左右2部分，检查左右两边字符串互换之后可否得到原来的字符串<br>思路2：模拟回环变位的过程，不断将字符串的首字符移动到字符串末尾<br>思路3：比较巧妙。将原字符串重复2次，相当于字符串首尾相连了，然后判断字符串是否是这个首尾相连的字符串的子串。这个解法简直酷毙了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">s, t</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> left = s.<span class="title function_">substring</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">const</span> right = s.<span class="title function_">substring</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (right + left === t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">s, t</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.<span class="title function_">substring</span>(<span class="number">1</span>) + s.<span class="title function_">charAt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn3</span> = (<span class="params">s, t</span>) =&gt; s.<span class="property">length</span> === t.<span class="property">length</span> &amp;&amp; s.<span class="title function_">repeat</span>(<span class="number">2</span>).<span class="title function_">includes</span>(t);</span><br></pre></td></tr></table></figure><h1 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h1><p>下面的代码中平均数和方差的计算采用了每向累加器中添加一个数后根据已有的方差和标准差实时计算，而不是要取值的时候，求和、求均值，然后求平方和，求方差，思路比较清奇。这种方式和直接对所有数据平方求和的方式相比较能够很好避免四舍五入带来的误差。记录如下，证明过程参见<a href="https://www.zhihu.com/question/59252399">知乎</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">s</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">n</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addDataValue</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = ++<span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">        <span class="keyword">const</span> m = <span class="variable language_">this</span>.<span class="property">m</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">s</span> = <span class="variable language_">this</span>.<span class="property">s</span> + (n - <span class="number">1</span>) / n * (x - m) * (x - m);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = m + (x - m) / n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">mean</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">var</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">s</span> / (<span class="variable language_">this</span>.<span class="property">n</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">stddev</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="variable language_">this</span>.<span class="property">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="洗牌算法的正确性证明"><a href="#洗牌算法的正确性证明" class="headerlink" title="洗牌算法的正确性证明"></a>洗牌算法的正确性证明</h1><p>洗牌也就是排列，把这n张牌任意排列，总共有n!种。为了保证随机，那么我的洗牌策略，不管怎么洗，都应该是1&#x2F;n!。</p><p>Fisher–Yates shuffle算法的正确性：</p><p>第一张牌抽取的概率为1&#x2F;n,第二张牌是1&#x2F;(n-1),….，第i张牌概率是1&#x2F;(n-i),..。那么这种洗牌策略的概率是1&#x2F;n*1&#x2F;(n-1)<em>1&#x2F;(n-2)</em>…*1&#x2F;1，即1&#x2F;n!</p><p>下面这种经常被写错的算法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">worseShuffle</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = _.<span class="title function_">random</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        [arr[i], arr[r]] = [arr[r], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种算法相当于放回取样，概率为 1 &#x2F; n ^ n,并不能保证真正的公平。</p><h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>为什么数组缩容的的时候检测条件是是否已经占用了1&#x2F;4的空间将其调整为1&#x2F;2的空间而不是检测1&#x2F;2的空间将其调整为1&#x2F;2的空间。</p><p>假设动态数组的size为1&#x2F;2的capacity，当取出一个元素的时候容量变为1&#x2F;2 capacity，再放入一个元素的时候数组满了，接着再放一个元素的时候容量不够会触发扩容，接着取出2个元素会触发缩容。即如果检测条件为1&#x2F;2会频繁触发数组的扩容和缩容，开销太大。检测条件为1&#x2F;2则多了很大一部分缓冲，在这个实现中数组最多有3&#x2F;4的空间浪费。</p><h1 id="出栈顺序和卡塔兰数"><a href="#出栈顺序和卡塔兰数" class="headerlink" title="出栈顺序和卡塔兰数"></a>出栈顺序和卡塔兰数</h1><p>算法4习题1.3.3。假设某个用例程序会进行一系列入栈和出栈操作。入栈操作会将整数0到9按顺序压入栈；出栈操作会打印返回值。下面哪种顺序是不可能产生的？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a)  4 3 2 1 0 9 8 7 6 5</span><br><span class="line">(b)  4 6 8 7 5 3 2 9 0 1</span><br><span class="line">(c)  2 5 6 7 4 8 9 3 1 0</span><br><span class="line">(d)  4 3 2 1 0 5 6 7 8 9</span><br><span class="line">(e)  1 2 3 4 5 6 9 8 7 0</span><br><span class="line">(f)  0 4 6 5 3 8 1 7 2 9</span><br><span class="line">(g)  1 4 7 9 8 6 5 3 0 2</span><br><span class="line">(h)  2 1 4 3 6 5 8 7 9 0</span><br></pre></td></tr></table></figure><p>分析3个数时的入栈与出栈操作，所有的顺序有3!种。分别为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>可以知道只有 3 1 2 这种顺序不可能的，将其推广就可以得到这种的规律:”大 小 中”这种顺序是不能出现的。如上述中(b)中的9 0 1，(f)中的8 1 7，(g)中的3 0 2。所以b, f, g是不能产生的。</p><blockquote><p>算法1.3.46中给出一个结论。如果有三元组(a,b,c)满足a &lt; b &lt; c，弹出相对顺序为c,a,b(c,a,b之间可以间隔其他整数)。当且仅当不存在这样的三元组的时候栈才可以生成它。</p></blockquote><blockquote><p>解答：反证法。假设c会在a和b之前被弹出，但a和b会在c之前被压入。因此，当c被压入的时候，a和b已经在栈中了，所以a不可能在b之前被弹出。</p></blockquote><p>①对于出栈序列中的每一个数字，在它后面的、比它小的所有数字，一定是按递减顺序排列的。</p><p>比如入栈顺序为：1 2 3 4。</p><p>出栈顺序：4 3 2 1是合法的，对于数字 4 而言，比它小的后面的数字是：3 2 1，且这个顺序是递减顺序。同样地，对于数字 3 而言，比它小的后面的数字是： 2 1，且这个顺序是递减的。….</p><p>出栈顺序：1 2 3 4 也是合法的，对于数字 1 而言，它后面没有比它更小的数字。同样地，对于数字 2 而言，它后面也没有比它更小的数字。</p><p>出栈顺序：3 2 4 1 也是合法的，对于数字 3 而言，它后面比 3 小的数字有： 2 1，这个顺序是递减的；对于数字 2 而言，它后面的比它 小的数字只有 1，也算符合递减顺序；对于数字 4 而言，它后面的比它小的数字也只有1，因此也符合递减顺序。</p><p>出栈顺序：3 1 4 2 是不合法的，因为对于数字 3 而言，在3后面的比3小的数字有：1 2，这个顺序是一个递增的顺序(1–&gt;2)。</p><p>因此，当给定一个序列时，通过这个规律 可以轻松地判断 哪些序列是合法的，哪些序列是非法的。</p><p>②给定一个入栈顺序：1  2  3 …. n，一共有多少种合法的出栈顺序？参考：<a href="https://blog.csdn.net/doc_sgl/article/details/8880468">卡特兰数</a></p><p>答案是 卡特兰数。即一共有：h(n)&#x3D;c(2n,n)&#x2F;(n+1) 种合法的出栈顺序。</p><p>方法1：模拟入栈和出栈的过程。终止条件是所有元素已经入栈，并且栈为空。对于每一步操作有2种，入栈和出栈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getAllSeq</span> = nums =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part, stack</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len &amp;&amp; stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(part);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">let</span> newStack = stack.<span class="title function_">concat</span>(nums[index]);</span><br><span class="line">            <span class="title function_">dfs</span>(index + <span class="number">1</span>, part, newStack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> top = stack[stack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">let</span> newStack = stack.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="title function_">dfs</span>(index, part.<span class="title function_">concat</span>(top), newStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, [], []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">getAllSeq</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">arr</span> =&gt;</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br></pre></td></tr></table></figure><p>注意上述对栈的操作先进行了<em>保护性复制</em>，不需要对元素进行还原了,另一种比较容易出错的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part, stack</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === len &amp;&amp; stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(part.<span class="title function_">slice</span>()); <span class="comment">// 保护性复制</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; len) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">        <span class="title function_">dfs</span>(index + <span class="number">1</span>, part, stack);</span><br><span class="line">        stack.<span class="title function_">pop</span>(); <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> top = stack.<span class="title function_">pop</span>();</span><br><span class="line">        part.<span class="title function_">push</span>(top);</span><br><span class="line">        <span class="title function_">dfs</span>(index, part, stack);</span><br><span class="line">        stack.<span class="title function_">push</span>(top); <span class="comment">// 还原</span></span><br><span class="line">        part.<span class="title function_">pop</span>(); <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方案2：对数字进行全排列，验证序列的合法性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列</span></span><br><span class="line"><span class="comment">// 123 =&gt; 123,132,231,213,312,321 一共6个</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">permutation</span> = nums =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 + &#123;2,3&#125;的全排列 2 + &#123;1,3&#125;的全排列 3 + &#123;1,3&#125;的全排列</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(part.<span class="title function_">slice</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前索引和index交换</span></span><br><span class="line">            <span class="title function_">swap</span>(part, i, index);</span><br><span class="line">            <span class="title function_">dfs</span>(index + <span class="number">1</span>, part);</span><br><span class="line">            <span class="comment">// 再交换回来</span></span><br><span class="line">            <span class="title function_">swap</span>(part, index, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">checkIsValidSeq</span> = seq =&gt; &#123;</span><br><span class="line">    <span class="comment">// 合法序列：出栈序列中的每一个数字，比它小的数字，一定是按照递减顺序排列的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">check</span> = index =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = seq[index];</span><br><span class="line">        <span class="keyword">const</span> afterLessThan = seq.<span class="title function_">slice</span>(index).<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; afterLessThan.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = afterLessThan[i];</span><br><span class="line">            <span class="keyword">let</span> n = afterLessThan[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c &lt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; seq.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">check</span>(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getAllSeq2</span> = nums =&gt; <span class="title function_">permutation</span>(nums).<span class="title function_">filter</span>(<span class="function"><span class="params">seq</span> =&gt;</span> <span class="title function_">checkIsValidSeq</span>(seq));</span><br></pre></td></tr></table></figure><p>算法1.3.45.假设我们的栈测试用例会进行一系列的入栈和出栈操作，序列中的整数 0, 1, … , N - 1 （按此先后顺序排列）表示入栈操作，N个减号表示出栈操作。设计一个算法，判定给定的混合序列是否会使数组向下溢出（你使用的空间量与 N 无关，即不能用某种数据结构存储所有整数）。设计一个线性时间算法判定我们的测试用例能否产生某个给定的排列（这取决于出栈操作指令的出现位置）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性时间判断入列出列顺序的合法性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve1</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        cnt += num == <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定指定出栈顺序，求出对应的入栈和出栈操作</span></span><br><span class="line"><span class="comment">// 对于某个整数k，前k次出栈操作会在前k次入栈操作之前完成，否则栈不会向下移除。</span></span><br><span class="line"><span class="comment">// 如果某个排列可以产生，那么产生它的方式一定是唯一的：如果输出排列中的下一个整数在栈顶，则将它弹出，否则将其压入栈中。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve2</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    <span class="keyword">const</span> ops = [];</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    stack.<span class="title function_">push</span>(n);</span><br><span class="line">    ops.<span class="title function_">push</span>(n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nums.<span class="property">length</span> &amp;&amp; stack.<span class="title function_">peek</span>() != nums[i]) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(n);</span><br><span class="line">            ops.<span class="title function_">push</span>(n);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="title function_">peek</span>() != nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">        ops.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve1</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve2</span>([<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve2</span>([<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>]));</span><br></pre></td></tr></table></figure><p><a href="http://ceeji.net/blog/forbidden-triple-for-stack-generability/">合法栈输出顺序的充要条件</a></p><blockquote><p>不同于 Stack，对于 Queue 来说，如果是执行一系列的入列出列的混合操作，则合法的顺序只有入列的顺序，因为队列的顺序一定是先进先出的。</p></blockquote><h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><p>n个人围城一个圈，按照1，2，3…n开始报数，报k的被杀掉，下一个从1开始重新报数，如此往复直到剩下一个人，如何确定自己的序号从而不被杀掉。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/josephus-ring.webp" alt="一共5人，数到3被杀，序号为4"></p><p>使用队列模拟上述过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    q.<span class="title function_">enqueue</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = q.<span class="title function_">dequeue</span>();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kill&#x27;</span>, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.<span class="title function_">enqueue</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位置4就是我们最后不被杀死的位置。可以将上述模型抽象为：</p><blockquote><p>已知：总共有n个人，数到m的人将被杀死，并重新从1计数；求位置p使得该位置最后被杀死。</p></blockquote><p>现在考虑一种泛化情形：总共有 n 个人，数到 k 的人被杀掉，其中 n &gt;&#x3D; k。幸存者的位置为 p<sub>n</sub> 。<br>显而易见，初始位置为 k 的人将会第一个被杀掉。此时，经过重新排序之后，问题变成了 n-1 个人的情形。幸存者的位置为 p<sub>n-1</sub> 。如果能够找到从 p<sub>n-1</sub> 到 p<sub>n</sub> 的递推关系，那么问题就解决了。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/josephus-ring-solve.png" alt="约瑟夫环的推理求解"></p><p>重新排序之后，每个人的位置发生了下面这些变化：</p><ul><li>1 -&gt; n-k+1</li><li>2 -&gt; n-k+2</li><li>…</li><li>k-1 -&gt; n-1</li><li>k 被杀死</li><li>k+1 -&gt; 1</li><li>…</li><li>p<sub>n</sub> -&gt; p<sub>n-1</sub></li><li>…</li><li>n-1 -&gt; n-k+1</li><li>n -&gt; n-k</li></ul><p>从右边的式子反推左边的式子，可以得到：p<sub>n</sub> &#x3D; (p<sub>n-1</sub> + k) % n。只有一个人的情况则：p<sub>1</sub> &#x3D; 0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用递推式，求出正确的位置 fn = (fn-1 + k) % n;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve</span> = (<span class="params">n, k</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="title function_">solve</span>(n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">const</span> ret = (a + k) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">solve</span>(n, m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num = &#x27;</span>, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve2</span> = (<span class="params">n, k</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index = (index + k) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参考：<a href="https://blog.csdn.net/wusuopubupt/article/details/18214999">约瑟夫环递推方程的推导</a></li></ul><h1 id="链表中虚拟头结点的应用"><a href="#链表中虚拟头结点的应用" class="headerlink" title="链表中虚拟头结点的应用"></a>链表中虚拟头结点的应用</h1><ul><li>删除第k个节点</li></ul><h1 id="环形队列和缓冲区"><a href="#环形队列和缓冲区" class="headerlink" title="环形队列和缓冲区"></a>环形队列和缓冲区</h1><p>RingBuffer一种固定尺寸的、头尾相连的缓冲区数据结构，又称为环形队列，拥有读写指针，在进程间异步数据传输或者记录日志文件的时候非常有用。当缓冲区空的时候不能读取数据，在缓冲区满的时候不能写数据.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        capacity += <span class="number">1</span>; <span class="comment">// 多分配一个，最后一个空间不存储数据，这样判断缓冲区满和缓冲区空就很方便了</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>; <span class="comment">// 下一次读的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一次写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> === <span class="variable language_">this</span>.<span class="property">writePos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isFull</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span> === <span class="variable language_">this</span>.<span class="property">readPos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>] = item;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = (<span class="variable language_">this</span>.<span class="property">readPos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer2</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一个要写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span> = <span class="number">0</span>; <span class="comment">// 有效元素个数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">avaiable</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>] = item;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">avaiable</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> readPos = <span class="variable language_">this</span>.<span class="property">writePos</span> - <span class="variable language_">this</span>.<span class="property">avaiable</span>;</span><br><span class="line">        <span class="keyword">if</span> (readPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            readPos += <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">data</span>[readPos];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span>--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个flip标记写指针是否到了读指针之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer3</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一个要写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>; <span class="comment">// 下一个要读的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">false</span>; <span class="comment">// 写指针是否到了读指针之前 </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">flipped</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> === <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> &gt;= <span class="variable language_">this</span>.<span class="property">readPos</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>++] = item;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> &gt;= <span class="variable language_">this</span>.<span class="property">readPos</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">flipped</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> &lt; <span class="variable language_">this</span>.<span class="property">writePos</span> ? <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++] : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readPos</span> === <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> &lt; <span class="variable language_">this</span>.<span class="property">writePos</span> ? <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++] : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="http://tutorials.jenkov.com/java-performance/ring-buffer.html">环形队列的实现</a></p><h1 id="前移编码、缓存和数据压缩"><a href="#前移编码、缓存和数据压缩" class="headerlink" title="前移编码、缓存和数据压缩"></a>前移编码、缓存和数据压缩</h1><p>问题来源：算法1.3.40。使用链表保存一系列字符并删除重复字符。当你读取了一个从未见过的字符时，将它插入表头。当你读取了一个重复的字符时，将它从链表中删去并再次插入表头。它实现了<em>前移编码策略</em>。这种策略假设最近访问过的元素很可能会再次访问，因此可以用于缓存、数据压缩等许多场景。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveToFront</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(char, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = cur.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">if</span> (!next) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.<span class="property">value</span> == char) &#123;</span><br><span class="line">                cur.<span class="property">next</span> = next.<span class="property">next</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">data</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = [];</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            data.<span class="title function_">push</span>(cur.<span class="property">value</span>);</span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h1><p>算法1.3.43。第一反应是用DFS来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">listFiles</span> = (<span class="params">dir, depth</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> absolutePath = path.<span class="title function_">resolve</span>(dir);</span><br><span class="line">    <span class="keyword">const</span> stat = fs.<span class="title function_">statSync</span>(absolutePath);</span><br><span class="line">    <span class="keyword">if</span> (stat.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(absolutePath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">            <span class="title function_">listFiles</span>(path.<span class="title function_">join</span>(absolutePath, file), depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-&#x27;</span>.<span class="title function_">repeat</span>(depth), absolutePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目中说要使用队列来做,怎么感觉还是用的DFS的思想：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">listFiles2</span> = (<span class="params">dir, depth, queue</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> absolutePath = path.<span class="title function_">resolve</span>(dir);</span><br><span class="line">    <span class="keyword">const</span> stat = fs.<span class="title function_">statSync</span>(absolutePath);</span><br><span class="line">    <span class="keyword">if</span> (stat.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">        queue.<span class="title function_">enqueue</span>(&#123; <span class="attr">file</span>: dir, depth &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(absolutePath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">            <span class="title function_">listFiles2</span>(path.<span class="title function_">join</span>(absolutePath, file), depth + <span class="number">1</span>, queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Queue</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedQueue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="title function_">listFiles2</span>(<span class="string">&#x27;/Users/yiihua-013/consoles-projects/dsa4js/test&#x27;</span>, <span class="number">0</span>, q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> q) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-&#x27;</span>.<span class="title function_">repeat</span>(item.<span class="property">depth</span>), item.<span class="property">file</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈与文件编辑器的缓冲区"><a href="#栈与文件编辑器的缓冲区" class="headerlink" title="栈与文件编辑器的缓冲区"></a>栈与文件编辑器的缓冲区</h1><p>问题来源算法1.3.44。思路：建立两个栈，一个左栈，一个右栈，输入时将数据压入左栈，其实光标位置就是左栈的栈头，向左向右移动就是其中一个栈pop一些元素给另一个栈来模拟光标移动。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorBuffer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leftStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rightStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在光标位置插入字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">push</span>(char);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回光标位置的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">delete</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将光标左移k个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">left</span>(<span class="params">k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将光标右移k个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">right</span>(<span class="params">k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="property">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区中的字符数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span> + <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inspect</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="keyword">const</span> tmpStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>) &#123;</span><br><span class="line">            tmpStack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> left = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> tmpStack) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> right = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">rightStack</span>) &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`pos = <span class="subst">$&#123;pos&#125;</span>,size = <span class="subst">$&#123;<span class="variable language_">this</span>.size()&#125;</span>,left = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(left)&#125;</span>,right = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(right)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">EditorBuffer</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&#x27;sfdssemkf&#x27;</span>) &#123;</span><br><span class="line">    buf.<span class="title function_">insert</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">buf.<span class="title function_">left</span>(<span class="number">4</span>);</span><br><span class="line">buf.<span class="title function_">delete</span>();</span><br><span class="line">buf.<span class="title function_">right</span>(<span class="number">2</span>);</span><br><span class="line">buf.<span class="title function_">insert</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">buf.<span class="title function_">right</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);</span><br></pre></td></tr></table></figure><h1 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h1><p>问题来源：算法1.3.49.使用有限个栈模拟队列，保证入队和出队操作在最坏情况下只需要常数时间。</p><p>很容易想到使用2个栈模拟队列。入队的时候向enqueStack中push元素，出队的时候从dequeStack中pop元素。dequeStack中的元素来源于dequeStack为空的时候将enqueStack移动到此位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2个栈模拟队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">enqueStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dequeStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队操作为O(1)，出队操作为O(N)，不满足题目要求。使用6个栈均摊复杂度可以保证入队和出队的复杂度为O(1)。</p><p>参考:</p><p><a href="https://www.cnblogs.com/ikesnowy/p/7157813.html">使用6个栈实现O(1)队列</a></p><h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p>从n个数中取出3个不同数的组合是C<sub>n</sub><sup>3</sup> &#x3D; <code>n(n-1)(n-2)/6</code>。</p><p>所以以下代码中cnt的值为10，而不是<code>5*4*3 = 60</code>!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定性分析：</p><p>i &#x3D; 0,j &#x3D; 1,k &#x3D; 2,3,4 &#x3D;&gt; 3<br>i &#x3D; 0,j &#x3D; 2,k &#x3D; 3,4   &#x3D;&gt; 2<br>i &#x3D; 0,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1</p><p>i &#x3D; 1,j &#x3D; 2,k &#x3D; 3,4   &#x3D;&gt; 2<br>i &#x3D; 1,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1</p><p>i &#x3D; 2,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1 </p><p>总和: (3 + 2 + 1) + (2 + 1) + 1 &#x3D; 10。</p><p>5 * 4 * 3之所以错的原因是，没有考虑内循环条件的约束！</p><h1 id="幂次法则和倍率实验"><a href="#幂次法则和倍率实验" class="headerlink" title="幂次法则和倍率实验"></a>幂次法则和倍率实验</h1><p>以three-sum为例，该算法的复杂度为O(N^3):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">count</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MAX</span> = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(_.<span class="title function_">random</span>(-<span class="variable constant_">MAX</span>, <span class="variable constant_">MAX</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">const</span> cnt = <span class="title function_">count</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cnt,</span><br><span class="line">        <span class="attr">elapsedTime</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() - start</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">let</span> prev = <span class="title function_">test</span>(n);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    n += n;</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="title function_">test</span>(n);</span><br><span class="line">    <span class="keyword">const</span> &#123; cnt, elapsedTime &#125; = cur;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n, cnt, elapsedTime, elapsedTime / prev.<span class="property">elapsedTime</span>);</span><br><span class="line">    prev = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">500 5 33 3.3</span><br><span class="line">1000 63 225 6.818181818181818</span><br><span class="line">2000 490 1709 7.595555555555555</span><br><span class="line">4000 3940 13493 7.895260386190754</span><br><span class="line">8000 31565 107293 7.951752760690728</span><br></pre></td></tr></table></figure><p>可以发现：当数据规模翻倍的时候，运行的时间的翻倍数量为8 &#x3D; 2^3。实际上对于大多数程序运行的时间可以写成:T(N) ~ aN^b·lgN，因此T(2N)&#x2F;T(N) ~ 2^b。倍率定理适合于<em>非指数级别的算法</em>，可以用来简单估算程序的运行时间。</p><blockquote><p>实际上，大多数现代计算机系统会使用缓存技术来组织内存（程序的局部性原理），在这种情况下访问大数组中的若干并不相邻的元素可能会比较长。上面的例子中看似运行时间的比例收敛到了8，但是到了后面数组规模变得很大了之后这个比例可能变成一个很大的值。这也是理论上快排和归并排序时间复杂度一样但是快排更快的原因。</p></blockquote><h1 id="二项式定理及其证明"><a href="#二项式定理及其证明" class="headerlink" title="二项式定理及其证明"></a>二项式定理及其证明</h1><p>问题来源：练习1.4.1。使用数学归纳法证明从N个数中取3个数的不同组合的总数为 N(N-1)(N-2)&#x2F;6。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(N, 3) = N! / [(N - 3)! × 3!]</span><br><span class="line">        = [(N - 2) * (N - 1) * N] / 3!</span><br><span class="line">        = N(N - 1)(N - 2) / 6</span><br></pre></td></tr></table></figure><p>显然N必须大于等于3，当N &#x3D; 3时等式成立，只有一种组合，当N&#x3D;4时等式也成立，4种组合。当拓展到N+1个数的时候可以理解为：<em>前 N 个数中取三个数的所有组合 + 多出的一个数和前 N 个数中的任意取两个数的所有组合</em>。</p><p>即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C(N+1,3) = C(N,3) + C(N,2)</span><br><span class="line">        = N(N - 1)(N - 2) / 6 + (N!/[(N-2)! * 2!])</span><br><span class="line">        = N(N - 1)(N - 2) / 6 + N(N - 1) / 2</span><br><span class="line">        = [N(N-1)(N-2) + N(N-1)*3] / 6</span><br><span class="line">        = N(N-1)(N-2+3) / 6</span><br><span class="line">        = (N+1)N(N-1) / 6</span><br></pre></td></tr></table></figure><h1 id="二分查找的思想及其应用"><a href="#二分查找的思想及其应用" class="headerlink" title="二分查找的思想及其应用"></a>二分查找的思想及其应用</h1><h2 id="局部最小元素"><a href="#局部最小元素" class="headerlink" title="局部最小元素"></a>局部最小元素</h2><p>二分查找可以使用<code>lgN</code>的复杂度在<strong>有序数组</strong>中找到指定元素。但是普通数组也可以使用二分查找的思想，例如：习题1.4.18</p><blockquote><p> 数组的局部最小元素。编写一个程序，给定一个含有 N 个不同整数的数组，找到一个局部最小元素：满足 a[i] &lt; a[i-1]，且 a[i] &lt; a[i+1] 的索引 i。程序在最坏情况下所需的比较次数为 ~ 2lgN。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法 O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">localMin1</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>] &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数组中间值a[N/2]以及它相邻的元素a[N/2-1]和a[N/2+1]。如果a[N/2]是一个局部最小值则算法终止；否则在较小的相邻元素的那一侧查找</span></span><br><span class="line"><span class="comment">// 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。O(lgN)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">localMin2</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> index = <span class="title function_">localMin2</span>(arr);</span><br></pre></td></tr></table></figure><blockquote><p>习题1.4.19。矩阵的局部最小元素。给定一个含有 N ^ 2 个不同整数的 N×N 数组 a[]。设计一个运送时间和 N 成正比的算法来找出一个局部最小元素：满足 a[i][j] &lt; a[i + 1][j]、a[i][j] &lt; a[i][j + 1]、a[i][j] &lt; a[i - 1][j] 以及 a[i][j] &lt; a[i][j - 1] 的索引 i 和 j。程序运行时间在最坏情况下应该和 N 成正比。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(N^2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span> (item &lt; matrix[i + <span class="number">1</span>][j] &amp;&amp; item &lt; matrix[i][j + <span class="number">1</span>] &amp;&amp; item &lt; matrix[i - <span class="number">1</span>][j] &amp;&amp; item &lt; matrix[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂度为O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findMinCol</span> = (<span class="params">matrix, midRow, colStart, colEnd</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">    <span class="keyword">let</span> colPos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = colStart; i &lt; colEnd; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[midRow][i] &lt; min) &#123;</span><br><span class="line">            min = matrix[midRow][i];</span><br><span class="line">            colPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lgN</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findLocalmin</span> = (<span class="params">matrix, rowStart, rowEnd, colStart, colEnd</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> midRow = rowStart + <span class="title class_">Math</span>.<span class="title function_">floor</span>((rowEnd - rowStart) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> minColPos = <span class="title function_">findMinCol</span>(matrix, midRow, colStart, colEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> midRowMin = matrix[midRow][minColPos]; <span class="comment">// 中间行中的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要和 上一行 &amp; 下一行比较就行</span></span><br><span class="line">    <span class="keyword">if</span> (midRowMin &lt; matrix[midRow + <span class="number">1</span>][minColPos] &amp;&amp; midRowMin &lt; matrix[midRow - <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [midRow, minColPos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间一行的最小值大于下一行，则说明下一行中间值比较小，在矩阵的下半部分继续寻找</span></span><br><span class="line">    <span class="keyword">if</span> (midRowMin &gt; matrix[midRow + <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, midRow, rowEnd, colStart, colEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, rowStart, midRow, colStart, colEnd);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix2</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> end = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, <span class="number">0</span>, end, <span class="number">0</span>, end);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix3</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> minRowIndex = <span class="number">0</span>, maxRowIndex = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (minRowIndex &lt;= maxRowIndex) &#123;</span><br><span class="line">        <span class="keyword">const</span> midRowIndex = minRowIndex + <span class="title class_">Math</span>.<span class="title function_">floor</span>((maxRowIndex - minRowIndex) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> min = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">        <span class="keyword">let</span> minColPos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[midRowIndex][i] &lt; min) &#123;</span><br><span class="line">                min = matrix[midRowIndex][i];</span><br><span class="line">                minColPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = matrix[midRowIndex][minColPos];</span><br><span class="line">        <span class="keyword">if</span> (item &lt; matrix[midRowIndex - <span class="number">1</span>][minColPos] &amp;&amp; item &lt; matrix[midRowIndex + <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [midRowIndex, minColPos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item &gt; matrix[midRowIndex - <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">            maxRowIndex = midRowIndex - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minRowIndex = midRowIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">9</span>, -<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = <span class="title function_">minMatrix2</span>(matrix);</span><br></pre></td></tr></table></figure><p>上面的解法2是一种“滚下山”(roll downhill)的方式。首先找到中间行，并在中间行中找到该行的最小值，然后判断它在该列中是不是局部最小值，如果是的话，那就返回这个值，否则向该列的最小一侧方向移动，如此循环往复。这个过程有点像在群山连绵的地方找到一个水池。</p><p><a href="https://stackoverflow.com/questions/18525179/find-local-minimum-in-n-x-n-matrix-in-on-time/24461101#24461101">在O(n)的时间内在n*n的方阵中找到局部最小值</a></p><p>习题1.4.20。如果一个数组中的所有元素是先递增后递减的，则称这个数组为双调的。编写一个程序，给定一个含有 N 个不同 int 值的双调数组，判断它是否含有给定的整数。程序在最坏情况下所需的比较次数为 ~3lgN。</p><p>很容易想到的是O(N)的算法，仔细观察数组可以发现：双调数组存在一个最大值，我们可以使用1.4.18中的方法在lgN的时间内取得数组最大元素，这样数组左右两侧都是有序数组了，可以使用二分查找分别在左右两个子数组中进行查找。最坏的复杂度为3lgN。注意：二分查找的算法稍有改动，支持自定义的比较器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">localMax</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;检查输入&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在3lgN时间内判断双调数组中是否有指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">find</span> = (<span class="params">nums, num</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> binarySearch = <span class="built_in">require</span>(<span class="string">&#x27;../../binarySearch&#x27;</span>).<span class="property">binarySearch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxIndex = <span class="title function_">localMax</span>(nums); <span class="comment">// lgN得到最大元素</span></span><br><span class="line">    <span class="keyword">const</span> max = nums[maxIndex];</span><br><span class="line">    <span class="keyword">if</span> (num &gt; max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num === max) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> left = nums.<span class="title function_">slice</span>(<span class="number">0</span>, maxIndex);</span><br><span class="line">    <span class="keyword">const</span> right = nums.<span class="title function_">slice</span>(maxIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 分别向左和向右进行二分搜索</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">binarySearch</span>(left, num, <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(right, num, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">100</span>, <span class="number">89</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">find</span>(arr, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>源自算法1.4.22。这种查找的精髓在于<em>采用最接近长度的斐波那契数值来确定拆分点</em>。例如：对于现有长度为9的数组，要对它进行拆分，对应的斐波那契数列（长度先随便取，只要最大数大于9即可）{ 1，1，2，3，5，8，13，21 } ，不难发现，大于9且最接近9的斐波那契数值是f[6] &#x3D; 13，为了满足所谓的黄金分割，所以它的第一个拆分点应该就是f[6]的前一个值f[5] &#x3D; 8，即待查找数组array的第8个数，对应到下标就是array[7]，依次类推。</p><p><em>推演到一般情况，假设有待查找数组array[n]和斐波那契数组F[k],并且n满足n&gt;&#x3D;F[k]-1&amp;&amp;n &lt; F[k+1]-1，则它的第一个拆分点middle&#x3D;F[k]-1</em>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(5) - 1 = 7</span><br><span class="line">F(6) - 1 = 12</span><br><span class="line">9 &gt;= F(5) - 1 &amp;&amp; 9 &lt; F(6) - 1</span><br><span class="line">所以切分点为F(5) - 1 = 7</span><br></pre></td></tr></table></figure><p>这里得注意，如果n刚好等于F[k]-1,待查找数组刚好拆成F[k-1]和F[k-2]两部分，那万事大吉你好我好；然而大多数情况并不能尽人意，n会小于F[k]-1,这时候可以拆成完整F[k-1]和残疾的F[k-2]两部分，那怎么办呢？聪明的前辈们早已想好了解决办法，对了，就是补齐，用最大的数来填充F[k-2]的残缺部分，如果查找的位置落到补齐的部分，那就可以确定要找的那个数就是最后一个最大的了。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fib-partion.jpg" alt="斐波那契查找-切分"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建最大值刚好&gt;=待查找数组长度的裴波纳契数组  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">makeFibArray</span> = arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> a = [first, second];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> current = first + second;</span><br><span class="line">        a.<span class="title function_">push</span>(current);</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= len) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = second;</span><br><span class="line">        second = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fibSearch</span> = (<span class="params">nums, num</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fibArr = <span class="title function_">makeFibArray</span>(nums); <span class="comment">// 斐波那契数组</span></span><br><span class="line">    <span class="keyword">const</span> filledLength = fibArr[fibArr.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 填充数组长度</span></span><br><span class="line">    <span class="comment">// 构建填充数组：填充数组长度为大于等于待查找数组长度向上取整的斐波那契数</span></span><br><span class="line">    <span class="comment">// 前一部分为待查找数组，后部分用原数组的最后一个元素填充</span></span><br><span class="line">    <span class="keyword">const</span> filledArray = <span class="keyword">new</span> <span class="title class_">Array</span>(filledLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        filledArray[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> last = nums[nums.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.<span class="property">length</span>; i &lt; filledLength; i++) &#123;</span><br><span class="line">        filledArray[i] = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> k = fibArr.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 用来控制子数组的左右边界</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + fibArr[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; filledArray[mid]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; filledArray[mid]) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid &gt; hi ? hi : mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h2><p>算法1.4.24。假设你面前有一栋 N 层的大楼和许多鸡蛋，假设将鸡蛋从 F 层或者更高的地方扔下鸡蛋才会摔碎，否则则不会。首先，设计一种策略来确定 F 的值，其中扔 <del>lgN 次鸡蛋后摔碎的鸡蛋数量为 ~lgN。然后想办法将成本降低到</del>2lgF。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs</span> = N =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; F) &#123;</span><br><span class="line">            <span class="comment">// 鸡蛋可以碎</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            brokenCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid === F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            hi = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F = &#x27;</span>, hi, <span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次鸡蛋,碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照第 1, 2, 4, 8,…, 2^k 层顺序查找，一直到 2^k &gt; F,随后在 [2^(k - 1), 2^k] 范围中二分查找</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs2</span> = N =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hi &lt; F) &#123;</span><br><span class="line">        lo = hi;</span><br><span class="line">        hi *= <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hi === F) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; F) &#123;</span><br><span class="line">            <span class="comment">// 鸡蛋可以碎</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            brokenCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid === F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            hi = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F = &#x27;</span>, hi, <span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次鸡蛋,碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">throwEggs</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="title function_">throwEggs2</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>算法1.4.25。但现在假设你只有两个鸡蛋，而你的成本模型则是扔鸡蛋的次数。设计一种策略，最多扔 2√(N) 次鸡蛋即可判断出 F 的值， 然后想办法把这个成本降低到 ~c√(F) 次。 这和查找命中（鸡蛋完好无损）比未命中（鸡蛋被摔碎）的成本小得多的情形类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs3</span> = N =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个蛋: 第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),…, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k &lt;= √(N)。</span></span><br><span class="line">    <span class="keyword">while</span> (hi &lt; F) &#123;</span><br><span class="line">        lo = hi;</span><br><span class="line">        count++;</span><br><span class="line">        hi += <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照斐波那契递增</span></span><br><span class="line">    <span class="comment">// for (let i = 0; hi &lt; F; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     count++;</span></span><br><span class="line">    <span class="comment">//     lo = hi;</span></span><br><span class="line">    <span class="comment">//     hi += i;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    brokenCount++;</span><br><span class="line">    hi = <span class="title class_">Math</span>.<span class="title function_">min</span>(hi, N);</span><br><span class="line">    <span class="keyword">if</span> (hi === F) <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个蛋：k-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次    </span></span><br><span class="line">    <span class="comment">// 不能用二分查找，找到一个比较小的值，然后向右推进</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lo++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次，碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个蛋，找到F= &#x27;</span>, F);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="冷还是热问题"><a href="#冷还是热问题" class="headerlink" title="冷还是热问题"></a>冷还是热问题</h2><p>问题来源：算法1.4.34。你的目标是猜出 1 到 N 之间的一个秘密的整数。每次猜完一个整数后，你会直到你的猜测距离该秘密整数是否相等（如果是则游戏结束）。如果不相等，你会知道你的猜测相比上一次猜测距离秘密整数是比较热（接近），还是比较冷（远离）。设计一个算法在 ~2lgN 之内找到这个秘密整数，然后设计一个算法在 ~1lgN 之内找到这个秘密整数。</p><p>方案一：二分查找。先猜测左边界(lo) ，再猜测右边界(hi) ，如果边界值猜中的话直接返回，否则如果右边界比较热，那么左边界向右边界靠，lo &#x3D; mid；否则，右边界向左边界靠，hi &#x3D; mid。其中，mid &#x3D; lo + (hi – lo) &#x2F; 2。每次二分查找的时候需要猜测2次lo和hi，复杂度~2LgN。</p><p>方案二:假设上次猜测值为 lastGuess，本次即将要猜测的值为 nowGuess，通过方程：(lastGuess+nowGuess)&#x2F;2&#x3D;(lo+hi)&#x2F;2 可以求得 nowGuess，具体可以查看示意图：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/cold-or-hot.png" alt="冷还是热"></p><p>数字是猜测顺序，黑色范围是猜测值的范围（lastGuess 和 nowGuess），绿色的是实际查找的范围（lo 和 hi）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">GUESS_RESULT</span> = &#123;</span><br><span class="line">    <span class="attr">COLD</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;cold&#x27;</span>),</span><br><span class="line">    <span class="attr">HOT</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;hot&#x27;</span>),</span><br><span class="line">    <span class="attr">EQ</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;eq&#x27;</span>),</span><br><span class="line">    <span class="attr">FIRST_GUESS</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;first_guess&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">N</span> = <span class="number">100000</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">MAGIC</span> = <span class="number">33</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastGuess</span> = -<span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">guessCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">guess</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">guessCount</span>++;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="variable language_">this</span>.<span class="property">MAGIC</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lastGuess</span> === -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lastGuess</span> = n;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable constant_">GUESS_RESULT</span>.<span class="property">FIRST_GUESS</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> lastDiff = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">MAGIC</span> - <span class="variable language_">this</span>.<span class="property">lastGuess</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastGuess</span> = n;</span><br><span class="line">        <span class="keyword">const</span> nowDiff = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">MAGIC</span> - n);</span><br><span class="line">        <span class="keyword">return</span> nowDiff &gt; lastDiff ? <span class="variable constant_">GUESS_RESULT</span>.<span class="property">COLD</span> : <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>, hi = game.<span class="property">N</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">// 无法比较大小，所以需要guess两次，最小边界和最大边界</span></span><br><span class="line">        <span class="keyword">let</span> guessRes = game.<span class="title function_">guess</span>(lo);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        guessRes = game.<span class="title function_">guess</span>(hi);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>) &#123;</span><br><span class="line">            lo = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>, hi = game.<span class="property">N</span>;</span><br><span class="line">    <span class="keyword">let</span> isRightSide = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 第一次猜测</span></span><br><span class="line">    <span class="keyword">let</span> guessRes = game.<span class="title function_">guess</span>(lo);</span><br><span class="line">    <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> nowGuess = (lo + hi) - game.<span class="property">lastGuess</span>;</span><br><span class="line">        guessRes = game.<span class="title function_">guess</span>(nowGuess);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRightSide) &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRightSide) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isRightSide = !isRightSide;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (game.<span class="title function_">guess</span>(lo) === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (game.<span class="title function_">guess</span>(hi) === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.log2(100000) ~= 17</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">task1</span>()); <span class="comment">// 35</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">task2</span>()); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/7a9ea6ece2af">蓄水池算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学归纳法 </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elastic Stack 入门</title>
      <link href="/2018/12/10/elk/"/>
      <url>/2018/12/10/elk/</url>
      
        <content type="html"><![CDATA[<h1 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h1><ul><li>Document：存储在ES中的一些数据，存储的最小单元。表中的一行数据。是JSON object，由field组成，有数据类型，每一个文档有唯一id，拥有meta data标注文档(<code>_source</code>,<code>_id</code>等)的相关信息。</li><li>Index:具有相同结构的文档的集合。对应表。拥有自己的mapping定义，定义字段名和类型。一个集群可以有多个索引，例如nginx日志可以按照每天生成一个索引来存储。</li><li>Node：一个es的运行实例，是构成集群的基本单元</li><li>Cluster：由一个或者多个节点组成，对外提供服务</li></ul><h1 id="反向索引和分词"><a href="#反向索引和分词" class="headerlink" title="反向索引和分词"></a>反向索引和分词</h1><ul><li>正排索引：文档id到文档内容、单词的关联关系</li><li>反向索引：单词到文档id的关联关系</li></ul><p>查询流程，通过关键字从反向索引中找到文档id，然后通过文档id使用正排索引返回所有符合条件的文档。</p><p>反向索引是搜索引擎的核心，主要包含2部分：</p><ul><li>单词词典（Term Dictionary）：记录文档所有单词和单词到倒排列表的关联信息，一般比较大。实现方式一般是B+树</li><li>倒排列表（Posting List）：包含文档id，单词词频（Term Frequency，用于后续相关性算分），位置（position，记录单词在文档中分词的位置，可以是多个，用于做词语搜索Phrase Query），偏移（Offset，记录单词在文档开始和结束的位置，用于做高亮显示）</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elasticsearch_term_dict_impl.png" alt="使用B+树实现单词字典"></p><p>B+树好处：插入和查询性能高，更高效利用磁盘和内存的映射机制。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/term_dict_posting_list.png" alt="单词词典和反向索引"></p><p>例如：search 搜索引擎的时候通过term dictionary快速在b+树中定位到搜索引擎，拿到在postion list中的偏移量，从而得到反向索引项的docid 1和3</p><p>es中分词称为文本分析analysis.自带分词器有standard&#x2F;simple,whitespace,stop,keyword,pattern,language.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;hello world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>自定义分词器，其实是自定义分词器的3个组成部分：Character Filters,Tokenizer和Token Filter实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> _analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>, </span><br><span class="line">  <span class="string">&quot;filter&quot;</span>: [<span class="string">&quot;lowercase&quot;</span>], </span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="中文分词的难点"><a href="#中文分词的难点" class="headerlink" title="中文分词的难点"></a>中文分词的难点</h2><ul><li>英文可以使用空格作为自然分界符，但是中文没有一个形式上的分界符。</li><li>上下文不同，分词结果迥异，例如交叉歧义问题，例如下面的两种分词结果其实都是合理的：</li><li>乒乓球拍&#x2F;卖&#x2F;完了</li><li>乒乓球&#x2F;拍卖&#x2F;完了</li></ul><p>常用的中文分词系统有IK和jieba。更高阶的则是基于NLP的分词系统，例如Hanlp，THULAC.  </p><h1 id="Mapping设置"><a href="#Mapping设置" class="headerlink" title="Mapping设置"></a>Mapping设置</h1><p>类似DB中表结构的定义，主要作用：</p><ul><li>定义index下的字段名（field name）</li><li>定义字段类型，例如Number，Text，Boolean</li><li>定义反向索引相关的配置，例如是否索引，记录position等</li></ul><p>自定义mapping和dynamic的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;title&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test_index/_mapping</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;test_index&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;dynamic&quot;</span>: <span class="string">&quot;false&quot;</span>,</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;age&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>:<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">  <span class="string">&quot;desc&quot;</span>:<span class="string">&quot;nothing exist.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询title可以返回结果</span></span><br><span class="line">GET test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 84,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;skipped&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 0.2876821,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;doc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 0.2876821,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;title&quot;</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">          <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;nothing exist.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询desc得不到结果</span></span><br><span class="line">GET test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;no&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_to，将该字段的值复制到目标字段，实现类似_all的作用，一般不会出现在_source中，只用来搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;first_name&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;last_name&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;copy_to&quot;</span>: <span class="string">&quot;full_name&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;first_name&quot;</span>:<span class="string">&quot;张&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last_name&quot;</span>:<span class="string">&quot;三丰&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;full_name&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;张三丰&quot;</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;took&quot;</span>: 117,</span><br><span class="line">  <span class="string">&quot;timed_out&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span>: 5,</span><br><span class="line">    <span class="string">&quot;skipped&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span>: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;hits&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;max_score&quot;</span>: 0.8630463,</span><br><span class="line">    <span class="string">&quot;hits&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;my_index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_type&quot;</span>: <span class="string">&quot;doc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_score&quot;</span>: 0.8630463,</span><br><span class="line">        <span class="string">&quot;_source&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;first_name&quot;</span>: <span class="string">&quot;张&quot;</span>,</span><br><span class="line">          <span class="string">&quot;last_name&quot;</span>: <span class="string">&quot;三丰&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index字段控制当前字段是否索引，默认为true，如果设置为false则不可搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cookie&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;cookie&quot;</span>:<span class="string">&quot;name=root&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;cookie&quot;</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 查询将会报错 Cannot search on field [cookie] since it is not indexed.</span></span><br></pre></td></tr></table></figure><p>索引设置为false的情形主要用于一些敏感信息，例如身份证号、手机号,index_options用于控制反向索引记录的内容。</p><p>dynamic templates：es默认会为字符串设置text类型，并增加一个keyword子字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;strings_as_keywords&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;match_mapping_type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapping&quot;</span>:&#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;test_index&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;strings_as_keywords&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段名匹配：以message开头的字段都设置为text类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">注意：2个dynamic_templates匹配顺序从上到下，只要匹配一个就结束了</span><br><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;message_as_text&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;match_mapping_type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;match&quot;</span>:<span class="string">&quot;message*&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapping&quot;</span>:&#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;strings_as_keywords&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;match_mapping_type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mapping&quot;</span>:&#123;</span><br><span class="line">              <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>:<span class="string">&quot;today is suny&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test_index/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;test_index&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;dynamic_templates&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;message_as_text&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;match&quot;</span>: <span class="string">&quot;message*&quot;</span>,</span><br><span class="line">              <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;strings_as_keywords&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;match_mapping_type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">              <span class="string">&quot;mapping&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;message&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义mapping的操作步骤如下：</p><ol><li>写入一条文档到es的临时索引中，获取es自动生成的mapping</li><li>修改步骤1得到的mapping，自定义相关设置</li><li>使用步骤2的mapping创建实际所需索引</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELETE test_index</span><br><span class="line">PUT test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;referrer&quot;</span>:<span class="string">&quot;-&quot;</span>,</span><br><span class="line">  <span class="string">&quot;response_code&quot;</span>:200,</span><br><span class="line">  <span class="string">&quot;remote_ip&quot;</span>:<span class="string">&quot;189,90,89,00&quot;</span>,</span><br><span class="line">  <span class="string">&quot;method&quot;</span>:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="string">&quot;username&quot;</span>:<span class="string">&quot;-&quot;</span>,</span><br><span class="line">  <span class="string">&quot;http_version&quot;</span>:<span class="string">&quot;1.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body_sent&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>:0</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;url&quot;</span>:<span class="string">&quot;/stat&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test_index/_mapping</span><br><span class="line">拷贝上面的结果然后根据自己的需要进行适当修改即可</span><br></pre></td></tr></table></figure><p>可以使用dynamic_templates将所有字段设置为keyword不分词，只将自己需要的字段按照合适的类型进行单独定义。灵活使用这个技术可以减少设置mapping的工作量。</p><p>index template，用于新建索引的时候自动应用预定的设置，简化创建索引的步骤。</p><h1 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h1><p>endpoint为<code>_search</code>，调用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET _search</span><br><span class="line">GET my_index/_search</span><br><span class="line">GET my_index,test_index/_search</span><br><span class="line">GET my_*/_search</span><br></pre></td></tr></table></figure><p>查询有两种形式URI(仅包含部分语法)和request body（基于完整的query dsl）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search?q=username:tom</span><br><span class="line"></span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:<span class="string">&quot;tom&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URI-Search"><a href="#URI-Search" class="headerlink" title="URI Search"></a>URI Search</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_seach?q=tom&amp;<span class="built_in">df</span>=username&amp;<span class="built_in">sort</span>=age:asc&amp;from=4&amp;size=10&amp;<span class="built_in">timeout</span>=1s</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;profile&quot;</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es提供了查询profile可以进行查询调优。</p><p>注意：term查询，phrase查询和泛查询</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search?q=username:tom black <span class="comment"># tom为查询username，而black会查询所有字段</span></span><br><span class="line">GET my_index/_search?q=username:<span class="string">&quot;tom black&quot;</span> <span class="comment"># 查询username完全匹配tom black</span></span><br><span class="line">GET my_index/_search?q=username:(tom black) <span class="comment"># group query，查询username=tom或者username=black</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># + 和 -分别表示must和must not</span></span><br><span class="line">GET my_index/_search?q=username:(tom NOT black) <span class="comment"># username 包含tom不包含black</span></span><br><span class="line">GET my_index/_search?q=username:(tom +black) <span class="comment"># username 一定有black，包含tom的文档，注意urisearch的时候加号要替换成%2B</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围查询</span></span><br><span class="line">GET my_index/_search?q=username:tom and age:&gt;20 <span class="comment"># username包含tom并且age&gt;20</span></span><br></pre></td></tr></table></figure><p>通配符查询执行效率低，并且吃内存，不建议使用，千万不要放在最前面可能导致OOM。</p><p>模糊匹配(fuzzy)：<code>roam~1</code>，foam、roams都会匹配<br>近似度查询(proximity):<code>&quot;fox quick&quot;~5</code>，以term为单位进行差异比较，<code>quick fox</code>,<code>quick brown fox</code>都会匹配<br>一般用于用户输入的纠错。</p><h2 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h2><h3 id="Match-Query"><a href="#Match-Query" class="headerlink" title="Match Query"></a>Match Query</h3><p>会进行分词处理。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/match_query.png" alt="match query的流程"></p><p>通过operator参数可以控制match中单词的匹配关系，可选值<code>and</code>,<code>or</code>（默认）<br>minimum_should_match参数可以控制需要匹配的单词数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;explain&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>:<span class="string">&quot;jack tom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>:<span class="string">&quot;and&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.x之后默认的相关性算分基于BM25,是针对TF-IDF模型的一个优化。BM(Best Match)，迭代25次。一个大的优化是降低了TF在过大的时候的权重，我们可以使用explain参数查看详细的算分过程。</p><p>match_phase则将query看做一个完整的词语，强调顺序，可以使用<code>slop</code>实现和proximity相似的效果。<br>query_string类似于search uri中q参数的查询。</p><h3 id="Term-Terms-Query"><a href="#Term-Terms-Query" class="headerlink" title="Term &amp; Terms Query"></a>Term &amp; Terms Query</h3><p>不对查询语句进行分词处理。</p><p>注意</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack tom&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上查询将不会返回结果，因为构建反向索引的时候会分词，反向索引中不存在”jack tom”这个词语。</p><h3 id="Range-Query"><a href="#Range-Query" class="headerlink" title="Range Query"></a>Range Query</h3><p>针对数值和日期，gt，gte，lt，lte。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span>:10,</span><br><span class="line">        <span class="string">&quot;lt&quot;</span>:20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对日期提供了一种更友好的方式Date Math，可以实现类似“最近一个小时”的查询</p><p>now - 1d</p><p><code>now</code>为基准日期，可以是具体的时间（使用双竖线隔离），例如2018-01-01<br><code>-1d</code>为计算公式 <code>+1h</code>表示加一个小时 <code>/d</code>表示将时间舍入到天</p><h3 id="Bool-Query"><a href="#Bool-Query" class="headerlink" title="Bool Query"></a>Bool Query</h3><p>Filter查询只过滤符合条件的文档，不计算相关性得分，es针对filter有智能缓存，因此执行效率很高。做简单匹配且不考虑分数的时候，推荐使用filter代替query。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET test_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>:&#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h1><p><a href="https://github.com/lmenezes/cerebro">cerebro</a>是一个便捷的针对es集群的web管理工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -Ecluster.name=my_cluster -Enode.name=node1 -Epath.data=my_cluster_node1 -Ehttp.port=5200 -d</span><br><span class="line">./bin/elasticsearch -Ecluster.name=my_cluster -Enode.name=node2 -Epath.data=my_cluster_node2 -Ehttp.port=5300 -d</span><br><span class="line">./bin/elasticsearch -Ecluster.name=my_cluster -Enode.name=node3 -Epath.data=my_cluster_node3 -Ehttp.port=5400 -d</span><br></pre></td></tr></table></figure><ul><li>可以修改cluster state的节点称为master节点，一个集群只能有一个，由集群中所有节点选举产生，可以被选举的节点称为master-eligible节点，相关配置<code>node.master:true</code>。</li><li>处理请求的节点称为coordinating节点，该节点为所有节点的默认您角色，不能取消。</li><li>路由请求到正确的节点处理，例如创建索引的请求到master节点。</li><li>存储数据的节点称为data节点，默认节点都是data类型，相关配置<code>node.data:true</code></li></ul><h2 id="副本和分片"><a href="#副本和分片" class="headerlink" title="副本和分片"></a>副本和分片</h2><p>引入分片（Shard）机制可以将数据均匀分布到所有节点上，从而充分利用集群的存储资源，是ES能够存储PB级别数据的基石。分片数在索引创建的时候指定，<em>后续不可修改</em>，默认为5。分片分为主分片和副本分片，实现数据高可用。副本分片由主分片负责同步，可以有多个，从而提高读取的吞吐量。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/es-shard.png" alt="ES分片和副本"></p><p>注意：如果磁盘空间不足的时候es不会分片,参考集群设置<code>cluster.routing.allocation.disk.threshold_enabled</code>。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/es-shard-replication.png" alt="分片"></p><p>上面图中实线是主分片，虚线是副本分片。分片数的设定非常重要，需要提前规划好。过小会导致后续无法通过增加节点实现水平扩容；过大会导致一个节点上分布过多分片，造成资源浪费，同时影响查询性能。</p><h2 id="Cluster-Health-故障转移"><a href="#Cluster-Health-故障转移" class="headerlink" title="Cluster Health &amp; 故障转移"></a>Cluster Health &amp; 故障转移</h2><p>green：所有主副分片都正常分配<br>yellow：所有主分片正常分配，但是又副本分片未正常分配<br>red：有主分片未分配</p><p>GET _cluster&#x2F;health</p><p>注意：即使集群处于RED状态，并不意味着集群不能提供服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到node1所在pid并kill</span></span><br><span class="line">ps aux | grep -i elasticsearc | grep node1</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elk-cluster_yellow.jpg" alt="node1挂掉之后集群变成了yellow"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elk-cluster_green.jpg" alt="经过一段时间集群重新生成副本变成了green"></p><h2 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/document_shard.png" alt="文档分片存储"></p><p>document 1是如何存储在分片P1上，这取决于文档到分片的映射算法，目的：文档均匀分布在所有分片上，充分利用资源。</p><p>随机选择或者round-robin算法是不可取的，因为文档存储进去之后还需要读取，需要维护文档到分片的映射关系，成本巨大。es采取的做法是根据文档实时算出其所在的分片。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = <span class="built_in">hash</span>(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure><p>hash算法可以保证数据分布，routing默认为文档id。该算法和主分片数相关，因此这也是<em>分片数一旦确定之后就不可更改</em>的原因。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/process_of_create_document.png" alt="文档创建流程"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elk-process_of_document_read.jpg" alt="文档读取流程"></p><h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elk-split_brain.jpg" alt="脑裂问题"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/elk-split_brain_solve.jpg" alt="加入选举法定人数quorum避免脑裂问题"></p><p><em>小技巧</em> :生产环境中设置master-eligible为3，quorum为2即可。</p><h1 id="ES运行机制"><a href="#ES运行机制" class="headerlink" title="ES运行机制"></a>ES运行机制</h1><h2 id="Query-Then-Fetch"><a href="#Query-Then-Fetch" class="headerlink" title="Query Then Fetch"></a>Query Then Fetch</h2><h2 id="相关性算分"><a href="#相关性算分" class="headerlink" title="相关性算分"></a>相关性算分</h2><p>相关性算分在shard和shard之间是独立的（一个shard是一个Lucene Index，是一个完整的相关性算分的单位。），也就意味着同一Term的IDF等值在不同shard上是不同的。文档的相关性算分和它所处的shard相关<br>当文档数量不够多的时候会导致相关性算分严重不准的情况发生。</p><p>解决思路有2个：</p><ul><li>分片数设置为1。可以从根本上解决问题，在文档数量不多的时候可以考虑（百万、千万）</li><li>DFS Query then Fetch。拿到所有文档后重新进行一次相关性算分，耗费更多CPU和内存，性能低，不建议使用。</li></ul><h2 id="分页和遍历"><a href="#分页和遍历" class="headerlink" title="分页和遍历"></a>分页和遍历</h2><p>from&#x2F;size是最常用的分页解决方案。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/deep-paging.png" alt="深度分页"></p><p>深度分页是所有的分布式搜索引擎和分布式系统都会遇到的问题,例如使用google搜索，调整url中的start</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对不起，Google 为所有查询的结果数都不会超过 1000 个。 (您所请求的结果在第 28000000 个之后。)</span><br></pre></td></tr></table></figure><p>scroll提供了遍历文档集的API，以快照的方式来避免深度分页的问题。</p><ul><li>不能用来做实时搜索，因为数据不是实时的</li><li>尽量不要使用复杂的sort条件，使用<code>_doc</code>最高效</li><li>使用稍微复杂</li><li>过多的scroll调用会占用大量内存，可以使用clear api删除过多快照</li></ul><p>search_after避免了深度分页的性能问题，提供了实时的下一页文档的获取功能。</p><ul><li>不能使用from参数，即：不能指定页数</li><li>只能下一页，不能上一页</li><li>使用简单</li></ul><p>应用场景</p><ul><li>from&#x2F;size:需要实时获取顶部分不分文档，且需要自由翻页</li><li>scroll：需要全部文档，例如导出所有数据</li><li>search_after:需要全部文档，不需要自由翻页</li></ul><h1 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/es-aggression.png" alt="ES聚合分析示例"></p><p>聚合分析分为以下4类：</p><ul><li>Bucket:类似SQL中的GROUP BY</li><li>Metric：计算最大值、最小值、平均值等</li><li>Pipeline：基于上一级的聚合分析结果再次进行分析</li><li>Matrix：矩阵分析类型</li></ul><p>所有的Kibana图表都是基于ES的Aggression实现的。</p><h2 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h2><p>按照一定的规则将分档分配到不同的桶中，达到分类分析的目的。</p><ul><li>terms：直接按照terms来分桶，如果是text类型，则按照分词后的结果进行分桶</li><li>ranges：通过指定数值范围来设定分桶规则</li><li>historgram:直方图。以固定间隔的策略来分割数据</li></ul><h2 id="Metric聚合"><a href="#Metric聚合" class="headerlink" title="Metric聚合"></a>Metric聚合</h2><ul><li>Cardinality意思是集合的势或者基数，是指不同集合的个数，类似SQL中的distinct count的概念。</li><li>使用stats可以一次性返回min,max,count,avg,sum。</li><li>extends_stats是对stats的拓展，包含了方差、标准差等。</li><li>percentile可以实现百分位数的统计。可以查看数据分布，例如：95%的请求在200ms内返回这样的需求。</li><li>top hits一般用于分桶后获取该桶内最匹配的顶部文档列表，即详情数据。</li></ul><h2 id="Bucket和Metric聚合分析"><a href="#Bucket和Metric聚合分析" class="headerlink" title="Bucket和Metric聚合分析"></a>Bucket和Metric聚合分析</h2><p>Bucket聚合分析允许通过添加子分析来进行进一步分析，该子分析可以是Bucket也可以是Metric。这也使得es的聚合分析能力变得异常强大。</p><h2 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h2><p>es默认作用范围是<em>query</em>的结果集，可以通过以下的方式改变其作用范围：</p><ul><li>filter</li><li>post_filter</li><li>global</li></ul><h2 id="排序以及精准度"><a href="#排序以及精准度" class="headerlink" title="排序以及精准度"></a>排序以及精准度</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/terms-miss-percision.png" alt="ES Terms排序可能是不准的"></p><p>不准确的原因在于数据分散在多个Shard上，Coordinating Node无法得悉数据全貌。解决方案：</p><ol><li>设置Shard数为1，可以消除数据分散的问题，但是无法承载大数据量</li><li>合理设置Shard_Size的大小，即每次从Shard上额外多获取数据，以提升准确度</li></ol><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/balance.png" alt="数据规模&amp;准确度&amp;实时性的均衡"></p><p>ES的聚合分析中Cardinality和Percentile分析使用的是近似统计算法。</p><h1 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h1><p>一个博客文章的索引可以设置如下：</p><p>&#x2F;&#x2F; bash<br>{<br>  “mappings”:{<br>    “doc”:{<br>      “source”:{<br>        “enabled”:false<br>      },<br>      “properties”:{<br>        “title”:{<br>          “type”:”text”,<br>          “fields”:{<br>            “keyword”:{<br>              “type”:”keyword”<br>            }<br>          },<br>          “store”:true<br>        },<br>        “publish_date”:{<br>          “type”:”date”,<br>          “store”:true<br>        },<br>        “author”:{<br>          “type”:”keyword”,<br>          “store”:true<br>        },<br>        “abstract”:{<br>          “type”:”text”,<br>          “store”:true<br>        },<br>        “url”:{<br>          “doc_values”:false,<br>          “norms”:false,<br>          “ignore_above”:100<br>          “store”:true<br>        }<br>      }<br>    }<br>  }<br>}</p><p>由于文章内容可能非常大，所以关掉_source避免取过大的原始文档，为每个字段加了<code>store</code>属性专门存储字段原始值</p><ul><li>文章标题是需要进行全文检索和分词的，所以设置为text，keyword子字段可以对博客的标题进行完全匹配</li><li>url只需要做展示并不需要搜索</li></ul><h2 id="关联关系处理"><a href="#关联关系处理" class="headerlink" title="关联关系处理"></a>关联关系处理</h2><p>ES不擅长处理RDBMS中的外键，可以通过Nested Object或者Parent&#x2F;Child（Join数据类型）变相解决。其中使用Nested Object适用于查询频繁的场景，而Parent&#x2F;Child父子文档独立更新，为了维护join关系需要占用部分内存并且读取性能差。</p><h2 id="Reindex"><a href="#Reindex" class="headerlink" title="Reindex"></a>Reindex</h2><p>重建所有数据的过程，一般发生在如下的情况：</p><ul><li>mapping设置变更，例如字段类型变化、分词器字典更新等</li><li>index设置变更，例如分片数目更改</li><li>迁移数据</li></ul><p>es提供了<code>_update_by_query</code>(在现有索引上重建)和<code>_reindex</code>（将source中的数据重建到dest中）。数据重建的时间受源索引文档规模的影响，当规模越大的时候所需要的时间越多，此时需要设定url参数<code>wait_for_completion</code>为false启动异步任务来执行，可以通过<code>_task</code>来查看任务的执行进度和相关数据</p><h1 id="集群调优"><a href="#集群调优" class="headerlink" title="集群调优"></a>集群调优</h1><h2 id="JVM设定"><a href="#JVM设定" class="headerlink" title="JVM设定"></a>JVM设定</h2><p>JVM内存的设定不要超过31GB，预留一般内存给OS，用来做文件缓存。具体大小根据node存储的数据量来估算，为了保证性能，在内存和数据量之间有一个建议的比例：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/es-jvm-memory.png" alt="JVM内存的设定"></p><h2 id="写性能优化"><a href="#写性能优化" class="headerlink" title="写性能优化"></a>写性能优化</h2><p>es写数据存在3个过程：</p><ol><li>refresh:segment写入磁盘的过程非常耗时，可以借助fs缓存的特性先将segment在缓存中创建并开放查询来进一步提升实时性。在refresh之前文档会先存储在一个buffer中，refresh时将buffer中的所有文档清空并猩猩segment。es默认每秒执行一次refresh，这也是es被称为Near Real Time的原因。</li><li>translog：用来避免segment还没有写入磁盘的时候发生了宕机。写入文档到buffer的同时将该操作写入translog。translog会即时写入磁盘(fsync)。es启动会检查translog并从中恢复数据。</li><li>flush：将内存中的segment落盘，主要做如下工作：将translog写入磁盘；将index buffer清空，其中的文档生成一个新的segment，相当于一个refresh操作；更新commit point并写入磁盘；执行fsync操作将内存中的segment落盘；删除旧的translog文件。</li></ol><p>写性能优化的目标是增大EPS(Events Per Second),优化方案：</p><ul><li>客户端：多线程写，批量写</li><li>ES：在高质量数据建模的前提下，主要是在refresh，translog和flush之间做文章</li></ul><p>调优参数:<code>refresh_interval</code>,<code>indices.memory.index_buffer_size</code>，<code>index.translog.durability</code>,<code>index.translog.sync_interval</code>,<code>index.translog.flush_threshold_size</code>。</p><h2 id="读性能优化"><a href="#读性能优化" class="headerlink" title="读性能优化"></a>读性能优化</h2><ul><li>尽量使用filter上下文，减少算分的场景，由于filter有缓存机制，可以极大提高查询性能</li><li>尽量不使用script进行字段计算或者算分排序</li><li>结合profile、explain api分析慢查询语句，然后优化数据模型</li></ul><h2 id="如何设定Shard数"><a href="#如何设定Shard数" class="headerlink" title="如何设定Shard数"></a>如何设定Shard数</h2><p>es的性能基本是线性拓展的，例如单个Shard的eps是1W，而线上eps要求是5W，则需要5个Shard（实际还需要考虑副本）。测试一个shard的流程如下：</p><ol><li>搭建和生产环境相同配置的单节点集群</li><li>设定一个单分片零副本的索引</li><li>写入实际生产数据进行测试，获得写性能指标</li><li>针对数据进行查询请求，获取读性能指标</li></ol><p>压测工具可以使用esrally，x-pack插件可以对es进行监控</p><h1 id="LogStash"><a href="#LogStash" class="headerlink" title="LogStash"></a>LogStash</h1><h2 id="入门-运行机制"><a href="#入门-运行机制" class="headerlink" title="入门 &amp; 运行机制"></a>入门 &amp; 运行机制</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/logstash-process.png" alt="LogStash流程"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/logstash-arch.png" alt="LogStash架构"></p><blockquote><p>可以使用<code>-r</code>命令行参数启动LogStash，可以热重载配置，便于调试。</p></blockquote><h2 id="线程分析"><a href="#线程分析" class="headerlink" title="线程分析"></a>线程分析</h2><p>LogStash使用不同的线程处理输入、过滤和输出：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/24b88683-bbdc-4493-8164-b9220f2f1a19.png" alt="LogStash线程"></p><p>可以先使用<code>jps -ml</code>命令获得logstash的pid，再使用<code>top -H -p pid</code>查看线程信息。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>LogStash的Queue分为2种:</p><ul><li>In Memory:无法处理宕机</li><li>Persistent Queue In Disk:保证不丢失数据；保证数据至少消费一次；充当缓冲区，可以替代Kafka</li></ul><p>相比内存中的队列，PQ的EPS下降不是特别严重（5%以内），相关配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.type:persisted</span><br><span class="line">queue.max_bytes:4gb</span><br></pre></td></tr></table></figure><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>每个Input Thread对应一个线程(Input-&gt;Codec)</li><li>每个pipeline worker Thread对应一个线程(Batcher-&gt;Filter-&gt;Output)</li></ul><p>相关配置有<code>pipeline.workers</code>,<code>pipeline.batch.size</code>,<code>pipeline.batch.delay</code>。</p><blockquote><p>线程查看工具可以使用visual vm。</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>file插件用于从文件读取数据。</p><ul><li>通过sincedb解决重启LS时从上次读取的位置开始读取</li><li>定时检查文件是否更新读取文件的新内容</li><li>定时检查新文件来发现新文件</li><li>如果文件发生了rotation操作，则被rotation的文件可以继续被读取（基于inode，和文件名没有关系）</li><li>基于Filewatch的ruby库实现</li></ul><p>调试小技巧：sincedb_path设置为&#x2F;dev&#x2F;null，start_position何止为beginning可以每次从头读取文件。</p><p>codec主要负责将数据在原始与Logstash Event之间转换。 multiline可以匹配多行，藏剑的用途是提取错误堆栈信息。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>对Logstash Event进行转换解析，常用：date,<a href="https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns">grok常用正则</a>,dissect基于分隔符解析数据，解决grok消耗过多CPU的问题。</p><p>dissect常用配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># / 后面的指定匹配的顺序</span></span><br><span class="line">原始日志：two three one go</span><br><span class="line">配置： %&#123;+order/2&#125; %&#123;+order/3&#125; %&#123;+order/1&#125; %&#123;+order/4&#125;</span><br><span class="line">结果：&#123;<span class="string">&quot;order&quot;</span>:<span class="string">&quot;one two three go&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态的键值对(例如query参数)</span></span><br><span class="line">原始日志：a=1&amp;b=2</span><br><span class="line">配置：%&#123;?key1&#125;=%&#123;&amp;key1&#125;&amp;%&#123;?key2&#125;=%&#123;&amp;key2&#125;</span><br><span class="line">结果：&#123;<span class="string">&quot;a&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;b&quot;</span>:<span class="string">&quot;2&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>mutate是使用最频繁的插件，可以对字段进行各种操作：重命名、删除、替换、更新等。常用操作:convert类型转换，gsub字符串替换，split&#x2F;join&#x2F;merge，字符串切割&#x2F;数组合并，rename字段重命名，update&#x2F;replace字段内容更新或者替换，remove_field删除字段。</p><h3 id="调试配置建议"><a href="#调试配置建议" class="headerlink" title="调试配置建议"></a>调试配置建议</h3><p>使用http做input方便输入测试数据，并且可以结合reload特性(stdin无法reload)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input &#123;http&#123;port =&gt; 7474&#125;&#125;</span><br><span class="line">filter &#123;&#125;</span><br><span class="line">output &#123;stdout&#123;codec =&gt; rubydebug&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>@metadata</code>特殊字段其内部不会输出到output中，适合用来存储做条件判断、临时存储的字段，相比<code>remove_field</code>有一定的性能提升。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input &#123;http&#123;port =&gt; 7474&#125;&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  <span class="comment"># 这里相当于一个调试开关</span></span><br><span class="line">  mutate &#123; add_field =&gt; &#123;<span class="string">&quot;[@metadata][debug]&quot;</span> =&gt; <span class="literal">true</span>&#125; &#125;</span><br><span class="line">  mutate &#123; add_field =&gt; &#123;<span class="string">&quot;show&quot;</span> =&gt; <span class="string">&quot;this data will in output&quot;</span>&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  <span class="keyword">if</span> [@metadata][debug] &#123;</span><br><span class="line">    stdout &#123;codec =&gt; rubydebug&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stdout &#123;codec =&gt; dots&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战apache日志"><a href="#实战apache日志" class="headerlink" title="实战apache日志"></a>实战apache日志</h2><p>debug.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">input &#123;http&#123;port =&gt; 7474&#125;&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line">    match =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;message&quot;</span> =&gt; <span class="string">&quot;%&#123;COMBINEDAPACHELOG&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;headers&quot;</span>,<span class="string">&quot;message&quot;</span>,<span class="string">&quot;timestamp&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  ruby &#123;</span><br><span class="line">    code =&gt; <span class="string">&quot;event.set(&#x27;@read_timestamp&#x27;,event.get(&#x27;@timestamp&#x27;))&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  geoip &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;clientip&quot;</span></span><br><span class="line">    fields =&gt; [<span class="string">&quot;location&quot;</span>,<span class="string">&quot;country_name&quot;</span>,<span class="string">&quot;city_name&quot;</span>,<span class="string">&quot;region_name&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  useragent &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">&quot;agent&quot;</span></span><br><span class="line">    target =&gt; <span class="string">&quot;useragent&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">date</span> &#123;</span><br><span class="line">    match =&gt; [<span class="string">&quot;timestamp&quot;</span>,<span class="string">&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;stdout&#123;codec =&gt; rubydebug&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -f debug.conf -r <span class="comment"># 使用-r参数可以热重载配置</span></span><br></pre></td></tr></table></figure><p>使用POSTMAN发送HTTP请求,注意将请求内容放在body中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">218.19.140.242 - - [10/Dec/2010:09:31:17 +0800] <span class="string">&quot;GET /query/trendxml/district/todayreturn/month/2009-12-14/2010-12-09/haizhu_tianhe.xml HTTP/1.1&quot;</span> 200 1933 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8 (.NET CLR 3.5.30729)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="实战CSV文件"><a href="#实战CSV文件" class="headerlink" title="实战CSV文件"></a>实战CSV文件</h2><p>csv.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/tmp/player_data.csv&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">    sincedb_path =&gt; <span class="string">&quot;/dev/null&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  csv &#123;</span><br><span class="line">    autodetect_column_names =&gt; <span class="literal">true</span></span><br><span class="line">    autogenerate_column_names =&gt; <span class="literal">false</span></span><br><span class="line">    convert =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;uid&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="string">&quot;play_count&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="string">&quot;hundred_win_rate&quot;</span> =&gt; <span class="string">&quot;float&quot;</span></span><br><span class="line">      <span class="string">&quot;landlord_count&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="string">&quot;farmer_count&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;<span class="string">&quot;role_count&quot;</span> =&gt; <span class="string">&quot;%&#123;landlord_count&#125;,%&#123;farmer_count&#125;&quot;</span>&#125;</span><br><span class="line">    remove_field =&gt; [<span class="string">&quot;landlord_count&quot;</span>,<span class="string">&quot;farmer_count&quot;</span>,<span class="string">&quot;message&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">date</span> &#123;</span><br><span class="line">    match =&gt; [<span class="string">&quot;last_play_time&quot;</span>,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      index =&gt; <span class="string">&quot;player_data&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stdout &#123;codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>player_data.csv:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid,play_count,max_rate,win_count,win_max,win_max_time,<span class="string">&quot;last_play_time&quot;</span>,<span class="string">&quot;hundred_results&quot;</span>,hundred_win_rate,max_keep_win_count,win_max_rate,win_total,lose_total,spring_count,bomb_count,win_point,tnmt_count,tnmt_win_count,tnmt_best_rank,landlord_count,farmer_count,play_time,diamond_play_count</span><br><span class="line">9682421,504,73728,247,460800,1534842968,<span class="string">&quot;2018-10-24 14:33:48&quot;</span>,<span class="string">&quot;1111111000001110010010111011111001011101001100001110100000010010110111011101111110000010000100101001&quot;</span>,0.52,3,24576,3855191,5083567,5,348,0,0,0,99999,219,285,29220,0</span><br><span class="line">9682423,15,6912,5,2832,1531899522,<span class="string">&quot;2018-07-18 15:53:12&quot;</span>,<span class="string">&quot;110001101000000&quot;</span>,0.33,2,3072,9971,18879,NULL,26,0,0,0,99999,0,0,0,0</span><br><span class="line">9682424,1447,6144,795,4822,1536214982,<span class="string">&quot;2018-12-14 11:11:14&quot;</span>,<span class="string">&quot;0001111010100001100011110000001110100101100001010111111010011010000101111100101100000010110011001101&quot;</span>,0.48,9,4608,10230,393207,NULL,15,0,32,20,1,3,11,132,0</span><br></pre></td></tr></table></figure><h1 id="Beats"><a href="#Beats" class="headerlink" title="Beats"></a>Beats</h1><h2 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h2><p>读取日志文件，但是不做数据处理，保证”At least once”至少被读取一次，数据不会丢（但某些情况下数据可能被重复消费）。可以处理多行数据、解析JSON、简单的过滤功能。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/filebeats-arch.png" alt="FileBeats架构"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -e输出到stderr，默认输出到syslog和logs/filebeat</span></span><br><span class="line"><span class="comment"># 由于6.x之后只能指定一个output，所以加上publish参数指定相关的debug日志</span></span><br><span class="line">filebeat -e -c filebeat.yml -d <span class="string">&quot;publish&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Elasticsearch-Ingest-Node"><a href="#Elasticsearch-Ingest-Node" class="headerlink" title="Elasticsearch Ingest Node"></a>Elasticsearch Ingest Node</h3><p>5.x新增的一个节点类型，可以在数据写入ES之前(bulk&#x2F;index操作)对数据进行处理，可以配置独立的ingest node,(<code>node.ingest:true</code>)专门进行数据处理。api endpoint为pipeline.类似于logstash的filter。</p><h3 id="Filebeats-Module"><a href="#Filebeats-Module" class="headerlink" title="Filebeats Module"></a>Filebeats Module</h3><p>filebeats提供了许多开箱即用的module用于数据采集-&gt;ES建模-&gt;数据处理-&gt;存储并分析数据的一整套解决方案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filebeat modules list</span><br><span class="line">filebeat modules <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><p>参见安装目录下的<code>modules</code>目录和<code>fields.yml</code>。按照这个规则可以制定属于我们自己的module。</p><h2 id="Metrics-Beats"><a href="#Metrics-Beats" class="headerlink" title="Metrics Beats"></a>Metrics Beats</h2><p>定期收集OS，软件或者服务的指标数据存储在ES中进行实时分析。</p><ul><li>Logs:记录离散的事件，具有随机性。例如程序的调试信息或者错误信息</li><li>Metrics:记录度量可以聚合的数据，具有计划性。例如服务的响应时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./metricbeat -e -d <span class="string">&quot;publish&quot;</span></span><br><span class="line">./metricbeat setup --dashboards <span class="comment"># 导入dashboard</span></span><br></pre></td></tr></table></figure><p>metricsbeats同filebeats也会向es中导入index template。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET _template/metricbeat*</span><br><span class="line">GET metricbeat-6.1.1-2019.01.05/_search</span><br></pre></td></tr></table></figure><p>也可以在kibana的discover中替代上面的命令行进行操作,dashboard面板用于展示指标的监控数据。</p><h2 id="Packet-Beats"><a href="#Packet-Beats" class="headerlink" title="Packet Beats"></a>Packet Beats</h2><p>抓取并解析网络包数据。packetbeats抓包配置有2种：</p><ul><li>pcap:基于libcap，跨平台</li><li>af_packet：仅支持Linux，基于内存映射的嗅探技术，性能更好</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./packetbeat setup --dashboards</span><br><span class="line"><span class="built_in">sudo</span> ./packetbeat -e -c packetbeat.yml -d <span class="string">&quot;publish&quot;</span></span><br><span class="line"></span><br><span class="line">GET _template/packetbeat*</span><br><span class="line">GET packetbeat-6.0.1-2019.01.10/_search</span><br></pre></td></tr></table></figure><p>heartbeats用于检测主机是否存活。此外还有<a href="https://www.elastic.co/guide/en/beats/libbeat/current/community-beats.html">社区提供的beats</a>可以满足需各种求。</p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>线上部署推荐专门部署一个Coordinating Only ES Node和Kibana在同一台机器上。</p><p><a href="https://www.elastic.co/guide/en/kibana/6.1/tutorial-load-dataset.html">测试数据导入</a></p><p>在Kibana的management界面中创建一个名为<code>logstash-*</code>的index pattern。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/kibana-visualize.png" alt="Kibana可视化"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/kibana-visualize2.png" alt="Buckets-SplitSeries使用Terms aggression"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/kibana-split-chart.png" alt="Buckets-SplitCharts使用不同的图表展示不同的数据"></p><p>注意Buckets中聚合的顺序不同将影响展示的结果。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/kibana-timelion.png" alt="时间序列图"></p><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="房屋搜索项目"><a href="#房屋搜索项目" class="headerlink" title="房屋搜索项目"></a>房屋搜索项目</h2><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/airbnb.csv">数据源airbnb.csv</a></p><h3 id="创建数据模型"><a href="#创建数据模型" class="headerlink" title="创建数据模型"></a>创建数据模型</h3><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/airbnb-settings.json">airbnb.settings.json</a></p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>logstash配置文件<code>ls.conf</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">input<span class="punctuation">&#123;</span></span><br><span class="line">    stdin<span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">filter<span class="punctuation">&#123;</span></span><br><span class="line">    csv<span class="punctuation">&#123;</span></span><br><span class="line">        columns =&gt; <span class="punctuation">[</span><span class="string">&quot;accommodates&quot;</span><span class="punctuation">,</span><span class="string">&quot;bathrooms&quot;</span><span class="punctuation">,</span><span class="string">&quot;bed_type&quot;</span><span class="punctuation">,</span><span class="string">&quot;bedrooms&quot;</span><span class="punctuation">,</span><span class="string">&quot;beds&quot;</span><span class="punctuation">,</span><span class="string">&quot;date_from&quot;</span><span class="punctuation">,</span><span class="string">&quot;date_o&quot;</span><span class="punctuation">,</span><span class="string">&quot;date_rom&quot;</span><span class="punctuation">,</span><span class="string">&quot;date_to&quot;</span><span class="punctuation">,</span><span class="string">&quot;has_availability&quot;</span><span class="punctuation">,</span><span class="string">&quot;host_image&quot;</span><span class="punctuation">,</span><span class="string">&quot;host_name&quot;</span><span class="punctuation">,</span><span class="string">&quot;image&quot;</span><span class="punctuation">,</span><span class="string">&quot;listing_url&quot;</span><span class="punctuation">,</span><span class="string">&quot;location&quot;</span><span class="punctuation">,</span><span class="string">&quot;name&quot;</span><span class="punctuation">,</span><span class="string">&quot;price&quot;</span><span class="punctuation">,</span><span class="string">&quot;property_type&quot;</span><span class="punctuation">,</span><span class="string">&quot;room_type&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    mutate<span class="punctuation">&#123;</span></span><br><span class="line">        remove_field=&gt;<span class="punctuation">[</span><span class="string">&quot;message&quot;</span><span class="punctuation">]</span></span><br><span class="line">        lowercase=&gt;<span class="punctuation">[</span><span class="string">&quot;has_availability&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">output<span class="punctuation">&#123;</span></span><br><span class="line">    elasticsearch<span class="punctuation">&#123;</span></span><br><span class="line">        index =&gt; <span class="string">&quot;testairbnb&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    stdout<span class="punctuation">&#123;</span></span><br><span class="line">        codec=&gt;rubydebug</span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>导入：</p><p>cat airbnb.csv | bin&#x2F;logstash -f ls.conf</p><h3 id="配置Kibana"><a href="#配置Kibana" class="headerlink" title="配置Kibana"></a>配置Kibana</h3><ol><li>Management-&gt;Index Patterns-&gt;Create Index Pattern创建一个<code>testairbnb</code>的index pattern，Time Filter field name选择<code>I don&#39;t want to use the Time Filter</code>。</li><li>修改host_image,image和listing_url的format为Url，并且将host_image,image的Type配置为<code>Image</code>，Url Template配置为<code>&#123;&#123;rawValue&#125;&#125;</code>,配置成<code>&#123;&#123;value&#125;&#125;</code>会被转义。</li><li>接下来就可以在Discover中发现testairbnb了，由于我们没有选择time_filter，所以右上角不会出现时间选择。步骤2中修改的URL和图片也会在这个面板被正确展示出来。</li></ol><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/test_airbana.png" alt="房屋搜索"></p><p><a href="https://github.com/appbaseio-apps/airbeds">一个更加友好的房屋搜索项目</a></p><p><a href="https://blog.csdn.net/yiifaa/article/details/74531976">注意ES跨域访问</a></p><h2 id="nginx日志分析"><a href="#nginx日志分析" class="headerlink" title="nginx日志分析"></a>nginx日志分析</h2><p>资料下载：</p><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/nginx_template.json">nginx_template.json</a><br><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/access-1w.log">access.1w.log</a><br><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/nginx_log.conf">nginx_log.conf</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash -f nginx_log.conf</span><br></pre></td></tr></table></figure><p>导入数据后可以使用<code>GET _cat/indices/nginx_logs_*</code>查看创建的索引，在kinana中配置<code>nginx_logs*</code>index pattern。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/Project-imooc-log-imooc_overview.png" alt="nginx日志分析结果"></p><h2 id="北京空气质量分析"><a href="#北京空气质量分析" class="headerlink" title="北京空气质量分析"></a>北京空气质量分析</h2><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/air_quality_mapping_pipeline.json">air_quality_index.json</a><br><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/filebeat-air_quality.yml">air_quality_filebeat.yml</a></p><p>空气质量的CSV数据可以到<a href="http://www.stateair.net/web/historical/1/1.html">美大使馆网站</a>下载</p><p>导入数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> air_quality/*.csv | ./filebeat -e -c filebeat-air_quality.yml -d <span class="string">&quot;publish&quot;</span></span><br></pre></td></tr></table></figure><p>使用Python脚本将小时数据聚合成天数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"> </span><br><span class="line">es = Elasticsearch([<span class="string">&#x27;127.0.0.1:9200&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">search_query = &#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;gte&quot;</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;days&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;date_histogram&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;field&quot;</span>: <span class="string">&quot;@timestamp&quot;</span>,</span><br><span class="line">                <span class="string">&quot;interval&quot;</span>: <span class="string">&quot;day&quot;</span>,</span><br><span class="line">                <span class="string">&quot;time_zone&quot;</span>: <span class="string">&quot;+08:00&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;pm25&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;stats&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">res = es.search(index=<span class="string">&#x27;air_quality&#x27;</span>, body=search_query)</span><br><span class="line"></span><br><span class="line">index_name = <span class="string">&#x27;air_quality_days&#x27;</span></span><br><span class="line">index_type = <span class="string">&#x27;doc&#x27;</span></span><br><span class="line">es.indices.delete(index=index_name, ignore=[<span class="number">400</span>, <span class="number">404</span>])</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> res[<span class="string">&#x27;aggregations&#x27;</span>][<span class="string">&#x27;days&#x27;</span>][<span class="string">&#x27;buckets&#x27;</span>]:</span><br><span class="line">    cur_date = datetime.strptime(info[<span class="string">&#x27;key_as_string&#x27;</span>], <span class="string">&#x27;%Y-%m-%dT%H:%M:%S.%f+08:00&#x27;</span>)</span><br><span class="line">    new_doc = &#123;</span><br><span class="line">        <span class="string">&quot;@timestamp&quot;</span>: info[<span class="string">&#x27;key_as_string&#x27;</span>],      </span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: cur_date.year,</span><br><span class="line">        <span class="string">&#x27;month&#x27;</span>: cur_date.month,</span><br><span class="line">        <span class="string">&#x27;day&#x27;</span>: cur_date.day,</span><br><span class="line">        <span class="string">&quot;value_max&quot;</span>: info[<span class="string">&#x27;pm25&#x27;</span>][<span class="string">&#x27;max&#x27;</span>],</span><br><span class="line">        <span class="string">&quot;value_avg&quot;</span>: info[<span class="string">&#x27;pm25&#x27;</span>][<span class="string">&#x27;avg&#x27;</span>],</span><br><span class="line">        <span class="string">&quot;value_min&quot;</span>: info[<span class="string">&#x27;pm25&#x27;</span>][<span class="string">&#x27;min&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    es.index(index=index_name, doc_type=index_type, <span class="built_in">id</span>=new_doc[<span class="string">&#x27;@timestamp&#x27;</span>], body=new_doc)</span><br><span class="line">    <span class="built_in">print</span>(new_doc)</span><br></pre></td></tr></table></figure><blockquote><p>对于在es中没有的字段，可以在kibana的index pattern中的script fields中添加</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/Project-2016-beijing-wumai.png" alt="2016年的北京雾霾"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/Project-beijing-air-condition-change.png" alt="北京空气质量趋势"></p><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><ul><li>正则调试网站 debuggex，regexr</li><li>grok调试：<a href="https://grokdebug.herokuapp.com/">https://grokdebug.herokuapp.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子谈网络安全</title>
      <link href="/2018/11/15/web-security/"/>
      <url>/2018/11/15/web-security/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的web攻击手段"><a href="#常见的web攻击手段" class="headerlink" title="常见的web攻击手段"></a>常见的web攻击手段</h1><h2 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h2><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>劫持DNS服务器，取得域名的解析记录控制权之后，修改域名的解析结果。在ISP中比较常见，当用户访问某个域名的时候会收到一个假的解析结果（广告站），广告站弹出广告之后再跳转到目标网站。</p><h3 id="DNS缓存投毒攻击"><a href="#DNS缓存投毒攻击" class="headerlink" title="DNS缓存投毒攻击"></a>DNS缓存投毒攻击</h3><p>cache poisoning，攻击者对运行在UDP 53上的DNS查询进行检测，一旦发现与关键字匹配的请求则立即伪装成目标域名的解析服务器（Name Server）返回虚假结果。</p><p>防止劫持可以优先选用公用的、可信的DNS解析服务器。为了避免DNS污染则可以借助其他工具加密查询工具，例如DNSCrypt。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>浏览器的XSS过滤器可能会误报。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&#x27;1&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上代码应该被正常渲染为正常的文本节点，而IE11会过滤。在搜索引擎中搜索<code>&lt;script&gt;alert(&#39;1&#39;);&lt;/script&gt;</code>也会被IE警告并过滤。而Chrome的XSS过滤器基于词法解析。</p><p>浏览器在tokenize的时候，标签中的左斜线(&#x2F;)被视为标签结束的符号，但是仅仅在后面跟着尖括号的时候会这样。如果出现在其他地方（值的范围除外）。那么它同样会被当做“空格”对待，从而被忽略。这也是一些XSS绕过代码可以使用形如<code>&lt;img/src=&quot;&quot;/&gt;</code>这样的原因。</p><p>分为持久型（存在数据库中的网站评论）和非持久型（url中构造script标签）。可以获取客户端cookie在远程主机复制用户会话。解决方案：对输出进行编码。<br>CSRF：跨站请求伪造，攻击者通过http请求将数据发送到服务器，盗取会话cookie，攻击者不仅可以获取用户信息还能修改该cookie关联的用户信息。解决方案：使用跨站请求令牌，以防卫来自终端的POST,PUT,DELETE请求。（例如为了防止恶意注册，在生成表单的时候服务器生成一个scrftoken插入到表单的隐藏域,表单提交的时候对scrftoken进行验证，只允许合法请求通过，并生成新的令牌返回给该页面）。</p><p>有些网站开放了重定向功能，例如访问主站之前会重定向到要求登录页面要求登录，这也是存在风险的：</p><p>正常重定向：<a href="http://mysite.com/login?redict=http://mysite.com">http://mysite.com/login?redict=http://mysite.com</a><br>异常重定向：<a href="http://mysite.com/login?redict=http://mysIte.com">http://mysite.com/login?redict=http://mysIte.com</a></p><p>如果我们将mysIte.com做的和mysite.com一模一样，然后在社交网络上散布，如果有人重定向到mysIte.com，他的用户名和密码将会被盗窃。解决方案是只重定向到白名单的网站。</p><p>CSFR和XSS正好相反。XSS在于客户端信任服务器数据，而CSRF在于服务端信任客户端数据。</p><h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>cookie和网页的同源判定不一样，不区分端口、协议、不严格按照path部分指定隔离。 攻击者可以在http协议中通过设置cookie来覆盖带有secure标记的cookie。</p><p>script标签中的html注释是无效的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    <span class="comment">&lt;!--</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">    alert(1);</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">    --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用js的constructor可以创建匿名函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;&quot;[&quot;charAt&quot;] 获取String.prototype.charAt</span></span><br><span class="line"><span class="comment">// 接着调用constructor可以得到一个匿名函数，给要执行的匿名函数前面加上括号，代码就会执行</span></span><br><span class="line"><span class="string">&quot;&quot;</span>[<span class="string">&quot;charAt&quot;</span>][<span class="string">&quot;constructor&quot;</span>](<span class="string">&quot;alert(1)&quot;</span>)() <span class="comment">// 将会执行alert(1)</span></span><br></pre></td></tr></table></figure><p>响应头x-frame-options设置为<code>SAMEORIGIN</code>只能被同源站点的iframe加载。</p><p>泛解析，利用通配符（*）来做次级域名，实现所有的次级域名均指向同一地址的解析方式。如果网站使用了泛解析，结合浏览器的同源策略可能带来一些灾难性的后果。<a href="http://www.filldisk.com/%EF%BC%8C%E6%89%93%E5%BC%80%E5%AE%83%E4%B8%8D%E7%AE%A1%EF%BC%8C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%90%8E%E7%A1%AC%E7%9B%98%E5%B0%B1%E4%BC%9A%E8%A2%AB%E6%92%91%E6%BB%A1%E3%80%82%E5%8E%9F%E7%90%86localStorage%E6%AF%8F%E4%B8%AA%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8B%A5%E6%9C%895M%E5%AD%98%E5%82%A8%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%AD%90%E5%9F%9F%E5%90%8D%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%BA%90%E3%80%82">http://www.filldisk.com/，打开它不管，一段时间后硬盘就会被撑满。原理localStorage每个子域名拥有5M存储，每个子域名都会被认为是一个独立的源。</a></p><p>针对html5元素的攻击：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autofocus</span> <span class="attr">onfocus</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span>alert&amp;#40+1&amp;#41<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">formaction</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>https的安全性取决于双方如何使用，如果网站同时支持http和https，则攻击者可以通过截获http报文来获得连接中的隐私信息。https机制使用非对称加密系统（公约加密，私钥解密）。发送方用对方公钥来加密消息，再用自己的私钥解开。但是如果一直采用这种方式的话传输效率会比较低。因此浏览器中通常使用混合加密算法：用非对称加密算法交换一个密钥，通过校验之后再用这个密钥进行对称加密并和服务器通信。算法安全性取决于密钥的长度。</p><p>HTTP流量升级：当用户访问http网站的时候发送302重定向，并指定<code>Strict-Transport-Security: max-age=31536000</code>头。SSLstrip工具可以流量降级。</p><p>wap浏览器不支持cookie，要传递状态只能通过隐藏的web表单或者URL参数。登陆信息放在url参数中是十分危险的，这只是受限于手机性能的折中方案。由于移动端屏幕过小，因此：隐藏地址栏、合并UI，下滑页面自动全屏等操作其实是有风险的。</p><p>堆喷射：循环申请内存，并最终覆盖某个特定地址，从而让攻击者执行恶意代码。</p><p>正则表达式攻击：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/(([a-zA-Z0-9]+)*)@([A-Za-z0-9]+)/</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><h1 id="一些看起来不那么安全的操作"><a href="#一些看起来不那么安全的操作" class="headerlink" title="一些看起来不那么安全的操作"></a>一些看起来不那么安全的操作</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bcrypt = <span class="built_in">require</span>(<span class="string">&quot;bcryptjs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户输入的密码和hash加密后的密码对比</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">password</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">passhash</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Promise&lt;boolean&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">comparePassword</span>(<span class="params">password, passhash</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> bcrypt.<span class="title function_">compare</span>(password, passhash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回hash加密后的密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">password</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPasshash</span>(<span class="params">password</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> salt = <span class="keyword">await</span> bcrypt.<span class="title function_">genSalt</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">await</span> bcrypt.<span class="title function_">hash</span>(password, salt);</span><br><span class="line">  <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  comparePassword,</span><br><span class="line">  getPasshash,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希其实是一个非常消耗 CPU 的操作，一般来说“为了安全”需要放在后端，但是在大厂（腾讯）的实践中却是<a href="https://juejin.cn/post/6932290083794583566">将其放在了前端</a>：</p><blockquote><p>一般这种情况都是将hash工作交给前端，最后数据传递只传递hash后的密码。有人可能认为，如果由前端进行hash，会导致salt泄漏之类的情况，但是实际上，salt泄漏并不会带来问题。salt只是为了防止相同数据的hash碰撞问题，只要你设定了独特的salt，不会和其他被脱库的数据集采用了一样的salt，就不会由有问题。还有人会考虑，如果泄漏salt有可能导致可以本地生成字典hash进行碰撞。其实这个情况也不用担心，节流阀等东西可以做好限制，而且如果别人铁了心要攻击了，估计会开大量代理来反复撞库，可能密码还没破，网站先挂了。总而言之，这种可以由客户端解决的任务，可以交给客户端来处理，既能降低服务端的负载，同时也不会丢失安全性。</p></blockquote><p>这有点颠覆认知了。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础之 storm</title>
      <link href="/2018/11/10/storm/"/>
      <url>/2018/11/10/storm/</url>
      
        <content type="html"><![CDATA[<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><p>storm 1.1.1</p><p>zookeeper，分布式协调服务，HA。</p><p>kafka和logstash的整合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.sh -daemon /home/hadoop/app/kafka_2.11-0.9.0.0/config/server.properties</span><br><span class="line">kafka-topics.sh --create --zookeeper hadoop001:2181 --replication-factor 1 --partitions 1 --topic logstash_topic</span><br></pre></td></tr></table></figure><p>logstash2.4.1<br>file_kafka.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/tmp/access.log&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">    codec =&gt; json</span><br><span class="line">    topic_id =&gt; <span class="string">&quot;logstash_topic&quot;</span></span><br><span class="line">    bootstrap_servers =&gt; <span class="string">&quot;hadoop001:9092&quot;</span></span><br><span class="line">    batch_size =&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.&#x2F;bin&#x2F;logstash -f file_kafka.conf</p><h1 id="架构和部署"><a href="#架构和部署" class="headerlink" title="架构和部署"></a>架构和部署</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/storm-arch.png" alt="storm架构"></p><p>主：nimbus，task的指派和分发、资源的分配<br>从：supervisor，执行任务的具体部分。启动和停止多个worker（配置指定）。一个topology可以运行在多个worker上，也可以通过配置来指定</p><p>主从是无状态的，元数据存放在zk中。</p><p>worker：运行具体组件逻辑（Spout &amp; Bolt）的进程</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>task:Spout和Bolt中的每一个线程<br>executor:Spout和Bolt可能共享一个线程</p><p>Nimbus从1.0.0是HA的了。</p><p><a href="http://storm.apache.org/releases/1.1.2/Setting-up-a-Storm-cluster.html">安装指南</a></p><p>编辑<code>conf/storm-env.sh</code>导出JAVA_HOME。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zk</span></span><br><span class="line"><span class="built_in">nohup</span> storm dev-zookeeper &amp; </span><br><span class="line"><span class="comment"># nimbus</span></span><br><span class="line"><span class="built_in">nohup</span> storm nimbus &amp;</span><br><span class="line"><span class="comment"># ui （默认8080端口）</span></span><br><span class="line"><span class="built_in">nohup</span> storm ui &amp;</span><br><span class="line"><span class="comment"># supervisor</span></span><br><span class="line"><span class="built_in">nohup</span> storm supervisor &amp;</span><br><span class="line"><span class="comment"># logviewer(通过uid查看日志)</span></span><br><span class="line"><span class="built_in">nohup</span> storm logviewer &amp;</span><br><span class="line"><span class="comment"># 杀掉进程使用kill -9</span></span><br></pre></td></tr></table></figure><p>通过访问storm web ui可以发现启动了2个nimbus，主要是为了HA。</p><p>提交任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar ~/lib/storm-1.0.jar io.github.ClusterSumStormTopology</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的topology</span></span><br><span class="line">storm list</span><br><span class="line"><span class="comment"># 杀掉topology</span></span><br><span class="line">storm <span class="built_in">kill</span> ClusterSumStormTopology</span><br></pre></td></tr></table></figure><h1 id="并行度"><a href="#并行度" class="headerlink" title="并行度"></a>并行度</h1><p><a href="http://storm.apache.org/releases/1.1.2/Understanding-the-parallelism-of-a-Storm-topology.html">并行度</a></p><ul><li>一个worker进程执行的是一个topo的子集</li><li>一个worker进程会自动1-n个Executor线程来执行一个topo的component</li><li>一个运行的topo就是由集群中的多台物理机上的多个worker进程组成</li></ul><p>executor是一个被worker进程启动的单独线程，每个executor只会运行1个topo的1个component<br>task是最终运行spout或者bolt的最小执行单元</p><p>默认：<br>一个supervisor节点启动4个worker进程,启动4个slots（supervisor.slots.ports）。<br>每个topo默认启动一个worker进程<br>每个worker进程会启动一个executor<br>每个executor启动一个task</p><p>提交作业之后执行<code>jps -l</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">7207 org.apache.storm.ui.core</span><br><span class="line">7288 org.apache.storm.daemon.logviewer</span><br><span class="line">7803 org.apache.storm.daemon.worker</span><br><span class="line">7164 org.apache.storm.daemon.nimbus</span><br><span class="line">7229 org.apache.storm.daemon.supervisor.Supervisor</span><br><span class="line">7789 org.apache.storm.LogWriter</span><br></pre></td></tr></table></figure><h1 id="分组策略"><a href="#分组策略" class="headerlink" title="分组策略"></a>分组策略</h1><p>A Stream grouping defines how that stream should be partitioned among the bolt’s tasks.</p><p><a href="http://storm.apache.org/releases/1.1.2/Concepts.html">Streaming Groupings</a></p><h1 id="DRPC"><a href="#DRPC" class="headerlink" title="DRPC"></a>DRPC</h1><p>常见的序列化方式avro,thrift</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://shiyanjun.cn/archives/1472.html">Storm内部原理分析</a><br><a href="https://my.oschina.net/u/2000675/blog/613142">Storm并行度</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础之SparkStreaming</title>
      <link href="/2018/10/30/spark-streaming/"/>
      <url>/2018/10/30/spark-streaming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我对你的敬仰犹如滔滔江水连绵不绝，又如黄河泛滥一发不可收拾。 – 周星驰</p></blockquote><h1 id="流处理概述"><a href="#流处理概述" class="headerlink" title="流处理概述"></a>流处理概述</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>参考<a href="https://consoles.github.io/2018/10/15/spark-learning/#Hadoop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">spark-sql中的环境配置</a>，目录结构同上，jdk和spark版本升级如下：</p><p>jdk:1.8<br>spark:2.2</p><h2 id="实时流处理框架和架构"><a href="#实时流处理框架和架构" class="headerlink" title="实时流处理框架和架构"></a>实时流处理框架和架构</h2><ul><li>Strom: 真实时，来一条处理一条</li><li>Spark Streaming: 基于自定义时间间隔(2s,3s)的批量处理。微批处理</li><li>Kafka:国内使用较少</li><li>Flink：离线批处理 + 实时</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/spark-streaming-arch.png" alt="实时流处理架构"></p><p>为什么要将Flume收集的日志放入Kafka而不是直接丢给实时处理系统？</p><p>一般情况下业务有高峰期和低峰期，高峰期如果大量日志直接命中实时流处理系统，流处理系统可能扛不住压力，所以一般情况下会加一层MQ用来缓冲。</p><h2 id="实时流处理的应用"><a href="#实时流处理的应用" class="headerlink" title="实时流处理的应用"></a>实时流处理的应用</h2><p>电信行业，如果用户流量快用完的时候发短信订购流量包<br>电商行业，双十一大屏；搜索A商品的时候可能会向你推荐B商品，因为A和B可能有关联关系</p><p>大数据分析可以提高转化率。</p><h1 id="分布式日志收集框架Flume"><a href="#分布式日志收集框架Flume" class="headerlink" title="分布式日志收集框架Flume"></a>分布式日志收集框架Flume</h1><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><blockquote><p>Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data. </p></blockquote><p>有多台服务器上运行着我们的应用程序，各个机器上有os日志，web server日志，application的日志。假设我们需要将这些日志要收集到hadoop集群上就需要定时执行scp。实时性和容错性得不到保证，文本文件的格式一般需要压缩传输。这些问题flume都帮我们解决了。只需要配置文件就OK了。类似框架还可以使用LogStash。</p><h2 id="架构和核心组件"><a href="#架构和核心组件" class="headerlink" title="架构和核心组件"></a>架构和核心组件</h2><p><img src="https://flume.apache.org/_images/DevGuide_image00.png" alt="架构和核心组件"></p><p>source：采集<br>channel：聚集，类似于数据的缓存池，临时存放的地方<br>sink：输出</p><p><img src="https://flume.apache.org/_images/UserGuide_image02.png" alt="常用架构"></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>下载解压，配置系统环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> FLUME_HOME=/home/hadoop/app/apache-flume-1.6.0-cdh5.7.6-bin</span><br><span class="line">PATH=<span class="variable">$FLUME_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>配置文件在conf目录下，<code>cp flume-env.sh.template flume-env.sh</code>，导出<code>$JAVA_HOME</code>.</p><h2 id="从指定端口收集数据到控制台"><a href="#从指定端口收集数据到控制台" class="headerlink" title="从指定端口收集数据到控制台"></a>从指定端口收集数据到控制台</h2><p><a href="https://flume.apache.org/FlumeUserGuide.html#a-simple-example">一个简单的例子</a></p><p>a1:agent的名称<br>r1:source的名称<br>k1:sink的名称<br>c1:channel的名称</p><p>example.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example.conf: A single-node Flume configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = hadoop001</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flume-ng agent --conf <span class="variable">$FLUME_HOME</span>/conf --conf-file <span class="variable">$FLUME_HOME</span>/conf/example.conf --name a1 -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><p>使用telnet连接到<code>hadoop001 44444</code>并发送数据，可以看到agent输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:94)] Event: &#123; headers:&#123;&#125; body: 68 65 6C 6C 6F 0D                               hello. &#125;</span><br></pre></td></tr></table></figure><p>Event是Flume数据传输的基本单环，Event &#x3D; 可选的header + byte array</p><h2 id="实时监控文件采集新增数据到控制台"><a href="#实时监控文件采集新增数据到控制台" class="headerlink" title="实时监控文件采集新增数据到控制台"></a>实时监控文件采集新增数据到控制台</h2><p>agent选型:exec source + memory channel + logger sink</p><p>example.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example.conf: A single-node Flume configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a1.sources.r1.type = <span class="built_in">exec</span></span><br><span class="line">a1.sources.r1.command = <span class="built_in">tail</span> -F /home/hadoop/data/data.log</span><br><span class="line">a1.sources.r1.shell = /bin/sh -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure><h2 id="将A服务器上的日志实时采集到B服务器"><a href="#将A服务器上的日志实时采集到B服务器" class="headerlink" title="将A服务器上的日志实时采集到B服务器"></a>将A服务器上的日志实时采集到B服务器</h2><p><img src="https://flume.apache.org/_images/UserGuide_image03.png" alt="一个agent的输出作为另一个agent的输入"></p><p>exec source + memory channel + avro sink<br>avro source + memory channel + logger sink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec-memory-avro.conf</span></span><br><span class="line">exec-memory-avro.sources = exec-source</span><br><span class="line">exec-memory-avro.sinks = avro-sink</span><br><span class="line">exec-memory-avro.channels = memory-channel</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sources.exec-source.type = <span class="built_in">exec</span></span><br><span class="line">exec-memory-avro.sources.exec-source.command = <span class="built_in">tail</span> -F /home/hadoop/data/data.log</span><br><span class="line">exec-memory-avro.sources.exec-source.shell = /bin/sh -c</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sinks.avro-sink.type = avro</span><br><span class="line">exec-memory-avro.sinks.avro-sink.hostname = hadoop001</span><br><span class="line">exec-memory-avro.sinks.avro-sink.port = 44444</span><br><span class="line"></span><br><span class="line">exec-memory-avro.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">exec-memory-avro.sources.exec-source.channels = memory-channel</span><br><span class="line">exec-memory-avro.sinks.avro-sink.channel = memory-channel</span><br><span class="line"></span><br><span class="line"><span class="comment"># avro-memory-logger.conf 这个要先启动</span></span><br><span class="line">avro-memory-logger.sources = avro-source</span><br><span class="line">avro-memory-logger.sinks = logger-sink</span><br><span class="line">avro-memory-logger.channels = memory-channel</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.type = avro</span><br><span class="line">avro-memory-logger.sources.avro-source.bind = hadoop001</span><br><span class="line">avro-memory-logger.sources.avro-source.port = 44444</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sinks.logger-sink.type = logger</span><br><span class="line"></span><br><span class="line">avro-memory-logger.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">avro-memory-logger.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-logger.sinks.logger-sink.channel = memory-channel</span><br></pre></td></tr></table></figure><h1 id="消息队列Kafka"><a href="#消息队列Kafka" class="headerlink" title="消息队列Kafka"></a>消息队列Kafka</h1><h2 id="架构及核心概念"><a href="#架构及核心概念" class="headerlink" title="架构及核心概念"></a>架构及核心概念</h2><p><img src="https://kafka.apache.org/20/images/kafka-apis.png" alt="Kafka架构"></p><p>每一条消息记录由key，value和timestamp组成。topic用于给消息记录打标签，消费者可以按照指定的标签进行消费。</p><h2 id="部署和使用"><a href="#部署和使用" class="headerlink" title="部署和使用"></a>部署和使用</h2><p>先安装zookeeper，配置<code>$ZK_HOME</code>。<code>cp zoo_sample.cfg zoo.cfg</code>，配置<code>dataDir=/home/hadoop/app/tmp/zk</code>。</p><p>使用<code>./zkServer.sh start</code>启动服务器之后就可以使用<code>./zkCli.sh</code>连接到服务器。zk-cli命令<code>ls /</code> ，<code>ls /zookeeper</code>。</p><p>kafka版本kafka_2.11-0.9.0.0，下载解压并配置KAFKA_HOME。</p><h3 id="单节点单broker"><a href="#单节点单broker" class="headerlink" title="单节点单broker"></a>单节点单broker</h3><p>config&#x2F;server.properties</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0</span><br><span class="line">listeners=PLAINTEXT://:9092</span><br><span class="line">log.dirs=/home/hadoop/app/tmp/kafka-logs</span><br><span class="line">zookeeper.connect=hadoop001:2181</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动kafka</span></span><br><span class="line">kafka-server-start.sh /home/hadoop/app/kafka_2.11-0.9.0.0/config/server.properties</span><br><span class="line"><span class="comment"># 创建topic</span></span><br><span class="line">kafka-topics.sh --create --zookeeper hadoop001:2181 --replication-factor 1 --partitions 1 --topic hello_topic</span><br><span class="line"><span class="comment"># 查看所有topic</span></span><br><span class="line">kafka-topics.sh --list --zookeeper hadoop001:2181</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产消息</span></span><br><span class="line">kafka-console-producer.sh --broker-list hadoop001:9092 --topic hello_topic</span><br><span class="line"><span class="comment"># 启动一个消费者消费消息(注意官方文档中的--bootstrap-server要换成--zookeeper)</span></span><br><span class="line">kafka-console-consumer.sh --zookeeper hadoop001:2181 --topic hello_topic --from-beginning</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看描述</span></span><br><span class="line">kafka-topics.sh --describe --zookeeper hadoop001:2181</span><br></pre></td></tr></table></figure><p>启动生产者和消费者之后就可以在生产者所在tty发送消息了，从而消费者可以收到消息。上面的cmd中消费者加了参数<code>--from-beginning</code>，消费者重启之后以前的消息会再次收到。</p><h3 id="单节点多broker"><a href="#单节点多broker" class="headerlink" title="单节点多broker"></a>单节点多broker</h3><p>在单台服务器上配置多台kafka。</p><p>将server.properties复制为server-1.properties，server-2.properties，server-3.properties并修改对应的broker.id,listeners,log.dirs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server-1.properties &amp;</span><br><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server-2.properties &amp;</span><br><span class="line">kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server-3.properties &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为此时启动了3个broker所以replication-factor为3</span></span><br><span class="line">kafka-topics.sh --create --zookeeper hadoop001:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</span><br><span class="line">kafka-console-producer.sh --broker-list hadoop001:9093,hadoop001:9094,hadoop001:9095 --topic my-replicated-topic</span><br><span class="line">kafka-console-consumer.sh --zookeeper hadoop001:2181 --topic my-replicated-topic</span><br></pre></td></tr></table></figure><h3 id="容错性测试"><a href="#容错性测试" class="headerlink" title="容错性测试"></a>容错性测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop001 my-replicated-topic-0]$ kafka-topics.sh --describe --zookeeper hadoop001:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic      PartitionCount:1       ReplicationFactor:3    Configs:</span><br><span class="line">Topic: my-replicated-topic     Partition: 0   Leader: 1      Replicas: 1,2,3Isr: 1,2,3</span><br></pre></td></tr></table></figure><p>上面的描述信息显示1号broker是主，现在使用<code>kill -9</code>干掉2号（pid可以使用jps -m查看）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop001 my-replicated-topic-0]$ kafka-topics.sh --describe --zookeeper hadoop001:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic      PartitionCount:1       ReplicationFactor:3    Configs:</span><br><span class="line">Topic: my-replicated-topic     Partition: 0   Leader: 1      Replicas: 1,2,3Isr: 1,3</span><br></pre></td></tr></table></figure><p>Isr中2不见了。接下来干掉1号broker。可以发现消费者终端中出现了warning，但是发的消息还是可以收到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop001 my-replicated-topic-0]$ kafka-topics.sh --describe --zookeeper hadoop001:2181 --topic my-replicated-topic</span><br><span class="line">Topic:my-replicated-topic      PartitionCount:1       ReplicationFactor:3    Configs:</span><br><span class="line">Topic: my-replicated-topic     Partition: 0   Leader: 3      Replicas: 1,2,3Isr: 3</span><br></pre></td></tr></table></figure><p>Leader由1变成了3，因此只要有一个broker正常就可以了。</p><h3 id="Kafka高级特性"><a href="#Kafka高级特性" class="headerlink" title="Kafka高级特性"></a>Kafka高级特性</h3><h4 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h4><p>为什么要支持事务？满足：“读取-处理-写入”模式。</p><p>数据传输的事务定义：</p><p>最多一次：消息不会被重复发送，最多被传输一次（可能一次也不传输）<br>最少一次：消息不会被漏发送，最少被传输一次(可能被重复传输),目前多数消息系统采用<br>精确的一次：Exactly Once,不会被漏传输也不会重复传输，每个消息都被传输一次而且仅仅被传输一次，这是大家所期望的。</p><p>Kafka保证事务的机制：</p><ul><li>内部重试：Producer幂等处理</li><li>多分区原子写入</li><li>避免僵尸实例</li></ul><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>java nio中的<code>channel.transforTo()</code>方法，底层系统调用是<code>sendfile</code>。将磁盘上的一个文件块发送到网络上需要经过这样的几步：</p><ol><li>OS将数据从磁盘读入到内核空间的页缓存</li><li>应用程序将数据从内核空间读入到用户空间的缓存中</li><li>应用程序将数据写回到内核空间的socket缓存中</li><li>OS将数据从socket缓冲区复制到网卡缓冲区，以便将数据发送出去</li></ol><p>以上数据经过了4次拷贝，如果采用零拷贝机制则只有以下几步：</p><ol><li>OS将数据从磁盘读入到内核空间的页缓存</li><li>将数据的位置和长度信息的描述符增加内核空间(socket缓冲区)</li><li>OS将数据从内核拷贝到网卡缓冲区，以便将数据经过网络发出</li></ol><p>数据只经过了2次拷贝！零拷贝指的是：内核空间和用户空间之间的拷贝次数是0。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/kafka-zero-copy.png" alt="Kafka零拷贝"></p><h3 id="整合Flume完成数据采集"><a href="#整合Flume完成数据采集" class="headerlink" title="整合Flume完成数据采集"></a>整合Flume完成数据采集</h3><p><img src="http://archive.cloudera.com/cdh5/cdh/5/flume-ng-1.6.0-cdh5.7.0/FlumeUserGuide.html" alt="Flume cdh版本的soure-sink配置"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># avro-memory-kafka.conf</span></span><br><span class="line">avro-memory-kafka.sources = avro-source</span><br><span class="line">avro-memory-kafka.sinks = kafka-sink</span><br><span class="line">avro-memory-kafka.channels = memory-channel</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sources.avro-source.type = avro</span><br><span class="line">avro-memory-kafka.sources.avro-source.bind = hadoop001</span><br><span class="line">avro-memory-kafka.sources.avro-source.port = 44444</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.brokerList = hadoop001:9092</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.topic = hello_topic</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.batchSize = 5</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.requiredAcks = 1</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.channels.memory-channel.type = memory</span><br><span class="line"></span><br><span class="line">avro-memory-kafka.sources.avro-source.channels = memory-channel</span><br><span class="line">avro-memory-kafka.sinks.kafka-sink.channel = memory-channel</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flume-ng agent --conf <span class="variable">$FLUME_HOME</span>/conf --conf-file <span class="variable">$FLUME_HOME</span>/conf/avro-memory-kafka.conf --name avro-memory-kafka -Dflume.root.logger=INFO,console</span><br><span class="line">flume-ng agent --conf <span class="variable">$FLUME_HOME</span>/conf --conf-file <span class="variable">$FLUME_HOME</span>/conf/exec-memory-avro.conf --name exec-memory-avro -Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure><h1 id="Spark-Streaming环境搭建"><a href="#Spark-Streaming环境搭建" class="headerlink" title="Spark-Streaming环境搭建"></a>Spark-Streaming环境搭建</h1><p>下载scala2.11.8配置<code>$SCALA_HOME</code>环境变量。</p><h2 id="Hbase的配置"><a href="#Hbase的配置" class="headerlink" title="Hbase的配置"></a>Hbase的配置</h2><p>配置<code>$HBASE_HOME</code>系统变量。</p><p>修改conf&#x2F;hbase-env.sh中的<code>JAVA_HOME</code>并设置<code>HBASE_MANAGES_ZK=false</code>。<br>修改conf&#x2F;hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改conf&#x2F;regionservers为<code>hadoop001</code>。</p><p>启动<code>bin/start-hbase.sh</code>，WebUI地址<code>http://hadoop001:60010</code>。</p><p>启动hbase客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./bin/hbase shell</span><br><span class="line">version</span><br><span class="line">status</span><br><span class="line">create <span class="string">&#x27;member&#x27;</span>,<span class="string">&#x27;info&#x27;</span>,<span class="string">&#x27;address&#x27;</span></span><br><span class="line">list</span><br><span class="line">describe <span class="string">&#x27;member&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Spark-Streaming核心概念和编程"><a href="#Spark-Streaming核心概念和编程" class="headerlink" title="Spark-Streaming核心概念和编程"></a>Spark-Streaming核心概念和编程</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>one stack to rule them all.一栈式解决。</p><p><a href="https://github.com/apache/spark/blob/master/examples/src/main/scala/org/apache/spark/examples/streaming/NetworkWordCount.scala">官网的例子</a></p><p>使用spark-submit提交（生产）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lk 9999</span><br><span class="line">spark-submit --master <span class="built_in">local</span>[2] --class org.apache.spark.examples.streaming.NetworkWordCount --name NetworkWordCount /home/hadoop/app/spark-2.2.0-bin-2.6.0-cdh5.7.0/examples/jars/spark-examples_2.11-2.2.0.jar hadoop001 9999</span><br><span class="line"><span class="comment"># nc中输入的一行数据会实时在spark-shell中进行wordcount展示</span></span><br></pre></td></tr></table></figure><p>使用spark-shell提交（开发）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell --master <span class="built_in">local</span>[2]</span><br></pre></td></tr></table></figure><p>将下面的代码粘贴到spark-shell中即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">&quot;hadoop001&quot;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"><span class="keyword">val</span> wordCounts = words.map(x =&gt; (x, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">wordCounts.print()</span><br><span class="line">ssc.start()</span><br><span class="line">ssc.awaitTermination()</span><br></pre></td></tr></table></figure><p>Spark Streaming接收到实时数据流，把数据按照指定时间段切成一片片的小数据块，把小数据块交给SparkEngine处理。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/spark-streaming-process.png" alt="SparkStreaming工作原理"></p><p>Spark应用程序运行在Driver端，Driver端会要求Executor启动一些接收器，Receiver启动之后会将InputStream拆分成小的Block存放在内存中（如果设置了多副本的话还会拷贝到其他机器），之后Receiver会将block信息高速StreamingContext，每隔指定的时间周期StreamingContext会通知SparkContext应该启动一些jobs了，接下来SparkContext将jobs分发到Executor执行。</p><p>DStreams:</p><p>Discretized Streams (DStreams)： a DStream is represented by a continuous series of RDDs,  a DStream is represented by a continuous series of RDDs, which is Spark’s abstraction of an immutable, distributed dataset.</p><p>InputStreams &amp; Receivers:</p><p>Every input DStream (except file stream, discussed later in this section) is associated with a Receiver (Scala doc, Java doc) object which receives the data from a source and stores it in Spark’s memory for processing.</p><h2 id="处理Socket数据"><a href="#处理Socket数据" class="headerlink" title="处理Socket数据"></a>处理Socket数据</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * SparkStreaming处理Socket数据</span></span><br><span class="line"><span class="comment">  * 测试:nc -lk 6789 并输入数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NetworkWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: com.fasterxml.jackson.module.scala.deser.BigDecimalDeserializer$.handledType()Ljava/lang/Class;</span></span><br><span class="line">  <span class="comment">// 在pom中添加com.fasterxml.jackson依赖(jar包冲突)</span></span><br><span class="line">  <span class="comment">// java.lang.NoClassDefFoundError: net/jpountz/util/SafeUtils</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 设置为local或者local[1]无法执行,因为只有一个线程获取不到资源(从socket接收数据需要启动一个Receiver)</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;NetworkWordCount&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">6789</span>)</span><br><span class="line">    <span class="keyword">val</span> result = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">    result.print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理文件数据"><a href="#处理文件数据" class="headerlink" title="处理文件数据"></a>处理文件数据</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FileWordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="comment">// 不需要Receiver,因此local没有问题</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;FileWordCount&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sparkConf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">// tmp/ss目录中的文件一旦被生成,向文件中追加内容将不会被处理</span></span><br><span class="line">    <span class="keyword">val</span> lines = ssc.textFileStream(<span class="string">&quot;file:///tmp/ss&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = lines.flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">    result.print()</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>window:定时进行一个时间段内的数据处理。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 流处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏编程算法与技巧</title>
      <link href="/2018/10/21/game-programming/"/>
      <url>/2018/10/21/game-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏编程概述"><a href="#游戏编程概述" class="headerlink" title="游戏编程概述"></a>游戏编程概述</h1><p>游戏编程中的3个核心概念：游戏循环、游戏时间管理和游戏对象模型。</p><h2 id="游戏循环"><a href="#游戏循环" class="headerlink" title="游戏循环"></a>游戏循环</h2><p>整个程序的核心流程控制称为游戏循环。之所以是一个循环是因为游戏总在不断执行一系列动作直到玩家退出。每迭代一次游戏循环称为1帧。大部分游戏每秒钟更新30~60帧。60FPS即游戏循环每秒钟执行60次。一个传统的游戏循环分成3部分：处理输入、更新游戏世界、生成输出。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> game is <span class="built_in">running</span></span><br><span class="line">  process inpus</span><br><span class="line">  update game world</span><br><span class="line">  generate outputs</span><br><span class="line">loop  </span><br></pre></td></tr></table></figure><h2 id="游戏时间管理"><a href="#游戏时间管理" class="headerlink" title="游戏时间管理"></a>游戏时间管理</h2><p>游戏时间管理使得我们的游戏速度可以在任何机器上得到保证。通过处理时间增量来表示游戏逻辑。如果在8MHz下游戏的FPS为30，则在16MHz下FPS为60。也就是说在30FPS的时候敌人每秒钟移动150px，则在60FPS的时候敌人每秒移动300px。为了解决这个问题，通常需要引入时间增量：从上一帧起流逝的时间。更新逻辑可以写成这样：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emeny.position.x += <span class="number">150</span> * deltaTime</span><br></pre></td></tr></table></figure><p>在30FPS下每帧移动5px，而60FPS下每帧移动2.5px。结果是每秒还是移动150px，但是60FPS的显然更加平滑。但是这也会导致奇怪的角色行为：低帧率下跳的更高。这个问题的简单解决方案是限制帧率。例如一个目标帧率为30的游戏，如果游戏循环本身只用了30ms，则需要再等待3.3ms才能进入下一次游戏循环。如果游戏遇上复杂情形导致某帧比目标帧率时长长，最常见的就是为了跟上目标帧率放弃这一帧的渲染，这就是有名的<em>卡帧</em>。</p><h2 id="游戏对象模型"><a href="#游戏对象模型" class="headerlink" title="游戏对象模型"></a>游戏对象模型</h2><p>游戏对象是每一帧需要更新或者绘制的对象：</p><p>既绘制又更新的对象：玩家、角色、敌人<br>只更新的对象：摄像机和看不见的触发器<br>只绘制的对象：静态网格，例如背景中的树木</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class GameWorld</span><br><span class="line">  List updateableObjects</span><br><span class="line">  List drawableObjects</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> game is <span class="built_in">running</span></span><br><span class="line">  realDeltaTime = <span class="built_in">time</span> since last frame</span><br><span class="line">  gameDeltaTime = realDeltaTime * gameTimeFactor</span><br><span class="line"></span><br><span class="line">  process inpus</span><br><span class="line"></span><br><span class="line">  <span class="built_in">foreach</span> o <span class="keyword">in</span> GameWorld.updateableObjects</span><br><span class="line">    o.Update(gameDeltaTime)</span><br><span class="line">  loop</span><br><span class="line">  <span class="built_in">foreach</span> o <span class="keyword">in</span> GameWorld.drawableObjects</span><br><span class="line">    o.Draw()</span><br><span class="line">  loop </span><br><span class="line">  </span><br><span class="line">  // 帧数限制</span><br><span class="line">  ...</span><br><span class="line">loop  </span><br></pre></td></tr></table></figure><p>Q：一个简单的多线程游戏循环是如何提升帧率的？<br>A：如果渲染使用了30ms，游戏世界的更新使用了20ms，传统游戏循环会花费每帧50ms。但是如果将渲染放入一条自己单独的线程就可以和游戏更新并行完成。每帧总花费会降低到30ms。</p><p>Q:什么是输入延迟？多线程游戏循环是如何导致延迟的？<br>A：输入延迟是按下按钮到看见屏幕上按钮产生效果的时间。在多线程游戏循环中输入延迟会增加。因为渲染总是比游戏更新慢一帧，因此多了一帧的延迟。</p><h1 id="2D图形"><a href="#2D图形" class="headerlink" title="2D图形"></a>2D图形</h1><h2 id="像素缓冲区和垂直同步"><a href="#像素缓冲区和垂直同步" class="headerlink" title="像素缓冲区和垂直同步"></a>像素缓冲区和垂直同步</h2><p>将新的一帧向像素缓冲区中写像素的时候，CRT还在上一帧的绘制当中，这就导致了<em>屏幕撕裂</em>，具体表现就是屏幕上同时显示了不同的两帧的各自一半的画面。更糟糕的是，新一帧的数据提交时，上一帧还没开始，这就会导致没有画面。可以采用双缓冲来解决：有两块像素缓冲区，游戏交替地绘制在这两块缓冲区里。为了完全消除屏幕撕裂，缓冲区交换必须在场消隐期进行，这就是垂直同步。游戏游戏确实允许缓冲区交换在绘制完成前尽快进行，这就会导致屏幕撕裂的可能，这种情况通常是玩家想要会的比屏幕刷新速度快的帧率。如果一款显示器有60Hz的刷新频率，则同步缓冲区交换到场消隐期最多只有60Hz,但是玩家为了减少输入延迟，可能选择消除同步以达到更高的帧率。</p><h2 id="动画精灵"><a href="#动画精灵" class="headerlink" title="动画精灵"></a>动画精灵</h2><p>2D动画的原理是快速切换静态图片。为了保证动画的流畅性，帧率至少是24FPS（电影帧率）</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础之SparkSQL</title>
      <link href="/2018/10/15/spark-sql/"/>
      <url>/2018/10/15/spark-sql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在对应用进行集群化的时候，对于应用如何规划所使用的cpu核心数量有一个不成文的规定：总核心数量-1。因为操作系统需要消耗一些cpu，如果我们的应用占用了全部的cpu，一旦os需要处理一些其他任务，就会因为没有空闲的核而强制进行上下文切换，会减慢应用的处理速度。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/map-reduce.png" alt="MapReduce模型"></p><p>map操作中将每个单词设置为1<br>shuffle过程中将key相同的分到同一个reduce上</p><h1 id="HDFS架构"><a href="#HDFS架构" class="headerlink" title="HDFS架构"></a>HDFS架构</h1><h2 id="NameNode和DataNode"><a href="#NameNode和DataNode" class="headerlink" title="NameNode和DataNode"></a>NameNode和DataNode</h2><p><a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#NameNode_and_DataNodes">NameNode和DataNode</a></p><p>blocksize:128M<br>130M会被拆分成2个block:128M+2M</p><p>NameNode:</p><ul><li>客户端请求</li><li>元数据管理（文件名称、副本系数、block存放的DataNode）</li></ul><p>DataNode：</p><ul><li>存储用户文件对应的数据块</li><li>定期向NameNode发送心跳信息，汇报自身及其所有的block信息，健康状况</li></ul><blockquote><p>SecondNameNode在2.x中已经不是必须的了。</p></blockquote><h2 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h2><p>hdfs-site.xml中的<code>dfs.replication</code></p><ul><li>replication factor:副本因子会被存放在NameNode中</li><li>一个文件的所有block大小都一样，除了最后一个</li></ul><h1 id="Hadoop环境搭建"><a href="#Hadoop环境搭建" class="headerlink" title="Hadoop环境搭建"></a>Hadoop环境搭建</h1><p>用户名hadoop,密码hadoop，&#x2F;home&#x2F;hadoop目录结构：</p><p>software:存放软件安装包<br>lib：开发的jar包<br>app:所有软件的安装目录，子目录tmp<br>data:测试数据目录<br>source:框架源码目录</p><p><a href="http://archive.cloudera.com/cdh5/cdh/5/">http://archive.cloudera.com/cdh5/cdh/5/</a><br><a href="https://www.cloudera.com/documentation/enterprise/release-notes/topics/cdh_vd_cdh_package_tarball_57.html">https://www.cloudera.com/documentation/enterprise/release-notes/topics/cdh_vd_cdh_package_tarball_57.html</a> 2.6.0-cdh5.7.0<br>jdk7u51-linux-x64<br>scala2.11.8</p><p>修改主机名和hosts文件(&#x2F;etc&#x2F;sysconfig&#x2F;network和etc&#x2F;hosts)</p><p>主机名：hadoop001 - 192.168.100</p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network<br>NETWORKING&#x3D;yes<br>HOSTNAME&#x3D;hadoop001</p><p>配置ssh免密登陆(本步骤可以省略，但是重启hadoop进程的时候需要手动输入密码)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="built_in">cp</span> ~/.ssh/id_rsa.pub ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 可以测试是否可以免密登陆本机</span></span><br><span class="line">ssh hadoop001</span><br></pre></td></tr></table></figure><p>由于大数据开发会打开许多FD,修改最大打开文件数量和进程数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下内容添加到 /etc/security/limits.conf 文件后面</span></span><br><span class="line">* hard nofile 10000</span><br><span class="line">* soft nofile 10000 </span><br><span class="line">* hard <span class="built_in">nproc</span> 10000</span><br><span class="line">* soft <span class="built_in">nproc</span> 10000</span><br></pre></td></tr></table></figure><h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><p>配置文件路径&#x2F;home&#x2F;hadoop&#x2F;app&#x2F;hadoop-2.6.0-cdh5.7.0&#x2F;etc&#x2F;hadoop</p><p>hadoop-env.sh修改JAVA_HOME<br>core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="格式化HDFS和启停"><a href="#格式化HDFS和启停" class="headerlink" title="格式化HDFS和启停"></a>格式化HDFS和启停</h3><p>bin客户端脚本目录,sbin服务端脚本目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>使用<code>jps -m</code>命令验证是否启成功：</p><p>2042 SecondaryNameNode<br>1890 DataNode<br>1571 NameNode</p><p>关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chkconfig iptables off <span class="comment"># 禁止开机自启动</span></span><br><span class="line">chkconfig --list</span><br><span class="line">/etc/init.d/iptables stop</span><br></pre></td></tr></table></figure><p>可以访问<a href="http://hadoop001:50070/">http://hadoop001:50070</a>。端口信息参见hdfs-default.xml的<code>dfs.namenode.http-address</code>，NameNode的WebUI。可以查看集群上的datanode信息，浏览hdfs上的文件，浏览日志信息。</p><h3 id="HDFS-Shell常用操作"><a href="#HDFS-Shell常用操作" class="headerlink" title="HDFS Shell常用操作"></a>HDFS Shell常用操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -<span class="built_in">ls</span> /</span><br><span class="line">hadoop fs -<span class="built_in">mkdir</span> /test</span><br><span class="line">hadoop fs -<span class="built_in">mkdir</span> -p /a/b</span><br><span class="line">hadoop fs -<span class="built_in">ls</span> -R /</span><br><span class="line">hadoop fs -put hdfs.cmd /test </span><br><span class="line">hadoop fs -text /test/hdfs.cmd</span><br><span class="line">hadoop fs -get /test/hdfs.cmd a_tmp</span><br><span class="line">hadoop fs -<span class="built_in">rm</span> /test/hdfs.cmd</span><br><span class="line">hadoop fs -<span class="built_in">rm</span> -r /a</span><br></pre></td></tr></table></figure><h2 id="集群模式安装"><a href="#集群模式安装" class="headerlink" title="集群模式安装"></a>集群模式安装</h2><h3 id="在一台机器上进行安装"><a href="#在一台机器上进行安装" class="headerlink" title="在一台机器上进行安装"></a>在一台机器上进行安装</h3><p>以下操作都在hadoop001上进行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在hadoop001上执行下面的代码会远程登录hadoop001，002，002，输入密码之后即可免密登陆</span></span><br><span class="line"><span class="comment"># ssh-copy-id -i ~/.ssh/id_rsa.pub &quot;-p 10022 user@server&quot; 解决默认端口问题</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop001</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop002</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop003</span><br></pre></td></tr></table></figure><p>分布式和伪分布式仅仅多了个yarn的resourcemanager的hostname，还有slave配置文件<br>hadoop001 yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>slaves</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure><h3 id="将001上的安装包分发到其他节点"><a href="#将001上的安装包分发到其他节点" class="headerlink" title="将001上的安装包分发到其他节点"></a>将001上的安装包分发到其他节点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r ~/app hadoop@hadoop002:~/</span><br><span class="line">scp -r ~/app hadoop@hadoop003:~/</span><br><span class="line">scp ~/.bash_profile hadoop@hadoop002:~/</span><br><span class="line">scp ~/.bash_profile hadoop@hadoop003:~/</span><br></pre></td></tr></table></figure><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>核心概念：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mapreduce-combiner.png" alt="使用Combiner加速WordCount"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mapreduce-partitioner.png" alt="使用Partitioner指定reducer的输出"></p><ul><li>Split：交由MR作业处理的数据块，是MR中最小的计算单元；HDFS中的blocksize是HDFS中最小的存储单元，默认128M。默认情况下Split和hdfs中的block一一对应。</li><li>InputFormat：将输入数据进行分片（Split）：<code>InputSplit[] getSplit(JobConf job,int numSplits)</code>。<code>TextInputFormat</code></li><li>OutputFormat：输出。</li><li>Combiner:可以看成Map节点本地的Reducer，可以预先对数据进行一部分归并，对于求和这样的操作可以有效减少网络传输。</li><li>Partitioner:有几个partition对应几个reducer作业的输出。</li><li>jobhistory:记录已经完成的MR信息到指定的HDFS目录下，默认是不开启的。</li></ul><p>开启job history后可以通过yarn webui 查看</p><p>mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop001:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/history/done<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.intermediate-done-dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/history/done_intermediate<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动history server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure><blockquote><p>HDFS不适合小文件的存储，如果小文件非常多则集群性能会非常低，namenode维护太多元数据。所以一般情况下集群上的小文件都会定期清理合并成大文件。MapReduce只适合离线批处理。</p></blockquote><h1 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h1><p>hadoop 1.x中JobTracker存在单点且职能过多：</p><ol><li>资源管理</li><li>任务调度</li></ol><p>TaskTracker和JobTacker之间通过心跳维护。资源利用率低，运维成本高。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/yarn-arch.png" alt="Yarn架构"></p><p><code>1 * ResourceMananager + n * NodeManager</code></p><p>通常活跃的ResourceManager只有一个（可以做主备，只有主挂掉之后standby才会激活），负责整个集群资源的管理和调度。</p><ol><li>处理客户端请求（启动&#x2F;杀死）</li><li>启动&#x2F;监控ApplicationMaster(一个作业对应一个AM)</li><li>监控NodeManager</li><li>系统的资源分配和调度</li></ol><p>NodeManager整个集群中有N个，负责单个节点的资源管理和使用以及task的运行情况。</p><ol><li>定期向RM汇报本节点的资源使用请求和各个Container的运行状态</li><li>接收并处理RM的container启停的各种命令</li><li>单个节点的资源管理和任务管理</li></ol><p>ApplicationMaster每个应用&#x2F;作业对应一个，负责应用程序的管理</p><ol><li>数据切分</li><li>为应用程序向RM申请资源（container），并分配内部任务</li><li>与NM通信以启停task，task运行在container中</li><li>task的监控和容错</li></ol><p>Container对任务运行情况进行描述：cpu、memory</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/yarn-process-step.png" alt="作业在yarn上的执行流程"></p><ol><li>向yarn提交作业</li><li>RM为该作业分配第一个container（AM）</li><li>RM会与对应的NM通信，要求NM在这个container上启动应用的AM</li><li>AM首先会向RM注册，然后AM将为各个任务申请资源并监控运行情况</li><li>AM采用轮训的方式通过RPC协议向RM申请和领取资源</li><li>AM申请到资源后便和对应的NM通信要求NM启动任务</li><li>NM启动我们作业对应的task</li></ol><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>etc&#x2F;hadoop&#x2F;mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>etc&#x2F;hadoop&#x2F;yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>验证是否启动成功</p><p>jps</p><p>1610 NodeManager<br>1919 Jps<br>1532 ResourceManager</p><p><a href="http://hadoop001:8088/">Yarn WebUI地址</a>可以看到资源的使用情况。端口配置参见yarn-default.xml中的<code>yarn.resourcemanager.webapp.address</code></p><p>提交mr作业到yarn上运行：wordcount</p><blockquote><p>hadoop 默认提供了wordcount，位于&#x2F;home&#x2F;hadoop&#x2F;app&#x2F;hadoop-2.6.0-cdh5.7.0&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-2.6.0-cdh5.7.0.jar</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -<span class="built_in">mkdir</span> -p /input/wc</span><br><span class="line">hadoop fs -put data/hello.txt /input/wc</span><br><span class="line">hadoop fs -<span class="built_in">ls</span> -R /</span><br><span class="line">hadoop fs -text /input/wc/hello.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后面的两个参数指定输入文件和输出目录</span></span><br><span class="line">hadoop jar app/hadoop-2.6.0-cdh5.7.0/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.0-cdh5.7.0.jar wordcount /input/wc/hello.txt /output/wc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -<span class="built_in">ls</span> -R /output/wc</span><br><span class="line"><span class="comment"># 查看作业运行结果</span></span><br><span class="line">hadoop fs -text /output/wc/hello.txt/part-r-00000 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar hadoop-mapreduce-examples-2.6.0-cdh5.7.0.jar pi 2 5</span><br></pre></td></tr></table></figure><h1 id="大数据仓库HIVE"><a href="#大数据仓库HIVE" class="headerlink" title="大数据仓库HIVE"></a>大数据仓库HIVE</h1><blockquote><p>fb开发的构建与hadoop之上用于解决海量结构化的日志数据统计问题。定义了HQL（类SQL）</p></blockquote><p>几乎所有的大数据场景都可以使用MapReduce来完成，HIVE的出现时将HQL转化为MapReduce作业。极大降低大数据技术在数据分析领域的门槛。</p><p>产生背景：</p><ol><li>mapreduce编程的不便性</li><li>HDFS上的文件非结构化，不便于查询</li></ol><p>通常用于离线数据处理，HIVE底层的执行引擎：MapReduce，Tez，Spark。hive on mapreduce的意思是hive的执行引擎是mapreduce。</p><p>压缩：gzip,lzo,snappy,bzip2<br>存储：TextFile,SequenceFile,RCFile,ORC,Parquet<br>UDF：自定义函数</p><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>只需部署一个节点即可。</p><p>配置HIVE_HOME环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.7.0</span><br><span class="line">PATH=<span class="variable">$HIVE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>注意：需要事先安装mysql。<code>yum install -y mysql-server mysql &amp;&amp; service mysqld restart</code>。<code>mysqladmin -u root password 123456</code>。5.1.73默认安装后root密码为空。配置mysql开机自启动在<code>/etc/rc.d/rc.local</code>中添加<code>service mysqld restart</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/hadoop/app/hive-1.1.0-cdh5.7.0/conf</span><br><span class="line"><span class="built_in">cp</span> hive-env.sh.template hive-env.sh</span><br><span class="line"><span class="built_in">touch</span> hive-site.xml</span><br></pre></td></tr></table></figure><p>编辑hive-env.sh，设置HADOOP_HOME</p><p>hive-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type=<span class="string">&quot;text/xsl&quot;</span> href=<span class="string">&quot;configuration.xsl&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/sparksql?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意需要将mysql驱动放到<code>$HIVE_HOME/lib</code>。</p></blockquote><p>启动hive(确保mysql和hdfs已经启动了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hive</span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">create table</span> hive_wordcount(context string);</span><br><span class="line"><span class="comment">-- 加载数据</span></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/hello.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> hive_wordcount;</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> hive_wordcount;</span><br><span class="line"><span class="comment">-- lateral view explode 将每行记录按照指定分隔符进行拆解</span></span><br><span class="line"><span class="keyword">select</span> word,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> hive_wordcount <span class="keyword">lateral</span> <span class="keyword">view</span> explode(split(context,<span class="string">&#x27;\t&#x27;</span>)) wc <span class="keyword">as</span> word <span class="keyword">group</span> <span class="keyword">by</span> word;</span><br></pre></td></tr></table></figure><p>hql提交执行之后会生成MR作业并在Yarn上运行，可以在Yarn的管理界面上看到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> emp(empno <span class="type">int</span>,ename string,job string,mgr <span class="type">int</span>,hiredate string,sal <span class="keyword">double</span>,comm <span class="keyword">double</span>,deptno <span class="type">int</span>)<span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">create table</span> dept(deptno <span class="type">int</span>,dname string,location string) <span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/emp.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> emp;</span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hadoop/data/dept.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> dept;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求每个部门的人数</span></span><br><span class="line"><span class="keyword">select</span> deptno,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure><h1 id="Spark及其生态圈"><a href="#Spark及其生态圈" class="headerlink" title="Spark及其生态圈"></a>Spark及其生态圈</h1><p>为什么快？提供了DAG的执行引擎，支持数据流处理和内存计算。MapReduce中的Map和Reduce是基于进程的（需要维护进程的启动和销毁），而Spark中的job是基于线程池的。</p><p>MapReduce效率低下的原因：map的结果会落地到磁盘（不能充分发挥内存威力），经过shuffle然后reduce；每个job(map或者reduce)的粒度都是进程级别（JVM的启动和销毁代价很高）。</p><h2 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载源码包spark-2.1.0.tgz解压后放到<code>/home/hadoop/source</code>目录。文档地址<a href="http://spark.apache.org/docs/2.1.0/building-spark.html">http://spark.apache.org/docs/2.1.0/building-spark.html</a></p><p>查看源码包中的pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.version</span>&gt;</span>3.3.9<span class="tag">&lt;/<span class="name">maven.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sbt.project.name</span>&gt;</span>spark<span class="tag">&lt;/<span class="name">sbt.project.name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.16<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hadoop.version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">hadoop.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">protobuf.version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">protobuf.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">yarn.version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">yarn.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>hadoop-2.6<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hadoop.version</span>&gt;</span>2.6.4<span class="tag">&lt;/<span class="name">hadoop.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jets3t.version</span>&gt;</span>0.9.3<span class="tag">&lt;/<span class="name">jets3t.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zookeeper.version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">zookeeper.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">curator.version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">curator.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过命令行的-D参数覆盖pom.xml中的hadoop.version</span></span><br><span class="line"><span class="comment"># -P参数指定使用pom.xml中的那个profile的id</span></span><br><span class="line">mvn -Pyarn -Phadoop-2.6 -Phive -Phive-thriftserver -Dhadoop.version=2.6.0-cdh5.7.0 -DskipTests clean package </span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译一个可以部署的包(推荐使用)</span></span><br><span class="line">./dev/make-distribution.sh --name 2.6.0-cdh5.7.0 --tgz -Pyarn -Phadoop-2.6 -Phive -Phive-thriftserver -Dhadoop.version=2.6.0-cdh5.7.0 -X</span><br></pre></td></tr></table></figure><p>参考：</p><p>pom.xml添加cdh版的maven仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/be8a2cf0f32e">spark源码编译的那些坑</a></p><p>编译完成后会在当前spark源码目录下生成spark-2.1.0-bin-2.6.0-cdh5.7.0.tgz,接下来解压到安装目录即可</p><h3 id="Local-模式"><a href="#Local-模式" class="headerlink" title="Local 模式"></a>Local 模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把SPARK_HOME添加到环境变量</span></span><br><span class="line">spark-shell --master <span class="built_in">local</span>[2] </span><br></pre></td></tr></table></figure><p>Spark context Web UI available at <a href="http://192.168.1.100:4040。">http://192.168.1.100:4040。</a></p><p><a href="http://spark.apache.org/docs/2.1.0/programming-guide.html#using-the-shell">SparkShell</a><br><a href="http://spark.apache.org/docs/2.1.0/submitting-applications.html#master-urls">local[2]的含义</a></p><h3 id="standalone模式"><a href="#standalone模式" class="headerlink" title="standalone模式"></a>standalone模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><p>spark的standalone模式架构和hadoop的hdfs&#x2F;yarn很类似，都是<code>1*master + n*woker</code>.spark-env.sh配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPARK_MASTER_HOST=hadoop001</span><br><span class="line">SPARK_WORKER_CORES=2</span><br><span class="line">SPARK_DAEMON_MEMORY=1g</span><br><span class="line">SPARK_WORKER_INSTANCES=2 <span class="comment"># worker的数量</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>worker启动报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost: failed to launch: nice -n 0 /home/hadoop/app/spark-2.1.0-bin-2.6.0-cdh5.7.0/bin/spark-class org.apache.spark.deploy.worker.Worker --webui-port 8081 spark://hadoop001:7077</span><br><span class="line">localhost:   JAVA_HOME is not set</span><br></pre></td></tr></table></figure><p>解决方案：sbin&#x2F;spark-config.sh末尾添加：<code>export JAVA_HOME=/home/hadoop/app/jdk1.7.0_51</code></p><p>通过spark-shell连接到SparkMaster</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark-shell --master spark://hadoop001:7077</span><br><span class="line">spark-shell --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><blockquote><p><code>spark-shell --jars /home/hadoop/software/mysql-connector-java-5.1.23-bin.jar --master local[2]</code>将配置好mysql数据源的hive-site.xml拷贝到spark的conf目录下，使用这个可以使用spark连接到hive。</p></blockquote><p>连接完成之后查看<a href="http://192.168.1.200:8080/%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0Running">http://192.168.1.200:8080/可以发现Running</a> Applications中有了一个应用，用了4个cores，状态是RUNNING,如果此时再次启动一个spark-shell，由于申请不到core，所以不会运行，状态是WAITING。</p><h3 id="wordcount"><a href="#wordcount" class="headerlink" title="wordcount"></a>wordcount</h3><p>使用spark-shell连接到spark master在repl中执行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file = spark.sparkContext.textFile(<span class="string">&quot;file:///home/hadoop/data/wc.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> wordCounts = file.flatMap(line =&gt; line.split(<span class="string">&quot;,&quot;</span>)).map((word =&gt; (word, <span class="number">1</span>))).reduceByKey(_ + _)</span><br><span class="line">wordCounts.collect</span><br></pre></td></tr></table></figure><blockquote><p>开发中建议采用local模式，方便快捷，无需搭建集群。</p></blockquote><h1 id="Spark-SQL概述"><a href="#Spark-SQL概述" class="headerlink" title="Spark SQL概述"></a>Spark SQL概述</h1><p>SQL on Hadoop的解决方案：</p><ul><li>Hive: 将sql转化为mapreduce作业,metastore，Facebook</li><li>impala: cloudera,cdh(建议生产环境使用的hadoop版本)，自己的守护进程执行，非mr，metastore</li><li>presto: 基于sql，facebook，京东</li><li>drill:sql，访问：hdfs,rdbms,json,hbase,mongodb,s3,hive</li><li>spark sql:dataframe&#x2F;dataset api,metastore，支持外部数据源：hdfs,rdbms,json,hbase,mongodb,s3,hive</li></ul><p><a href="http://spark.apache.org/docs/2.1.0/submitting-applications.html">向spark提交应用程序</a></p><p>spark-sql的应用并不仅限于sql，还能访问hive，json，parquet文件。提供了sql，DataFrame，Dataset api，比spark-code中RDD更高级的api。</p><blockquote><p>idea拷贝全类名，右键Copy Reference</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spark</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SQLContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * SQLContext的使用</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 编译打包 mvn clean package -DskipTests</span></span><br><span class="line"><span class="comment">  * 上传jar包到服务器 scp target/sql-1.0.jar hadoop@hadoop001:~/lib</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SQLContextApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> path = args(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    1.创建SparkContext</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在测试或者生产环境中,AppName和Master是我们通过脚本进行指定的</span></span><br><span class="line"><span class="comment">//    sparkConf.setAppName(&quot;SQLContextApp&quot;).setMaster(&quot;local[2]&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    2.相关处理(json文件)</span></span><br><span class="line">    <span class="comment">//    json文件来源spark-2.1.0/examples/src/main/resources/people.json</span></span><br><span class="line">    <span class="keyword">val</span> people = sqlContext.read.format(<span class="string">&quot;json&quot;</span>).load(path)</span><br><span class="line">    people.printSchema()</span><br><span class="line">    people.show()</span><br><span class="line">    <span class="comment">//    3.关闭资源</span></span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spark-submit \</span><br><span class="line">--class com.spark.SQLContextApp \</span><br><span class="line">--master <span class="built_in">local</span>[2] \</span><br><span class="line">/home/hadoop/lib/sql-1.0.jar \</span><br><span class="line">file:///home/hadoop/source/spark-2.1.0/examples/src/main/resources/people.json</span><br></pre></td></tr></table></figure><h2 id="SparkSQL-Shell的使用"><a href="#SparkSQL-Shell的使用" class="headerlink" title="SparkSQL Shell的使用"></a>SparkSQL Shell的使用</h2><p><a href="https://blog.csdn.net/BigData_Mining/article/details/80895554?utm_source=blogxgwz0">SparkSQL连接Hive报错找不到表并且使用内置数据库Derby</a></p><p>spark-sql连接hive需要将hive-site.xml复制到spark&#x2F;conf目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动完成后spark.sql(&quot;select * from emp e join dept d on e.deptno = d.deptno&quot;).show</span></span><br><span class="line">spark-shell --jars /home/hadoop/software/mysql-connector-java-5.1.23-bin.jar --master <span class="built_in">local</span>[2]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开spark-sql shell连接到hive之后可以直接执行sql，和上面的等效</span></span><br><span class="line">spark-sql --jars /home/hadoop/software/mysql-connector-java-5.1.23-bin.jar --master <span class="built_in">local</span>[2]</span><br></pre></td></tr></table></figure><h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">spark-sql&gt; table t(key string,value string);</span><br><span class="line">spark-sql&gt; explain extended <span class="keyword">select</span> a.key * (2+3),b.value from t a <span class="built_in">join</span> t b on a.key = b.key and a.key &gt; 3;</span><br><span class="line">== Parsed Logical Plan ==</span><br><span class="line"><span class="string">&#x27;Project [unresolvedalias((&#x27;</span>a.key * (2 + 3)), None), <span class="string">&#x27;b.value]</span></span><br><span class="line"><span class="string">+- &#x27;</span>Join Inner, ((&#x27;a.key = &#x27;b.key) &amp;&amp; (&#x27;a.key &gt; <span class="number">3</span>))</span><br><span class="line">   :- <span class="string">&#x27;UnresolvedRelation `t`, a</span></span><br><span class="line"><span class="string">   +- &#x27;</span>UnresolvedRelation `t`, b</span><br><span class="line"></span><br><span class="line">== Analyzed Logical Plan ==</span><br><span class="line">(CAST(key AS DOUBLE) * CAST((<span class="number">2</span> + <span class="number">3</span>) AS DOUBLE)): double, value: string</span><br><span class="line">Project [(cast(key#55 as double) * cast((<span class="number">2</span> + <span class="number">3</span>) as double)) AS (CAST(key AS DOUBLE) * CAST((<span class="number">2</span> + <span class="number">3</span>) AS DOUBLE))#59, value#58]</span><br><span class="line">+- Join Inner, ((key#<span class="number">55</span> = key#<span class="number">57</span>) &amp;&amp; (cast(key#<span class="number">55</span> as double) &gt; cast(<span class="number">3</span> as double)))</span><br><span class="line">   :- SubqueryAlias a</span><br><span class="line">   :  +- MetastoreRelation default, t</span><br><span class="line">   +- SubqueryAlias b</span><br><span class="line">      +- MetastoreRelation default, t</span><br><span class="line"></span><br><span class="line">== Optimized Logical Plan ==</span><br><span class="line">Project [(cast(key#55 as double) * 5.0) AS (CAST(key AS DOUBLE) * CAST((<span class="number">2</span> + <span class="number">3</span>) AS DOUBLE))#59, value#58]</span><br><span class="line">+- Join Inner, (key#55 = key#57)</span><br><span class="line">   :- Project [key#55]</span><br><span class="line">   :  +- Filter (isnotnull(key#55) &amp;&amp; (cast(key#55 as double) &gt; 3.0))</span><br><span class="line">   :     +- MetastoreRelation default, t</span><br><span class="line">   +- Filter (isnotnull(key#57) &amp;&amp; (cast(key#57 as double) &gt; 3.0))</span><br><span class="line">      +- MetastoreRelation default, t</span><br><span class="line"></span><br><span class="line">== Physical Plan ==</span><br><span class="line">*Project [(cast(key#55 as double) * 5.0) AS (CAST(key AS DOUBLE) * CAST((<span class="number">2</span> + <span class="number">3</span>) AS DOUBLE))#59, value#58]</span><br><span class="line">+- *SortMergeJoin [key#55], [key#57], Inner</span><br><span class="line">   :- *Sort [key#55 ASC NULLS FIRST], <span class="literal">false</span>, 0</span><br><span class="line">   :  +- Exchange hashpartitioning(key#55, 200)</span><br><span class="line">   :     +- *Filter (isnotnull(key#55) &amp;&amp; (cast(key#55 as double) &gt; 3.0))</span><br><span class="line">   :        +- HiveTableScan [key#55], MetastoreRelation default, t</span><br><span class="line">   +- *Sort [key#57 ASC NULLS FIRST], <span class="literal">false</span>, 0</span><br><span class="line">      +- Exchange hashpartitioning(key#57, 200)</span><br><span class="line">         +- *Filter (isnotnull(key#57) &amp;&amp; (cast(key#57 as double) &gt; 3.0))</span><br><span class="line">            +- HiveTableScan [key#57, value#58], MetastoreRelation default, t</span><br><span class="line">Time taken: 0.252 seconds, Fetched 1 row(s)</span><br><span class="line">18/10/18 21:22:20 INFO CliDriver: Time taken: 0.252 seconds, Fetched 1 row(s)</span><br><span class="line">spark-sql&gt; 18/10/18 21:22:20 INFO TaskSetManager: Finished task 0.0 <span class="keyword">in</span> stage 8.0 (TID 8) <span class="keyword">in</span> 15 ms on localhost (executor driver) (1/1)</span><br><span class="line">18/10/18 21:22:20 INFO TaskSchedulerImpl: Removed TaskSet 8.0, whose tasks have all completed, from pool</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/spark-sql-arch.png" alt="Spark-SQL架构图"></p><h2 id="ThriftServer-Beeline的使用"><a href="#ThriftServer-Beeline的使用" class="headerlink" title="ThriftServer &amp; Beeline的使用"></a>ThriftServer &amp; Beeline的使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-thriftserver.sh --master <span class="built_in">local</span>[2] --jars /home/hadoop/software/mysql-connector-java-5.1.23-bin.jar</span><br><span class="line"><span class="comment"># 使用客户端beeline连接即可进行sql操作</span></span><br><span class="line">./bin/beeline -u jdbc:hive2://localhost:10000 -n hadoop</span><br></pre></td></tr></table></figure><p>执行sql后查看<a href="http://192.168.1.100:4040/sqlserver/%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%89%A7%E8%A1%8C%E8%BF%87%E7%9A%84sql%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%AF%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E4%BC%98%E9%9D%9E%E5%B8%B8%E6%9C%89%E5%B8%AE%E5%8A%A9%E3%80%82">http://192.168.1.100:4040/sqlserver/可以发现执行过的sql详细信息，对程序的调优非常有帮助。</a></p><blockquote><p>ThriftServer和普通的spark-shell&#x2F;spark-sql的不同：前者不管启动多少个客户端（beeline或者jdbc代码方式）都是一个spark application，只会在启动server的时候申请一次资源，多个客户端可以共享数据。</p></blockquote><h1 id="DataFrame-RDD"><a href="#DataFrame-RDD" class="headerlink" title="DataFrame &amp; RDD"></a>DataFrame &amp; RDD</h1><blockquote><p>A Dataset is a distributed collection of data.A DataFrame is a Dataset organized into named columns.</p></blockquote><p>DataFrame不是SparkSQL提出的，而是在R，Pandas语言中已有的。DataFrame是加了schame（列名，列类型，列值）的RDD。有了schema信息可以在编译的时候做更多的优化。</p><p>RDD:<br> java&#x2F;scala &#x3D;&#x3D;&gt; jvm<br> python &#x3D;&#x3D;&gt; python runtime </p><p>DataFrame<br> java&#x2F;scala&#x2F;python &#x3D;&gt; Logic Plan</p><p>因此如果语言不同，使用RDD编程会有效率差异，而使用DataFrame则没有区别。 </p><h2 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">  <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">&quot;DataFrameApp&quot;</span>).master(<span class="string">&quot;local[2]&quot;</span>).getOrCreate()</span><br><span class="line">  <span class="comment">// load的参数path支持本地fs和分布式fs</span></span><br><span class="line">  <span class="comment">// json =&gt; DataFrame</span></span><br><span class="line">  <span class="keyword">val</span> peopleDF = spark.read.format(<span class="string">&quot;json&quot;</span>).load(<span class="string">&quot;file:///Users/yiihua-013/tmp/people.json&quot;</span>)</span><br><span class="line">  <span class="comment">// show columns</span></span><br><span class="line">  peopleDF.printSchema()</span><br><span class="line">  <span class="comment">// select * from table limit 20</span></span><br><span class="line">  peopleDF.show()</span><br><span class="line">  <span class="comment">// 查询某列 select name from table</span></span><br><span class="line">  peopleDF.select(<span class="string">&quot;name&quot;</span>).show()</span><br><span class="line">  <span class="comment">// select name,age + 10 as age2 from table</span></span><br><span class="line">  peopleDF.select(peopleDF.col(<span class="string">&quot;age&quot;</span>), (peopleDF.col(<span class="string">&quot;age&quot;</span>) + <span class="number">10</span>).as(<span class="string">&quot;age2&quot;</span>)).show()</span><br><span class="line">  <span class="comment">// select * from table where age &gt; 19</span></span><br><span class="line">  peopleDF.filter(peopleDF.col(<span class="string">&quot;age&quot;</span>) &gt; <span class="number">19</span>).show()</span><br><span class="line">  <span class="comment">// select age,count(1) from table group by age</span></span><br><span class="line">  peopleDF.groupBy(<span class="string">&quot;age&quot;</span>).count().show()</span><br><span class="line">  spark.stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DataFrame和RDD的互操作"><a href="#DataFrame和RDD的互操作" class="headerlink" title="DataFrame和RDD的互操作"></a>DataFrame和RDD的互操作</h2><p><a href="http://spark.apache.org/docs/2.1.0/sql-programming-guide.html#interoperating-with-rdds">DataFrame和RDD的互操作</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataFrameRDDApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DataFrame 与 RDD的互操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">&quot;DataFrameApp&quot;</span>).master(<span class="string">&quot;local[2]&quot;</span>).getOrCreate()</span><br><span class="line"></span><br><span class="line">    inferReflection(spark)</span><br><span class="line">    <span class="comment">//    program(spark)</span></span><br><span class="line"></span><br><span class="line">    spark.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把文本文件通过编程的方式转换成DataFrame</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">program</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = spark.sparkContext.textFile(<span class="string">&quot;file:///Users/yiihua-013/Downloads/tmp/infos.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> rowRDD = rdd.map(_.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">      .map(line =&gt; <span class="type">Row</span>(line(<span class="number">0</span>).toInt, line(<span class="number">1</span>), line(<span class="number">2</span>).toInt))</span><br><span class="line">    <span class="keyword">val</span> structType = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">Array</span>(</span><br><span class="line">        <span class="type">StructField</span>(<span class="string">&quot;id&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>),</span><br><span class="line">        <span class="type">StructField</span>(<span class="string">&quot;name&quot;</span>, <span class="type">StringType</span>, <span class="literal">true</span>),</span><br><span class="line">        <span class="type">StructField</span>(<span class="string">&quot;age&quot;</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> infoDF = spark.createDataFrame(rowRDD, structType)</span><br><span class="line">    infoDF.printSchema()</span><br><span class="line">    infoDF.show()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用反射来推断包含特定数据类型的RDD的元数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inferReflection</span></span>(spark: <span class="type">SparkSession</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// RDD =&gt; DataFrame</span></span><br><span class="line">    <span class="keyword">val</span> rdd = spark.sparkContext.textFile(<span class="string">&quot;file:///Users/yiihua-013/Downloads/tmp/infos.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 需要导入隐式转换</span></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> infoDF = rdd.map(_.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">      .map(line =&gt; <span class="type">Info</span>(line(<span class="number">0</span>).toInt, line(<span class="number">1</span>), line(<span class="number">2</span>).toInt))</span><br><span class="line">      .toDF()</span><br><span class="line">    infoDF.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过DataFrame API</span></span><br><span class="line">    infoDF.filter(infoDF.col(<span class="string">&quot;age&quot;</span>) &gt; <span class="number">30</span>).show()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将DataFrame注册为临时表之后就可以通过sql的方式进行查询了</span></span><br><span class="line">    infoDF.createOrReplaceTempView(<span class="string">&quot;infos&quot;</span>)</span><br><span class="line">    spark.sql(<span class="string">&quot;select * from infos where age &gt; 30&quot;</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>(<span class="params">id: <span class="type">Int</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反射：case class，需要事先知道字段和字段类型</li><li>编程：Row，事先不知道列</li></ul><blockquote><p>优先选择反射的方式。</p></blockquote><blockquote><p>Dataset &gt; DataFrame &gt; SQL,可以更早抛出错误，可以在编译时发现错误而不是在运行时。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/spark-dataset-dataframe-sql.png" alt="Dataset&amp;DataFrame&amp;SQL"></p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/column-storage.png" alt="列式存储示意图"></p><p>列式存储的优点：每一列可以单独压缩，访问同列有更小的IO。</p><p>大数据调优（忽略掉一些不必要的信息）：</p><ul><li>列式存储，列裁剪</li><li>分区裁剪</li><li>使用min&#x2F;max统计信息</li><li>条件下压到数据源（例如将where下压到jdbc）</li></ul><p>其实DataFrame和SQL都会采用Catalyst引擎使用上面的策略进行优化，运行效率是一样的。</p><h1 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h1><ul><li>数据采集：Flume，日志写入到HDFS</li><li>数据清洗：Spark,Hive,MapReduce或者其他分布式计算框架清理脏数据，清理之后的数据可以放在HDFS上（Hive，SparkSQL）</li><li>数据处理：Spark,Hive,MapReduce或者其他分布式计算框架，按照业务进行统计分析</li><li>处理结果入库：结果可以放在RDBMS,NoSQL</li><li>数据可视化展示：Echarts,HUE,Zeppelin</li></ul><h2 id="Spark-on-Yarn"><a href="#Spark-on-Yarn" class="headerlink" title="Spark on Yarn"></a>Spark on Yarn</h2><p>spark支持4种运行模式：</p><p>local:本地开发<br>standalone:spark自带的，如果一个集群是standalone的话，那么就需要在多台机器上部署spark环境，比较麻烦<br>yarn:生产环境推荐使用，统一使用yarn进行整个集群作业（MapReduce,Spark）的资源调度<br>mesos:国内用的不多</p><blockquote><p>不管使用什么模式，spark应用程序的代码是一模一样的，只需要在提交的时候使用<code>--master</code>参数即可指定运行模式即可。</p></blockquote><p>client:Dirver运行在client端（提交spark作业的机器），client会和请求到的container进行通信来完成作业的调度和执行，client是不能退出的。日志信息在控制台输出，便于测试<br>cluster:Driver运行在ApplicationMaster中，client只要提交完作业就可以关掉,因为作业已经在spark上运行了。日志只能通过<code>yarn logs -applicationId application_1540378428255_0002</code>来查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--executor-memory 1G \</span><br><span class="line">--total-executor-cores 1 \</span><br><span class="line">/home/hadoop/app/spark-2.1.0-bin-2.6.0-cdh5.7.0/examples/jars/spark-examples_2.11-2.1.0.jar \</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">./bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn-cluster \</span><br><span class="line">--executor-memory 1G \</span><br><span class="line">--total-executor-cores 1 \</span><br><span class="line">/home/hadoop/app/spark-2.1.0-bin-2.6.0-cdh5.7.0/examples/jars/spark-examples_2.11-2.1.0.jar \</span><br><span class="line">4</span><br></pre></td></tr></table></figure><blockquote><p>大数据压缩格式的可分割性在hadoop中很重要如果支持分割，就可以分隔成多块并行执行task（执行作业时map的启动个数）。</p></blockquote><ul><li>bzip2压缩效果最好，但是压缩速度慢，支持分割</li><li>gzip压缩和解压比bzip2快，不支持分割</li><li>lzo压缩效果不如bzip2和gzip，但压缩和解压速度最好，支持分割</li></ul><p>参数调优</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.sql.shuffle.partitions=300 # 并行度</span><br><span class="line">spark.sql.sources.partitionColumnTypeInference.enabled=false # 禁用分区字段类型推测</span><br></pre></td></tr></table></figure><blockquote><p>大数据处理神器Beam可以使用相同的代码可以运行在MR，Spark，Flink上。</p></blockquote><h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><ul><li><a href="http://blog.51cto.com/hsbxxl/2066487">重新format namenode后，datanode无法正常启动</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> hadoop </tag>
            
            <tag> hive </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字字珠玑</title>
      <link href="/2018/04/15/excellent-words/"/>
      <url>/2018/04/15/excellent-words/</url>
      
        <content type="html"><![CDATA[<blockquote><p>程序员的竞争力并不是写代码，也并不是哪门语言或者框架，其核心竞争力是通过技术解决问题的能力。</p></blockquote><blockquote><p>世上多数美好事物都如此，你在享受它带来的美的同时也要承担它随之即来的残缺。要享受冰镇可乐的畅快，就要承担它带来的卡路里；要去攀爬纯净的山峰就要承担剧烈的紫外线，要得到真诚浓厚的爱就要承担它的争吵、猜疑、厌倦和平淡。然而正是因为那携带的不完美，才让它的美显得更珍贵、夺目、不可取代。</p></blockquote><blockquote><p>我相信事在人为，但是一切又像冥冥中中，自有天意。</p></blockquote><blockquote><p>万法皆空，因果不空。</p></blockquote><blockquote><p>如果提前了解你们要面对的人生，不知道你们是否还有勇气前来，看见的和听到的，经常会另你们沮丧，世俗是这样强大，强大到生不出改变他们的念头来。可是如果有机会提前了解你们的人生，知道青春也不过这些日子，不知你们是否还会在意，那些世俗希望你们在意的事情，比如占有多少才更荣耀，拥有什么，才能被爱。等你们长大，你们因绿芽冒出土地而喜悦，会对初升的朝阳欢呼雀跃，也会给别人善意和温暖，但是却会在赞美别的生命的同时，常常甚至永远忘了自己的珍贵。<br>人把自己置身于忙碌当中，有一种麻木的踏实，但丧失了真实，你的青春也不过只有这些日子。什么是真实？你看到什么，听到什么，做什么，和谁在一起。有一种从心灵深处满溢出来的不懊悔，也不羞耻的平和喜悦。愿你在被击打时，记起你的珍贵，抵抗恶意，愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。<br>这个世界缺的不是完美的人，而是从心地给出的真心、正义、无畏与同情。  –《无问西东》</p></blockquote><blockquote><p>有人说苦难会让人变得高风亮节，其实不然，有时幸福的生活才会让人的情操变得高尚，苦难在大多数情况下只会让人变得心胸狭窄，苦大仇深。我当时还没觉察到人性是多么矛盾，不知道真挚的情感中会有多少矫揉造作，高贵优雅中会有多少卑劣低贱，也不知道罪孽中会有多少良善仁慧。我承认这种生活的社会价值，也知道这是一种有条不紊的幸福生活，但我却有一腔不甘平庸的热血，渴望踏上一条更为放荡不羁的险途。——毛姆《月亮和六便士》</p></blockquote><blockquote><p>人生幸福无非四件事：一是睡在自家床上，二是吃父母做法饭菜，三是听爱人讲情话，四是跟孩子做游戏。————林语堂</p></blockquote><blockquote><p>惯性定律不仅存在于物质世界，也存在于人类的认知世界。人类的经验越丰富，理解新事物的阻力就会越大。这就是为什么很多人说“程序员是个年青的职业”。</p></blockquote><blockquote><p>易经有云“否极泰来”。用易经的哲学思维，从整体上来说，一件事情已然发生，必然会继续发展下去。所谓“一生二，二生三，三生万物”。</p></blockquote><blockquote><p>无形装逼最为致命！老奶奶都不扶就服你！<br>以不正义开始的事情，必须用罪恶使它巩固。——莎士比亚《麦克白》<br>暗恋之纯粹，在于不求结果，完全把自己锁闭在一个单向的关系里面。——梁文道《暗恋到偷窥》<br>好看的皮囊千篇一律，有趣的灵魂万里挑一。<br>每一件与众不同的绝世好东西，其实都是以无比寂寞的勤奋为前提的，要么是血，要么是汗，要么是大把大把的曼妙青春好时光。</p></blockquote><blockquote><p>天下只有两种吃葡萄的人，一种先从最好的开始吃，另一种先从最坏的开始吃。按理说，前者应该是乐观主义者，因为他吃的每一颗葡萄都是剩下的葡萄里最好的一颗。后者应该悲观，因为他吃的每一颗葡萄都是剩下的葡萄里最坏的一颗。实际上往往恰好相反，大概是后者还留有希望，而前者只有回忆。——钱钟书</p></blockquote><blockquote><p>少年易老学难成，一寸光阴不可轻。<br>未觉池塘春草梦，阶前梧叶已秋声。</p></blockquote><p>经济利益驱动法：假设每个人的行为动机都是金钱，让人们听命你的最好方法就是给他们物质奖励或者物质惩罚，以创造行为动机。这种方法的缺陷是将内部激励（内心想做好某件事情的天然愿望）变成了外部激励（来着外部的刺激，有人付钱让你完成某件事）。而内部激励比外部激励强得多。人们为他们正真想做的事格外努力工作，但是花钱让人们去做那些无论如何他们都想做的事情的时候，他们就会受到一种“过度合理化效应”的支配，最终结果是降低了他们做出优异工作的愿望，停止外部激励的时候他们就没有动力了。另一个问题是：人们有追求局部利益最大化的倾向，他们会想尽办法得到最大化的报酬，但是实际上并不会达到你正真想要的结果。认同法就是设法产生内部激励。</p><p>在软件项目管理中军事化管理法是行不通的，可能造成囚徒的困境。</p><p>“共地的悲剧”：由美国生态学家提出，在公共草地可以无偿放牧，所以牧羊人一定会过度放牧，尽可能多地占用共地资源，因为如果他不这样做其他人也会这样做。最终结果就是共地的荒芜。在经济学上特指公共资源会因为过度使用而枯竭。过渡砍伐的森林、过度捕捞的渔业都是“公地的悲剧”的典型例子。之所以叫做悲剧是因为：每个当事人都知道资源将会由于过度使用而枯竭，但是每个人对事态的继续恶化都感到无能为力，而且都抱着“及时捞一把”的心态加剧事态的恶化。</p><p>空酒馆效应：没有人愿意去空的酒馆吃饭。他们愿意去隔壁的拥挤不堪的酒馆吃饭，哪怕难吃的要命。</p><p>停机问题：无法找到一个程序用来判断任意函数在有限的输入的情况下是否会在有限时间内结束，由图灵证明。</p><p>能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。 ——鲁迅</p><p>在那个小小的梦的暖阁，我为你收藏整个世界的烟雨。</p><p>人类在工业革命以前，生产资料主要是通过第一产业（尤其是农业和畜牧业）积累，或者部分第三产业（商业），其对应的社会形态分别是农业文明，游牧文明，商业文明。<br>自从爆发了工业革命，第二产业的生产效率以指数级别上升，直接把其他产业文明全部干尿，所以，现在的世界，哪个文明不拥抱第二产业，哪个文明就是死蛤呀只<br>第一个在制造业领跑的是联合王国，以强大海军为纽带，殖民地为原材料供应基地，英伦三岛为第二产业心脏，成为全球霸主<br>第二个在制造业领跑的是合众国，以强大的海军为纽带，WTO 为框架，成为全球霸主<br>在英国和美国交接棒的时候，曾经有个很好玩的事，有英国人反对制造业大量外流美国，提出技术封锁资金封锁，但是有人就安慰说，不用怕，我们只是把生产基地迁到成本更低的美国，国内仍将保有科技研发实力，金融实力，而且美国工厂背后都有英国资本。<br>但是啊，傻就傻在这了，效率高与成本低其实是制造业的两只脚，平时坐着数钱当大爷没事，一旦打起仗来就知道腿脚哪不利索了。虽然一直到二战结束后，英国依然掌握核心科技，但是在战争中，英国的黄金开始大量外流美国，英国牛逼啊，飞机你造的坦克你造的，但是 30 万士兵的袜子，只能找美国买，30 万士兵的靴子，只能找美国买，这种低端工业产业对资金的消耗也是巨大的，英国财政开始出现危机，于是大量的股份抵货款，美国人成为自己土地上生产资料的所有者。<br>二战一打完，人类第一个通过制造业称霸全球的国家轰然倒塌，所以英国拍什么敦刻尔克呢，其实应该认真的拍一下英国的制造业是怎么流失的。<br>所以 2010 年，其实从奥巴马开始，就在喊重振美国制造业，但是奥巴马就是嘴炮打打，真要重振制造业，就要重新分生产资料，就会动了别人的奶酪，奥巴马比较在乎人设，所以根本不会有实质性举措。<br>我说的只是我自己的判断，事实是什么样很难讲。你说信息产业的生产效率增长到一定阶段，成为 “第四产业”，能够积累比第二产业还更多的生产资料，不知道，但有一点，战争的本质是什么，就是更高效率更低成本地整合生产资料生产出更牛逼的杀人武器。<br>工业革命之前，农业商业畜牧业其实差不多，效率成本差不多，而且往往畜牧业还略微有点优势，出过蒙古骑兵这个 bug。工业革命之后，在制造杀人武器这一方面，只玩商业只玩农业只玩畜牧业的下场大家看到了，尤其是英国的先例，你把第二产业的生产资料渡让出去，等同于自断经脉。<br>所以，未来世界的主旋律，就是几个核心玩家以自己的制造业效率和成本为依托，在全世界抢土地抢生产资料的节奏.</p><p>基于效率不可回撤，ai 屌不屌，肯定屌，会不会让一部分人失业，肯定会，那是不是咱们都玩完了，肯定不会。<br>举个例子，原来美国有一个非常庞大的产业人群——码头工人，码头工人工会也是非常强的工会。但是当集装箱出现了之后，货物的运输开始大量使用机械，那些手挑肩抗的码头工人强烈地抵制集装箱的使用。<br>但是在效率面前，在经济账面前，更高效的事物一旦出现，就不可阻挡。大码头公司的工人多，抱成团，很难说裁员就裁员，小码头因为规模小，工人少，包袱轻，就更容易先转型。<br>当越来越多的码头开始使用集装箱标准，效率势差就越大，最后大码头货运下降，效率下降，预期收益越来越低，维持现有框架的成本越来越大，大家都会算账，当不变的成本大于改变的成本时，就一定会有力量出来说，去他娘的我们也要用集装箱。<br>而使用了集装箱之后，机械给人赋能，码头工人数量肯定会变得比原来少，不具备应有技能的工人，可能就只能另谋生路。<br>对于那些失业的码头工人，肯定会非常绝望的，因为年龄或者某些客观条件的限制，他们可能没有时间没有条件没有心情重新学习技能去加入另外的产业。所以如果开上帝视觉马后炮，假如一个开天眼的码头工人，当他感觉到码头的产业会面临集装箱的升级，应该做的不是去阻挡，不是去干他娘的，应该利用你先知先觉的这一段很宝贵的时间，要么学会拥抱集装箱的技能，要么学习加入其他产业的技能，因为当码头的效率升级之后，必会有其他产业因此而受益，迎来一个高增长空间</p><p>美国的码头推行集装箱标准之后，那是不是美国制造业就牛逼了，因为物流环节的效率成本枷锁一下子被打开了，额，具体情况是，日本制造业牛逼了，因为他们制造的商品更物廉价美，直接冲击了整个美国市场。除了以汽车飞机为代表的高端制造业还能抵抗，中低端基本上就完全被碾压了，大量的本土就业岗位消失，是的，能有多少孩纸能够进波音进福特工作呢，某种程度上，（这个观点是我自己说的，不敢保证对）无法加入产业就业的年轻人就成为嬉皮士文化的土壤。<br>这个嬉皮士文化运动为什么后来又消解了，原因有很多，我肯定说不全，有可能年龄大了躁不动了，有可能家里长辈觉得再不让我们抱孙子我们就凉了，但是有一种说法是，美国崛起了以麦当劳为代表的服务业，以硅谷为代表的高科技产业，以卡车司机为代表的物流产业，和以电视为代表的媒体新闻娱乐产业，这些产业容纳了大量的嬉皮士，分散在各个产业的嬉皮士，各奔东西之后产生了隔阂，就很难再因为一点屁事大规模聚集了。<br>所以在 AI 的冲击波下，那些离得近的人怎么办，根据集装箱的推演逻辑，有4种方法：<br>进入上游制造 AI 行业（制造集装箱，制造港口机械）<br>留在原行业使用 AI（在码头当机械操作工人）<br>进入下游会因 AI 收益的行业（当集装箱卡车司机）<br>进入与 AI 弱相关但是全新的产业（服务业，高新科技制造业，新闻媒体娱乐业）<br>当然也可以像乔布斯一样，先在失业迷茫的人群浪潮里快活一把，薅一把颓废思潮的羊毛，再进入新的产业 stay simple stay naive<br>另外补充一点，从集装箱推演和芯片的发展来看，当一个产业技术创新效率爆炸所带来的红利，会在下游以量级叠加，也对嘛，你在上游撒尿肯定往下游走。所以由此肯可以推断，AI 技术成熟之后，，会带来一个坏消息和一个好消息，坏消失是，AI 会让非常多的人失业，好消息是，AI 所带来的产业冲击，会在其下游以指数级别的红利回报给大家。<br>So，那里会是一个美丽新世界</p><p>最后的疯狂：当一个趋势真正要到达终点时，外在表现会接近于疯狂。这在波浪理论中很明显，当然波浪理论往往有回溯性不具有前瞻性，因为人类的疯狂无法计算，大部分临界点的判定都只能使马后炮。举两个例子，美股现在涨的多高了？什么时候到头？有多大把握？港股现在也是历史新高了，什么时候到头？别的不敢说，香港股市如果一个猛子扎下去，香港应该再也爬不起来了，算是为香港这座城市，从 1949 到 201X 半个多世纪的拼搏奋斗史，画上一个圆满而绚烂的句号。</p><p>土地是土地，生产资料是生产资料（土地是生产资料的子集），人是人，人有人种民族，人之上还有文化。<br>2000 年前，犹太人弱势流浪在欧亚，不掌握土地，掌握生产资料，一路起起伏伏各种磨难，现在在美国，依然不算是主体民族，但某种意义上算是一种主流文化。<br>1600 年前，日耳曼人强势进入罗马，抢土地，抢生产资料，日耳曼人自称西罗马<br>1000 年前，吉卜赛人弱势进入欧洲，不掌握土地，没有积累生产资料，不妥协不合作，坚持自己的民族文化一千年不动摇，也是不容易。<br>500 年前，西欧人强势进入美洲，抢土地，抢生产资料，以日耳曼文化为主流。<br>几年前，穆斯林弱势进入西欧，<br>其实弱势和强势的区别就在于，是否有军队力量参与土地和生产资料的争夺。<br>所有的强势入侵的开始，一开始都是弱势的，但弱势的入侵也是必要的，当弱势的入侵持续而有力，就会沉重着打击被入侵土地上原有的经济文化秩序，加大社会运转成本，最后的临界状态是内忧外患，内忧是财政忧，外患是军事患。然后一个引爆点，土地和生产资料易手。</p><p>有两种生物是有比较先进（我认为的）的社会形态的，一种是人类，一种是蚂蚁。但是有趣的不同在于，人类的分工是后天形成的，蚂蚁的分工是先天的。换句话说，人和人基本都一样，你有鼻子我有眼，蚂蚁不同，工蚁兵蚁雄蚁雌蚁在生理上就有很大差别。所以生理构造上几乎相同的人如何组织起来，很大程度上取决于脑子，谁洗谁的脑，所以人类还有发达的语言文字系统（我不确定蚂蚁有没有类似功能系统，比如气味啊或者啥的）。而蚂蚁就像所谓的松散生命，单一的个体只是实现单一功能，一个蚁群才像是一个完整的生命体。</p><p>《机器智能》</p><p>传统计算机必须先由人类进行编程才能执行某项特定任务；而认知系统则会从数据与人类的交互中学习，从某种意义上来说：它可以自行编程执行新任务。传统计算机被设计用来快速计算；而认知系统则被设计用来从数据中推导出结论并达成指定目标。传统计算机只有基本的感知能力，而认知系统则会添加人类的听觉、视觉、味觉、嗅觉和触觉。在由程序控制的计算机的时代，人们必须适应计算机的工作方式，而在认知时代，计算机将会适应人。它们将会与我们与生俱来的方式和我们进行互动。<br>冯诺依曼瓶颈：处理过程中每个元素都需要多个步骤：数据和指令在CPU和内存之间来回移动，这需要移动和处理大量数据，这也就意味着离散处理任务只能每次一个、线性地完成。通过人脑可以得到这样的启发：数据处理不应该是集中在CPU中，而是应该分布在整个计算系统中，处理能力应该和存储水平紧密结合以减少数据和指令的来回传输，离散任务处理应该并行而不是串行。</p><p>量子通信的目的是实现加密而不是超光速通信。量子纠缠和蝴蝶效应好像有点相似哦。隐变量理论被认为是错误的，仅仅用量子纠缠无法传递任何信息，因为它们是完全随机的，也就是“噪声”。</p><p>数字信号是否一定比模拟信号好呢？答案可能不是那样：因为自然界是模拟的，人脑也是模拟的。采用数字技术主要是为了便于现有的计算机处理。</p><p>《机器危机》</p><p>在大众市场中，企业的生存死亡与繁荣衰败是由消费者的集体购买行为所决定的，这是一种自然形成的运转机制。一家低效的公司倒闭之后，其资金、资源、员工最终会流入更加强大的新企业。在市场机制的作用下，参与者的总量和财富总额都在不断增长，它是推动市场经济发展的主引擎。</p><p>谈到奴隶制，人们的注意力几乎都集中在道德沦丧和骇人听闻的暴行上，很少有人思考奴隶制（把一部分人当成机器人使用）对社会经济的影响。虽然林肯为首的北方人民反对奴隶制主要是出于道德诉求，但是南北不同的经济体制也是双方产生冲突的重要原因。北方经济以自由劳动力和创业精神为基础，保证了大多数人可以获得较平等的机会。相反南方各轴把奴隶作为劳动力，财富主要集中在拥有大量奴隶的农场主手里，这种经济体制导致市场能够提供的自由劳动机会非常有限，所以南方普通百人很难改变他们的境况。在南方各州相继推出联邦后，林肯对南方经济实行封锁，效果非常明显：最终导致了南方的棉花出口量降低了95%，这也是内战爆发的导火索，1865年战争结束后，南方经济已经彻底崩溃。</p><p>一旦自动化大规模冲击就业市场，大众市场经济就会走向衰败。原因很简单：如果我们把市场看做一个整体就可以发现靠工作获得收入的劳动者同时也是购买产品和服务的消费者。换句话说：机器虽然能代替人类工作，却不会参与消费。在自动化进程的早期阶段，它退经济的冲击还不算明显。第一批实现自动化的企业开始裁员，其生产成本大幅下降，而此时的市场需求还没有出现显著下降。事实上，需求在一定时间内不降反升，因为产品价格降低了。因此企业利润以及管理者和股东的收入都会增加。然而随着越来越多的企业实现自动化，总有一天潜在的消费者小时带来的损失会超过自动化带来的好处，到那时企业将被迫大量裁员，导致市场中的消费者数量急剧减少，市场需求大幅缩水。于是整个经济就陷入了螺旋式的恶性循环，每况愈下。</p><p>数字按照固定周期倍增称为几何级数增长或者指数级增长。几何级数非常具有欺骗性，期初很难察觉，但它会突然开始爆炸式增长。</p><p>卢德分子：反对科技进步或者无法适应新科技的人。出自于英国工业革命时期抗议纺织机取代纺织工而毁坏机器。</p><p>工厂自动化在提高生产率的同时，也会让全世界制造行业的工作机会不断减少，发展中国家也不例外。</p><p>如果某人知道自己将会获得一大笔财富，那么他从现在开始就会提高消费水平，哪怕他现在还没收到那一笔钱。为了应付不确定的未来，人们会大幅缩减开支，同时增加储蓄。</p><p>自动化造成的劳动力成本不断下降的同时，能源成本会持续上升。</p><p>劳动密集型产业：需要较多劳动力参与的产业。例如：制造加工、零售、运输、餐饮、酒店<br>资本密集型产业：把大量资金投入科研和购买先进设备上。例如：半导体制造、生物技术、信息技术（包括互联网）</p><p>在劳动密集型产业向资本密集型产业过渡的过程中存在一个临界点，一旦越过这个临界点，大范围的失业后果将会吞噬科技进步带来的红利，经济状况将会急转直下。</p><p>经济增长的限制有四点：一曰劳动力，二曰能源，三曰技术，四曰需求。</p><p>软件最大的好处，就是让一切变得简单。但是，做到这一点的方法，是正确设置缺省值，而不是限制用户的选择。</p><p>懂得示弱，才是真牛逼的人，而不是处处表现的比别人强。</p><p>青春是一道明媚的忧伤。</p><p>虽然爱情很甜蜜，但这份甜蜜会让你失去斗志，失去野心，甚至失去梦想。<br>这个世界上，除了自己，谁都靠不住的。<br>人终究是独立的个体。<br>古人云，<br>士之耽兮，犹可说也<br>女之耽兮，不可说也。<br>不论你们现在多相爱，总有一天会发生意外。</p><p>人的一切痛苦，本质上都是对自己无能的愤怒。</p><p>货币第一层，也是最底层，是商品流通，拿着货币能买东西；第二层，股权流通，就是能对未来的商品定价，甚至分红，就是钱生钱利滚利。目前基于第一层流通的数字货币是比特，市值第一；基于第二层流通的是以太，市值也接近比特了（最近一年暴涨）。由此可见，当前的货币环境下，购买商品需求的增长远不如拿数字货币非法集资来得猛。</p><p>当你老了，回顾一生，就会发觉：什么时候出国读书、什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，还以为是生命中普通的一天。 ——陶杰 《杀鹌鹑的少女》</p><ol><li>好运气从来都不会眷顾只会做白日梦或者怨天尤人的人。</li><li>你必须非常努力，才能看起来毫不费力。</li><li>人要先做自己该做的事情，再做自己想做的事情。</li></ol><p>效率不可回撤：效率更高就是好，就是牛逼的。<br>奥卡姆剃刀：如果没有必要，就不要。<br>布鲁克斯法则：向一个已经延期的软件项目中增加人手只会使得它更加延误。<br>幸存者偏差：只考虑了幸存者存在的特征，这并不能得出一个有说服力的结论。</p><p>如果是 2c 的产品，变现的筹码就是流量，所以一定要抓住屌丝，因为屌丝虽然没钱，但是有闲，可以贡献大量的流量；2b 的产品，变现的筹码就是产品质量，质量好自然买卖做的成，因为企业非常看重产品的功能与稳定性。所以那些整天说快播 low 的，老实说，这很正常，不 low 不嗨，一群高富帅白富美发点模模糊糊的夜店嗨照也没多大劲。另外，别小看这些流量霸主，一旦模式成熟，内容贡献者群体成熟，整个平台会直接上几个量级。举个都被举烂的例子，qq，当年你跟人留个 qq，挖槽尼玛你个 low 逼，我们都用 msn。发邮件一看是 qq 邮箱，我操你妈你个 low 逼，我们都用 gmail。可是你现在真正回头看，谁还在用 msn？所以啊，尽管埋头赚钱吧，不要理会别人的嘲讽，要坚信，只要有钱了，就莫名其妙洗白了。</p><p>记得有个朋友找我个事儿，我说，我考虑一下，他很激动，考虑就是准备答应了？我说，不是，我在考虑怎么拒绝你。</p><p>欠的都要还的，缺的有一天一定会找回来的。比如我特么就是玩泥巴长大，自然洗脚上岸就巴不得天天宅着，吃着烤鸡腿，那些都市白领跑去山里跑去乡下我是觉得 naive，有个屌子好玩，我他妈就是山里出来的，然后叫我回去，说远离城市喧嚣？记得之前有个同学说，他的理想是以后赚够了钱，去北海道买一套小别墅过着半隐居的生活，我心想，爱去去，妈的闲得蛋疼，我他妈就喜欢住在闹市区，半夜肚子饿了下楼吃个烧烤喝个小酒，人来人往嘈杂的不行，这样是坠吼的。我小时候基本上东南沿海就走过一圈了，碰上过暴雨城区积水齐屌深（因为我那时候小嘛，我的裆部差不多是大人膝盖大腿位置吧），结果鸡鸡发炎疼的走不乐路，也碰上过烈日把脖子晒脱一层皮的，还碰上过被毒蚊子咬了满腿奇痒无比我使劲抓结果最后化脓感染的。所以上了初中，我基本上，就很不喜欢出门，或者说，很不喜欢挪窝，出门对于我来说，并没有什么开地图的新鲜感啊，我只觉得很累。我在哪呆下来，就很不喜欢动屁股了。到了大学有的同学翘了课越南柬埔寨走了一圈，还有一冲动休学去非洲支教的，回来还开讲座讲述自己各种见闻，我觉得很青春很热血，但要我肯定是一点也提不起兴趣听你讲什么见闻的，见了又怎样，不见又怎样，傻逼环游世界一圈下来还是傻逼，好玩的人天天呆地下室做木工也还是好玩。更至于有些朋友说人生理想是财富自由环游世界，啊，财富自由我也很喜欢，但是环游世界这个就有点。。指向模糊。当然我觉得，这是一个坎，就像山里的孩纸，总会想着，山那头是什么。当真正去了之后，山那头还是山，或是平原或是海，到底是啥，其实并不是很要紧的，那什么要紧呢，攥钱要紧。不过走出去这个坎是要迈的，而且越早迈越好。就像面对生死，这个坎，是要迈的，经历过亲人的离去，真的对于生活，会是完全不一样的体会。也比如说，勇敢去爱，是要经历的，越早越好。有的人我看读书的时候老是觉得，不能谈啊不能谈，父母不同意啊，要好好学习啊，可是真的等到谈婚论嫁了相夫教子了，又觉得，没好好谈过啊，这种人稀里糊涂结了婚更糟，往往越往后心里就越有一个遗憾，我为什么年轻时候没好好去谈恋爱啊，最可怕的就是，已经有了家庭有了孩纸，心里却一直有个疙瘩，我没有好好爱过，将伴侣将孩纸将家庭视为累赘，最后憋到一天实在觉得，我要过自己的生活！老实说，什么是自己的生活呢？什么是自己想要的生活呢？</p><p>根据统计，IT 行业产生的数据每年增加30％至40％，但是硬盘的容量增长率达不到这一速度的一半。幸运的是，大部分数据不需要立即访问。对于这样的情况，磁带是完美的解决方案。<br>实际上，磁带机从未消失，世界上大部分数据仍然保留在磁带上，还有一群科学家，他们的工作就是不断改进磁带存储。磁带已存在很长时间了，并且在过去几十年中取得了巨大进步。<br>历史上，第一个商用数字磁带存储系统IBM的 Model 726，可以在一卷磁带上存储大约1.1MB。今天，现代的磁带一盒可存储15TB。一个磁带库最多可包含278 PB的数据。这刻成光盘，将超过3.97亿张光盘，如果堆起来，高度将超过476公里。<br>磁带的缺点是不能提供硬盘或半导体存储器那样的快速访问，但是磁带有很多其他优势。首先，磁带存储更节能。一旦记录了所有数据，磁带就会安静地放在磁带库的插槽中，根本不消耗任何电量。磁带也非常可靠，错误率比硬盘低四到五个数量级。磁带非常安全，具有内置的动态加密和介质本身提供的额外安全性。毕竟，如果磁带未安装在驱动器中，就无法访问或修改数据。<br>磁带的离线存储，为数据安全提供了额外的防线。2011年，软件更新的一个 bug 导致 Google 意外删除了大约40,000个 Gmail 帐户的电子邮件。幸运的是，数据记录在磁带上，谷歌最终可以从该备份中恢复所有丢失的数据。最近，微软让人们知道它的 Azure 归档存储使用了 IBM 磁带存储设备。<br>磁带还有经济优势。磁带存储的成本，是磁盘上存储相同数据量成本的六分之一，这就是为什么任何存储大量数据的地方都会找到磁带系统的原因。但是由于磁带现在完全从消费级产品中消失，大多数人都不知道它的存在，更不用说了解到磁带录制技术近年来取得的巨大进步，并将在可预见的未来继续发展。</p><p>手机移动网络信令样本容量大、覆盖范围广、数据稳定可靠、对信令信息的相应字段进行分析、挖掘，并结合GIS技术可以实现区域实时人流量的智能化统计分析。</p><p>《人类简史》的作者尤瓦尔·赫拉利的最新文章。他提出，人工智能有利于政府，可以将权力集中在少数精英手里。唯一可能的解决方法，是寻找分布式的技术方案，防止资源的集中。</p><p>畜牧业是人类蛋白质供给的主要来源之一，也是温室气体的主要来源之一。每一吨红肉的背后，都是大量的二氧化碳释放。<br>为了减少温室气体，科学家提出，我们也可以食用细菌产生的蛋白质。有些细菌可以食用糖或氨，随着它们的生长，可以被干燥，碾成粉末，用作蛋白质供人类或牲畜食用。计算后发现，如果大规模应用，到2050年，细菌每年可替代175至3.07亿吨的饲料，减少土地使用量6％，温室气体排放减少7％。 </p><p>熔岩灯可以当做伪随机数生成器。</p><p>时间和空间本身是一体的，而引力只是时空在大质量处的弯曲效应。</p><p>浮力是压强差造成的，物体受到的浮力等于其排开液体的重力，所以航母的排水量多少吨是指航母的质量。 </p><p>避开攻击的最好方法之一就是让它看上去获得了成功。</p><p>科技是把双刃剑，人工智能的发展虽然能极大提高工作效率，但是也会带来严重的社会问题。例如会教书的机器人取代老师，无人超市的取代售货员。饱暖思淫欲，当太多的人无事可做的时候就会带来严重的社会问题。更有甚者，当人工智能用于战争，机器人拥有思考能力，可能会对人类自身造成威胁，想想就很恐怖。</p><blockquote><p>游戏制作的核心是机制和美术，而游戏还需要运营，运营好不好真的差好远。机制的核心就是正负反馈，正反馈就是玩得爽，负反馈就是不爽，但这是相辅相成的，负反馈愈强，就是游戏难度越高，难度越高，其实胜利的快感会愈强。快感就是压力的释放。</p></blockquote><blockquote><p>绿地项目：没有太多前置约束的项目。类比自在一块绿地上开发项目，没有既有建筑和基础设施的约束。</p></blockquote><p>如果一个人不想做某件事，通常不是由于客观条件不允许，而是他有下面四种心态之一：恐惧（Fear）、排斥（Rejection）、自卑（Low self-esteem）、怠惰（Laziness）</p><p>金钱最有价值的用途就是购买时间，换来更多的时间让你做自己想做的事情。老板就是花钱买员工的时间。</p><p>视频网站 Youtube 的视频广告有个特点：倒计时五秒之后，用户可以自由选择是否跳过广告。表面上，它把看不看广告的选择权给了用户，但其实 Youtube 用这种方法真正“控制”了用户。如果一个广告不能跳过，用户很可能在播放广告的时候跳出去干别的，根本就不看广告，可一旦有了跳过按钮，用户起码会看5秒钟的广告，这极大地增加了广告的“到达率”，缩减了成本。类似的案例在其他地方也有所体现，比如微博的开屏广告，不论你跳过或不跳过，其实你都已经看过了。</p><p>人的大脑就是这样，得到的控制权越多，安全感就越强，做事的积极性就越高，当人感觉控制权在自己手里，逆反心里就不会那么强。</p><p>《万物简史》</p><p>农业文明或多或少地带来了一些负面影响，比如它在某种程度上抹杀了人类的勇敢、勤劳的特性，现在已经没有多少人愿意外出狩猎了，养尊处优的人越来越多，而随着人口的增长，内部矛盾逐渐增加，分裂的可能性不断扩大。更大的矛盾在于种植和养殖带来了人口的膨胀，为了养活更多人，农民必须更加努力工作，这就造成了一种恶性循环——圈养和养殖开始慢慢成为一种职业，一些老弱病残或者地位低下的人开始负责这项枯燥的工作，而它们的社会地位也越来越低，并且被剥夺了优先享用美食的权利，这就造成了一种奇怪的现象：养牛的人一口牛肉汤都喝不上，种植葡萄的人连一粒葡萄也吃不到，养蚕的人穿不上贵重的丝织品……这种现象甚至影响到了现代文明社会——这是农业文明带来的一个深远影响，而且是饱含讽刺性的。</p><p>其实无论是国家还是其他政权结构的出现都无法改变一个事实：很大一部分人最终变成了专业的养殖户和种植户，它们为整个庞大的社会提供粮食，但令人寒心的是，这样的工作却从未被当做一项伟大的事业来对待；相反这部分职业化的人却站在了社会的最底层，他们成了农民，而在当时以及以后的大部分时间里，农民都是受剥削的人群。因为在其他人看来，农民所做的一切都是过去那些老弱病残所做的事情。</p><p>从生存的角度来说，人类生存最基本的模式应该是追捕猎物，四处寻求食物和领地，但是种植业和养殖业的出现改变了晚期智人的生存模式，人类不得不花费大量时间和精力在田间劳作，做一些播种施肥圈养动物之类的琐事。从这方面来看人类似乎反这些动植物控制；而进入工业社会之后控制我们的是机器，现在则是手机。</p><p>动物也知道头脑发达的好处，但是在漫长的进化史中并没有出现会写诗的狗，也没有出现会进行几何计算的鸭子，金牛管一些动物具有更大的脑容量，但是他们并没有肆无忌惮让自己的大脑不断增大。过大的脑容量同样会成为一个负担，因为大脑会造成巨大的能量消耗。休息的时候大脑会消耗25%的能量，这对人类来说永远是一个负担。为了弥补在休息的时候遗失的能量，我们不得不花费大量的时间寻找食物。事实上很多动物在吃完一顿之后可以好几天不进食，例如狮子、老虎这样的顶级食肉动物可以饿上好几天，蛇和乌龟之类的动物可以好几个月不进食。在动物世界中，没有哪一种动物可以确保自己每天吃上一顿方。事实上如果每天都必须进食才能生成的话，动物们早就被生物链淘汰出局了。</p><p>年轻人，尤其是经济条件不特别好的人，要慢慢学会（在条件允许的情况下）用金钱换概率，要学会一种风投的思维。错十次不要紧，对一次就把错十次的损失全部弥补回来!</p><p>2004年，eBay 在中国拥有85％的网络拍卖市场份额。当时阿里巴巴只有 B2B 业务，很担心 eBay 影响到 B2B 市场。于是，马云开始筹备一个叫做淘宝的网站，作为 eBay 的直接竞争对手。<br>当时，eBay 基本上是照搬他们在美国的做法，没有为中国市场定制产品。淘宝上线后，马云尝试了各种创新，试图将自己与 eBay 区分开来，但是成效不大。<br>但是，eBay 有一个致命的缺点，就是他们要从交易中收费，这是 eBay 赚钱的方式。为了达到收费的目的，他们想尽办法，将买家和卖家尽可能分开，防止他们直接接触，绕过平台，私下交易。马云看到了这点，宣布淘宝不收费，并且推出了聊天功能，允许买卖双方直接聊天，这一招让 eBay 逐渐失去市场份额。<br>2007年，eBay 终于认输，开始退出中国市场。但是，阿里巴巴的代价也很高，就是无法从淘宝的用户交易中直接赚钱，不得不从其他渠道赚钱，比如关键词的竞价排名、店铺装修等等，后面推出天猫也是这个原因。</p><p>《无界·人工智能时代的认知升级》</p><p>智力具备遗传性，随着一个人的成长，先天智力的影响会越来越大，其他因素影响会逐步降低。</p><p>庄子·逍遥游 “乘天地之正，御六气之辩，以游无穷”。人生要用更多的维度去看待，众人所追求的未必就是适合自己的，一个人需要找到适合自己的路并建立属于自己的独立价值观，这样才能抛开成见，达成自己的逍遥游。庄子的人生哲学看似无为消极，实际上是教导我们：第一，世界上的很多事情不需要刻意追求。特别是过多的名利和物质，只有降低对物质的依赖才会让个人获得自由；第二，人生需要做选择，做适合自己的事情而非别人要求你的事情，这样更有价值。</p><p>孟子有言：“老吾老以及人之老，幼吾幼以及人之幼”表明爱是有等级、有差别的，越亲近的爱得越深越多，越疏远的就爱得越浅越少。墨子的兼爱精神提倡人人平等、四海一家、天下大同这个观点虽然美好，但是却不符合人性。</p><p>对于不同人来说不同物品的价值是有差异的，这些差异使得经济行为发生，自由交换可以顺利进行，而在交换的同时，是正和博弈在起作用而不是零和博弈（也就是说经济行为会让双方都获得收益，而不是一方收益一方损失的情况）。在交换过程中也不存在所谓的等价交换，因为不同人对不同物品的评价不一致，所以才产生了不等价交换，也就产生了财富。</p><p>无论在哪个领域，最大的风险就是黑天鹅事件，而且黑天鹅事件有一个特点，就是完全不可预测，唯一能预测的就是它一定会到来。</p><p>大脑是有缺陷的，在很多时候我们的行为受到潜意识的影响而不是凭借我们的自由意志。</p><p>情商指的是对别人情绪的探查和自我情绪的把控能力。这些软性技能在未来会越来越重要，因为计算、体力劳动会逐渐被机器所替代。</p><p>《国富论》</p><p>经济的发展依赖技术进步和创新，市场机制发挥作用的核心在于分工。分工以后每个人对劳动的熟练度越来越高，而技术创新也就出现了。某个市场是否能够充分发展在于这个市场规模是否足够大，如果拥有足够大的市场规模，分工就会越来越细，然后技术就会进步，财富就会增长，反过来也会帮助市场规模的增大，这样就形成了一个正向增长的闭环。</p><p>在没有遇到这个对的人之前，我不会将就，我会把自己弄的好好的，好好吃饭，好好睡觉，好好工作，把自己照顾的健健康康的，做一个开开心心的普通人。</p><p>《金陵十三钗》</p><p>从传统意义上讲，男人总是去和妻子、母亲那样的女人成立家庭，但从心理和生理都觉得吃亏颇大。成熟一些的男人明白雌性资质多高、天性多风骚的女人一旦结婚全要扼杀她们求欢的肉体的渴望。把那娼妓的美处结合到一个良家女子身上，那是做梦；而反之，把淑女的气质罩在一个娼妓身上，让她以淑女对外而以娼妓对你则是可行的。</p><p>现实是一堵墙，一开始你适应它，后来依赖它，到最后你发现你已经离不开它了。人的一生，究竟是该为适应现实而奋斗，还是该为实现梦想而奋斗，这的确是个问题。如果你选择了适应现实，那么你对梦想的态度将会经历下面的变化，一开始你是放下梦想，接着你开始鄙视梦想，到最后你便完全的厌恶梦想。所以当我看到一个对梦想持一种厌恶的态度的人的时候，我就知道我们不是一类人。</p><p>面试金句：为什么考虑出来看看?”现在自己的技术成长有点碰到瓶颈，加上一直对您公司钦慕有加””</p><p>猫屎咖啡是世界上最贵的咖啡之一，是印尼麝香猫吃下咖啡浆果排泄出的咖啡豆制成的。过去，人们是在树林捡拾野生麝香猫排泄的天然咖啡豆，数量稀少且生产速度慢，于是咖啡商人开始人工养殖麝香猫，以求大量生产猫屎咖啡。</p><h1 id="帕金森定理"><a href="#帕金森定理" class="headerlink" title="帕金森定理"></a>帕金森定理</h1><p>在 1957 年，英国作家 西里尔·诺斯古德·帕金森 提出了「帕金森琐碎定理」，用来说明大型组织会花费大量时间在讨论无关紧要的琐事上，但是真正重大的决议反而可以轻松过关这种现象。</p><p>帕金森描述了一个虚构的财政会议，其中有三个议题：第一项是搭建一个价值千万英镑的核反应堆，第二项是建一个价值 350 英镑的员工自行车棚，第三项是每年为联合福利议会咖啡店赞助 21 英镑的提案。</p><p>关于这三个提案，帕金森分别做了描述：</p><ol><li><p>一千万英镑的核反应堆在数额和技术含量上都高高在上、遥不可及，在 2.5 分钟的讨论之后便通过了。一名议会成员提出了完全不同的计划，然而没有人愿意放弃议会目前取得的进展所以响应寥寥，另一位熟悉该议题的成员略有担忧，但是他觉得无法向议会的其他成员解释清楚，最终作罢。</p></li><li><p>自行车棚的议题则处于所有人的理解范围之内，并有丰富人生经验予以支撑意见，议会成员 Softleigh 先生表示铝制棚顶价格高昂，应使用石棉；Holdfast 先生提议使用镀锌铁；Daring 先生则对是否有必要建自行车棚表示质疑；Holdfast 表示反对。辩论自此拉开帷幕…… 在经过 45 分钟的讨论，并得出有可能节省 50 英镑的结果之后，议会成员们带着完成使命的成就感纷纷坐回原位。</p></li><li><p>帕金森继续描写第三项议题：“也许有些成员无法区分铝制棚顶或石棉棚顶，但是所有人都了解咖啡：它是什么，应该如何做，该在哪买，以及到底该不该买。这项议题将会占用议会成员一小时十五分钟的时间，然而由于时间关系，会议结束时议员要求会议秘书提供更多信息，同时将此项议题的决定留待下次议会处理。”</p></li></ol><p>软件开发行业中起始存在很多帕金森问题：</p><ul><li>世界上最好的编程语言是?</li><li>React 和 Vue，哪个更好?</li><li>世界上最好的编辑器是哪个？Emacs 还是 Vim？</li><li>代码中的缩进应该用 Tab 还是空格？</li></ul><p>类似的问题还有很多，并且通常争论不休。与其参与到其中图个嘴上痛快，不如踏踏实实地关注眼前的问题。</p><p>我们能够接受一顿饭100元，能接受一次出租车50元，不能接受为了效率提升支付15元。对此，我深以为然。以前也见过一些人，他们在吃喝玩乐上大手大脚，却不舍得购买网上的付费课程或正版软件，很大的一个原因是，<strong>他们觉得可以找到免费资源的东西，干嘛要花钱去买</strong>？但殊不知有时候，花费在寻找资源的时间，它的机会成本远大于花费在课程或软件上的钱。<strong>要想自己的时间变得值钱，首先你要认为自己的时间值钱。</strong></p><p>手信：广东话中不太贵重的小礼物。</p><p>邮差问题：用不重复的路径连接多点的问题</p><p>拜占庭式阴谋：因为拜占庭宫廷中经常充斥着皇室斗争,经常出现兵变,政变,阴谋,所以后世西方有一句谚语叫”拜占庭的阴谋”,形容政治上的勾心斗角</p><p>新的一年，愿你拥有最理想的生活，不问长远，只争朝夕。</p><p>在任何等级社会中，那些对自己没自信的人会通过虐待他们眼中的下等人来凸显自己的身份。正是由于这种原因，在美国社会中低层白人是对待黑人最残酷的群体。</p><p>与笨蛋辩论，最终你也会变成笨蛋。</p><p>许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是黄金和白银本质 只是一种交换媒介，留住他们并不会让一个国家变得富有。如果物质财富保持不变，金钱越多，唯一的结果就是物价越高。亚当斯密——《国富论》</p><p>黑眼圈只有长在熊猫身上那才叫可爱。</p><p>如果有2个选择尽量选择较难的那个。坐在家里看电视还是出去跑步？出去跑步吧。人们往往出于懒惰的缘故选择较为容易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果，这个方法只是迫使你接受这一点。</p><p>故智过万人者谓之英，千人者谓之俊，百人者谓之豪，十人者谓之杰。——《淮南子·泰族训》</p><p>官无常贵，民无终贱。——《墨子·尚贤》</p><h1 id="蒋勋细说红楼梦"><a href="#蒋勋细说红楼梦" class="headerlink" title="蒋勋细说红楼梦"></a>蒋勋细说红楼梦</h1><p>卓文君年青守寡，家里请了个家庭教师名唤司马相如，谁知道引狼入室。司马相如天天念诗《凤求凰》最后卓文君和司马相如私奔了。</p><p>中医理论认为人的身体是一个世界，有着自己的生态平衡，不同于“头痛医头，脚痛医脚”。五行相生相克。五脏对应五行。心主火，肺主金，肝主木，胃主土，肾主水。</p><p>常言“月盈则亏，水满则溢”，又道是“登高必跌重”。秦可卿在贾府极其兴盛的时候，便悟出了这个道理。</p><h1 id="王小波"><a href="#王小波" class="headerlink" title="王小波"></a>王小波</h1><p>只有当书很少的时代，人们才愿意发奋读书，无疑是对人性的一种嘲弄，但也是一个令人啼笑皆非的事实。在文化的沙漠里，人们渴得嗓子眼直冒烟，对于每一滴可以润喉的水都无比珍惜。</p><h1 id="村上春树-舞舞舞"><a href="#村上春树-舞舞舞" class="headerlink" title="村上春树-舞舞舞"></a>村上春树-舞舞舞</h1><p>当然算不上爱，可不单单是喜欢。</p><p>世界上本不存在误解，无非看法相左。</p><p>生活在高度发达的资本主义社会，浪费是最大的美德，政治家称之为扩大内需，我辈称之为挥霍，无非想法不同。不过同也罢不同也罢，反正我们所处的社会就是如此。</p><blockquote><p>我羡慕，但我不嫉妒。别人坐享其成的，是他们父辈努力的结果，我不过是走在他们父辈的道路上。精神上的富裕远比金钱的富裕重要的多。可金钱的现实意义又比精神富裕重要的多。有粮心中安，无钱难寸行。我还是愿意开着车，唱着歌；搂着自己心爱的女人；睡在属于自己温暖的被窝；有吃有喝；然后再去谈理想，谈豪车。</p></blockquote><h1 id="村上春树-1Q84"><a href="#村上春树-1Q84" class="headerlink" title="村上春树-1Q84"></a>村上春树-1Q84</h1><p>总有一天我会在什么地方偶然遇到他。是偶然的。我只想静静地，珍重地等待这个时刻。</p><p>这个世界上没有绝对的善，也没有绝对的恶。善恶并不是一成不变的东西，而是不断改变所处的场所和立场。一个善在下一个瞬间也许就转换成了恶，反之亦然。重要的是，要维持转换不停的善和恶的平衡，一旦向某一方过度倾斜，就会难以维持现实中的道德了。平衡本身就是善。</p><p>超过了一定年龄，所谓人生，无非是一个不断丧失的过程。对您的人生很宝贵的东西，会一个接一个，像梳子豁了齿一样，从您手中滑落下去。取而代之落入您手中的全是一些不值一提的伪劣品。体能，希望，美梦和理想，信念和意义，或是您所爱的人，这样一样接着一样，一个人接着一个人，从您身边悄然消逝。而且一旦消失，您就再也别想重新找回，连找个代替的东西都不容易。这可真够呛。有时简直就像拿刀子在身上割，苦不堪言。</p><p>所有江湖偶遇都是宿命相逢。</p><h1 id="钱为什么总是不够花"><a href="#钱为什么总是不够花" class="headerlink" title="钱为什么总是不够花"></a>钱为什么总是不够花</h1><blockquote><p>钱能解决生活中多半的难题，热爱能让人不畏惧所有难题。</p></blockquote><blockquote><p>工资是奴化人性的一种手段，当你接受工资的那一刻，你的思维就已经被打上了烙印，每个月固定的薪水也会让你有种小富即安的心态。</p></blockquote><p>美国2016年的社会福利支出，占到政府总支出的73%。这就是说，美国政府的大部分支出，都用在养老金、医疗保险、失业救济这些方面了。现在，大多数的美国穷人和老人，都仰仗政府的这笔支出活着。问题是，美国政府快要承担不起了。</p><p>政府的钱从哪里来？主要就是两个途径：债务和税收（包含强制保险）。现在，美国的政府债务已经超过了 GDP，很难再大规模举债了。而税收本质上是用下一代的钱，养活上一代的人。现在人口老龄化，不工作的老人越来越多，交税的人口比例在下降，因此税收也不够用。总之，美国福利制度快要不行了，需要大大地压缩支出。</p><p>全世界的发达国家，几乎都面临同样问题：福利社会太昂贵，政府提供不起全民的社会保险。日本最严重，已经把退休年龄提高到了70岁。你要活到70岁，政府才开始发给你养老金。</p><p>对于刚刚就业的年轻人来说，这就是现实，政府很难保障每个人的养老，政府发放的养老金几乎肯定靠不住。你必须靠自己，否则将来的养老一定会成大问题，会出现很多“人还没死，钱却花光”的情况。</p><p>由于各国政府对烟草的限制越来越多，而人类的焦虑也在不断增长，所以电子烟有很好的前景。长期来看，电子烟更便宜，而且以后技术发展了，可能可以达到无害且精确的神经刺激作用。</p><p>很多人即便工资涨了，依然存不下钱，该月光还是月光，该穷还是穷，只不过由显性贫困人口变成了隐性贫困人口，为什么会这样？因为人们的收入和幸福之间的关系并不是线性的，而是呈对数相关，有钱人也有烦恼。举例来说，你以前工资从5000涨到1万会让你兴奋半年，现在要从1万涨到2万才能给你同样的幸福感。这种类似英国电视剧《黑镜》里的情节有点天方夜谭，但并非不可想象。人类的拿手好戏就是把“天方夜谭”变成“习以为常”。在爱迪生和特斯拉的年代，人们跨越半个地球，来参观世界上第一座被电灯照耀的宫殿。而在一百年后的今天，城市的夜晚灯火喷涌，连流浪狗都不觉得这有什么了不起。</p><p>所有对于新名词的美好想象，都源自于无知。</p><h1 id="一些好玩的话"><a href="#一些好玩的话" class="headerlink" title="一些好玩的话"></a>一些好玩的话</h1><p>有钱，任性。<br>家有千金，行止由心。</p><p>心好累。<br>形若槁骸，心如死灰。</p><p>重要的事说三遍<br>一言难尽意，三令作五申。</p><p>人要是没有理想，和咸鱼有什么区别。<br>涸辙遗鲋，旦暮成枯；人而无志，与彼何殊。</p><p>丑的人都睡了，帅的人还醒着。<br>玉树立风前，驴骡正酣眠。</p><p>画个圈圈诅咒你<br>画地成圆，祝尔长眠。</p><p>每天都被自己帅到睡不着<br>玉树临风美少年，揽镜自顾夜不眠。</p><p>世界那么大，我想去看看<br>天高地阔，欲往观之</p><p>我读书少你不要骗我<br>君莫欺我不识字，人间安得有此事。</p><p>人与人之间最基本的信任呢<br>长恨人心不如水，等闲平地起波澜</p><blockquote><p>不要和女孩子聊吃的，除非你知道她喜欢吃什么；如果不熟悉也不要聊旅游，就简单聊一聊生活周边，然后找一找好玩的地方，到时候一起玩，顺带就能一起吃个饭，晚了顺带把人送回家，第一印象差不多就及格了</p></blockquote><p>《百年孤独》：你那么憎恨那些人，跟他们斗了那么久，最终却变得和他们一样，人世间没有任何理想值得以这样的沉沦为代价。不幸的孩子大抵都有三个愿望：不要嫁给爸爸那样的人，不要活的像妈妈，不要自己的孩子像自己小时候。但最终，也很难逃出这个怪圈，还是活成了妈妈的样子…</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 学习</title>
      <link href="/2018/04/15/docker-learn/"/>
      <url>/2018/04/15/docker-learn/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cgroups 是容器技术的基础，提供了对网络、计算、存储等各类资源的隔离，由 Google 贡献给 Linux 内核。</p></blockquote><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>Docker 可以理解为轻量级的虚拟机，它可以把应用程序放在独立的环境中运行。</p><p>最简单的 Docker 命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu <span class="built_in">echo</span> hello docker</span><br><span class="line">docker run nginx</span><br><span class="line"></span><br><span class="line">docker images <span class="comment"># 查看本地所有镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx 80端口映射到本地8080端口，下面的字符串表示容器 id</span></span><br><span class="line">docker run -p 8080:80 -d nginx </span><br><span class="line">06dcb2f35caa00ba89faae92e1fc42917ccafeecf363f3a057ea75aede66eb78</span><br><span class="line"></span><br><span class="line">docker ps <span class="comment"># 看看正在运行的容器</span></span><br><span class="line">docker <span class="built_in">cp</span> index.html 06dcb2f35caa://usr/share/nginx/html <span class="comment"># 将本地文件拷贝进docker对应目录</span></span><br><span class="line">docker stop 06dcb2f35caa </span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 在容器内所做的改动都是暂时的(不可变基础设施思想)</span></span><br><span class="line"><span class="comment"># 所以改动容器内的内容停止容器后再开启，网页不会发生变化。需要使用 commit 命令保存更改</span></span><br><span class="line"></span><br><span class="line">docker commit -m <span class="string">&quot;fun&quot;</span> 67791ea2402f1401c nginx-fun</span><br><span class="line">sha256:db3845fd93625e56c9234c2622a3ea89126732323534ff449871a027ad8330e8 <span class="comment"># 新产生的image id</span></span><br><span class="line"></span><br><span class="line">docker rmi db3845fd9362 <span class="comment"># 删除 image</span></span><br><span class="line"></span><br><span class="line">docker ps -a <span class="comment"># 查看所有运行过的images</span></span><br><span class="line">docker <span class="built_in">rm</span> 2e61f26e9f41 7bde03e544e8 <span class="comment"># 删除 container</span></span><br></pre></td></tr></table></figure><p>Dockerfile 中每一条 RUN、COPY、ADD 指令会创建一个新层，Volume 提供了独立于容器之外的持久化存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -v /usr/share/nginx/html nginx</span><br><span class="line">docker inspect nginx</span><br></pre></td></tr></table></figure><h2 id="Docker-持久化卷"><a href="#Docker-持久化卷" class="headerlink" title="Docker 持久化卷"></a>Docker 持久化卷</h2><p>在另一个终端执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty</span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/eceb621c68f44291c8f1cf9964c3425ed23ac95f726e67f7e551375df13671ee/_data <span class="comment"># docker inspect 的 Mounts -&gt; Source</span></span><br><span class="line"><span class="built_in">echo</span> aaa &gt;&gt; index.html</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx /bin/bash</span><br><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html/</span><br><span class="line"><span class="built_in">cat</span> index.html <span class="comment"># 发现末尾追加了aaa</span></span><br><span class="line"></span><br><span class="line">docker run -p 80:81 -d -v <span class="variable">$PWD</span>/html:/usr/share/nginx/html nginx <span class="comment">#将本地目录挂载到容器的对应目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> vol &amp;&amp; <span class="built_in">cd</span> vol &amp;&amp; <span class="built_in">mkdir</span> data</span><br><span class="line">docker create -v <span class="variable">$PWD</span>/data:/var/mydata --name data_container ubuntu <span class="comment"># 产生一个仅有数据的容器</span></span><br></pre></td></tr></table></figure><p>进入容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from data_container ubuntu /bin/bash</span><br><span class="line">root@5da2d3f8e973:/#mount | grep mydata</span><br><span class="line">root@5da2d3f8e973:/#osxfs on /var/mydata <span class="built_in">type</span> fuse.osxfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">root@5da2d3f8e973:/#<span class="built_in">echo</span> a &gt; /var/mydata/a.txt</span><br></pre></td></tr></table></figure><p>退出容器查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> data/a.txt</span><br></pre></td></tr></table></figure><p>仅有数据的容器可以做到被多个容器挂载从而做到数据共享。</p><p>Registry 本身是注册中心的意思，提供 SASS 服务，而非镜像的意思，目的是让大家共享镜像。</p><h1 id="容器技术的原理"><a href="#容器技术的原理" class="headerlink" title="容器技术的原理"></a>容器技术的原理</h1><p>本质上，容器是通过命名空间、cgroups 等技术实现资源隔离和限制，并拥有独立根目录（rootfs）的特殊进程。</p><h2 id="文件系统隔离"><a href="#文件系统隔离" class="headerlink" title="文件系统隔离"></a>文件系统隔离</h2><p><code>chroot</code> 命令允许管理员将进程的更目录锁定在特定位置，从而限制进程对 FS 的访问范围，它的隔离功能对安全性至关重要 —— 例如可以创建一个“蜜罐”，用于安全地运行和监控可疑代码和程序。由于它的隔离作用，chroot 环境也被形象地称为“jail”（监狱），从 chroot 逃逸的过程则被称为“越狱”。</p><h2 id="资源全方位隔离"><a href="#资源全方位隔离" class="headerlink" title="资源全方位隔离"></a>资源全方位隔离</h2><p>Linux 引入了 Mount,IPC,UTS,PID,Network,User,Cgroup,Time 命名空间可以隔离文件系统、进程间通信、主机名、进程号、网络资源、用户和用户组、cgroup 控制组，系统时间。实现了容器所需要的 6 项最基本的资源隔离机制。</p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>cgroups 是 Linux 内核用于隔离、分配并限制进程组使用资源配额的机制。例如，它可以控制进程的 CPU 占用时间、内存大小、磁盘 I&#x2F;O 速度等。groups 通过文件系统向用户暴露其操作接口。这些接口以文件和目录的形式组织在 <code>/sys/fs/cgroup</code> 路径下。</p><h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><p>云原生时代的操作系统。</p><ul><li>整个集群分为 2 类节点：控制平面的 Master 和数据平面的 Worker</li><li>Master 系统由多个分布式组件组成：包括 API Server,Scheduler,Controller Manager 和 Cloud Controller Manager</li><li>k8s 的最小运行单元是 Pod</li><li>Worker 节点上有 kubeletet 组件</li><li>基于 Raft 算法实现的分布式一致性 kv 存储 Etcd</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/k8s-arch.svg" alt="k8s架构图"></p><p>List-Watch 是 Kubernetes **控制循环（Control Loop）*<em>的核心机制，用于</em>高效监听资源变化*并保持集群状态一致性。其工作分为下面 2 步：</p><ol><li>List: 客户端首次获取资源的全量数据</li><li>Watch: 持续监听资源的增量变更（如 Pod 创建、删除、更新）</li></ol><p>Resync 机制：定期全量同步，防止遗漏事件（兜底策略）。</p><p>交互流程：</p><ul><li>客户端（如 kubelet、controller-manager） 通过 API Server 的 REST 接口发起请求。</li><li>API Server 返回当前资源状态（List），并保持一个长连接（HTTP长连接流式传输）推送后续变更（Watch）</li><li>资源变更的时候，API Server 将事件(ADDED&#x2F;MODIFIED&#x2F;DELETED) 通过 Watch 连接推送给客户端。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>Namespace：将集群的资源隔离。</li><li>Pod：Pod 是 k8s 的最小运行单元，由 1 个或多个容器组成。</li><li>Deployment：管理一组 Pod，提供副本控制、滚动升级等功能。</li><li>Service：访问容器组的入口。</li></ul><h2 id="超亲密容器组-Pod"><a href="#超亲密容器组-Pod" class="headerlink" title="超亲密容器组 Pod"></a>超亲密容器组 Pod</h2><p>容器之间原本通过命名空间和 cgroups 进行隔离，Pod 的设计目标是打破这种隔离，使 Pod 内的容器能够像进程组一样共享资源和数据。为实现这一点，k8s 引入了一个特殊容器 —— Infra Container。</p><p>Infra Container 是 Pod 内第一个启动的容器，体积非常小（约 300 KB）。它主要负责为 Pod 内的容器申请共享的 UTS、IPC 和网络等命名空间。Pod 内的其他容器通过 setns（Linux 系统调用，用于将进程加入指定命名空间）来共享 Infra Container 的命名空间。此外，Infra Container 也可以作为 init 进程，管理子进程和回收资源。</p><p>Infra Container 启动后，执行一个永远循环的 pause() 方法，因此又被称为“pause 容器”。</p><h2 id="Pod-是-k8s-的基本单位"><a href="#Pod-是-k8s-的基本单位" class="headerlink" title="Pod 是 k8s 的基本单位"></a>Pod 是 k8s 的基本单位</h2><p>k8s 引入了高层次的抽象来管理多个 Pod 实例。</p><ul><li>Deployment：无状态应用，支持滚动更新和扩缩容</li><li>StatefulSet：有状态应用，确保 Pods 的顺序和持久性</li><li>DaemonSet：确保每个节点上运行一个 Pod，常用于集群管理或监控</li><li>ReplicaSet：确保指定数量的 Pod 副本处于运行状态</li><li>Job&#x2F;CronJob：管理一次性任务或定期任务</li></ul><p>鉴于 Pod 的 IP 地址是动态分配的，k8s 引入了 Service 来提供稳定的网络访问入口并实现负载均衡。此外，Ingress 作为反向代理，根据定义的规则将流量路由至后端的 Service 或 Pod，从而实现基于域名或路径的细粒度路由和更复杂的流量管理。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/k8s-pod.svg" alt="K8s核心功能全景图"></p><h2 id="边车模式"><a href="#边车模式" class="headerlink" title="边车模式"></a>边车模式</h2><p>组合多种不同角色的容器，共享资源并统一调度编排，在 k8s 中是一种经典的容器设计模式 —— Sidecar。</p><p>在边车模式下，一个主容器（负责业务逻辑处理）与一个或多个边车容器共同运行在同一个 Pod 内。边车容器负责处理非业务逻辑的任务，如日志记录、监控、安全保障或数据同步。边车容器将这些职能从主业务容器中分离，使得开发更加高内聚、低耦合的软件变得更加容易。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/k8s-sidecar.svg" alt="容器 Sidecar 设计模式"></p><h2 id="资源调度和编排"><a href="#资源调度和编排" class="headerlink" title="资源调度和编排"></a>资源调度和编排</h2><p>和调度密切相关的就是 CPU 和内存了。像 CPU 这类的资源被称为<strong>可压缩资源</strong>，不足的时候，Pod 内的进程会变得卡顿，但是 Pod 不会因此被 kill。k8s 中的 CPU 是逻辑算力，1CPU&#x3D;1000m。像内存这样的资源是<strong>不可压缩资源</strong>，不足的时候可能会杀死 Pod 中的进程，甚至驱逐整个 Pod。</p><h1 id="服务网格（Service-Mesh）"><a href="#服务网格（Service-Mesh）" class="headerlink" title="服务网格（Service Mesh）"></a>服务网格（Service Mesh）</h1><p>服务网格是一个处理服务通讯的专门的基础设施层。它的职责是在由云原生应用组成服务的复杂拓扑结构下进行可靠的请求传送。在实践中，它是一组和应用服务部署在一起的轻量级的网络代理，对应用服务透明。代表为 Istio，主要解决服务间通信治理问题。</p><p>解决了类似 SpringCloud 这类微服务框架的 3 个痛点问题：</p><ol><li>技术门槛高</li><li>框架无法跨语言</li><li>框架升级困难</li></ol><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/service-mesh-arch.svg" alt="Istio架构"></p><p>缺点：</p><ul><li>网络延迟问题：服务网格通过 iptables 拦截服务间的请求，将原本的 A-&gt;B 通信改为 A-&gt;（iptables+Sidecar）-&gt; （iptables+Sidecar）-&gt;B，调用链的增加导致了额外的性能损耗。尽管边车代理通常只会增加毫秒级（个位数）的延迟，但对性能要求极高的业务来说，额外的延迟是放弃服务网格的主要原因</li><li>资源占用问题：边车代理作为一个独立的容器必然占用一定的系统资源，对于超大规模集群（如有数万个 Pod）来说，巨大的基数使边车代理占用资源总量变得相当可观。</li></ul><p>服务网格之所以备受推崇，关键不在于它提供了多少功能（这些功能传统 SDK 框架也有），而在于其将非业务逻辑从应用程序中剥离的设计思想。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="构建足够小的容器镜像"><a href="#构建足够小的容器镜像" class="headerlink" title="构建足够小的容器镜像"></a>构建足够小的容器镜像</h2><p>容器镜像的一大挑战是尽量减小镜像体积。较小的镜像在部署、故障转移和存储成本等方面具有显著优势。方法如下：</p><ol><li>选用精简的基础镜像：基础镜像应只包含运行应用程序所必需的最小系统环境和依赖。选择 Alpine Linux 这样的轻量级发行版作为基础镜像，镜像体积会比 CentOS 这样的大而全的基础镜像要小得多</li><li>使用多阶段构建镜像：在构建过程中，编译缓存、临时文件和工具等不必要的内容可能被包含在镜像中。通过多阶段构建，可以只打包编译后的可执行文件，从而得到更加精简的镜像</li></ol><p>下面的是一个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 1 阶段</span></span><br><span class="line"><span class="keyword">FROM</span> skillfir/alpine:gcc AS builder01</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://nginx.org/download/nginx-1.24.0.tar.gz -O nginx.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">tar -zxf nginx.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"><span class="built_in">rm</span> -f nginx.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"><span class="built_in">cd</span> /usr/src/nginx-1.24.0 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash"> ./configure --prefix=/app/nginx --sbin-path=/app/nginx/sbin/nginx &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  make &amp;&amp; make install</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 第 2 阶段 只打包最终可执行文件</span></span><br><span class="line"><span class="keyword">FROM</span> skillfir/alpine:glibc</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update &amp;&amp; apk upgrade &amp;&amp; apk add pcre openssl-dev pcre-dev zlib-dev </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder01 /app/nginx /app/nginx</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app/nginx</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>最终大小仅仅 20MB。</p><h2 id="加速容器镜像下载"><a href="#加速容器镜像下载" class="headerlink" title="加速容器镜像下载"></a>加速容器镜像下载</h2><p>当容器启动时，如果本地没有镜像文件，它将从远程仓库（Repository）下载。镜像下载效率受限于网络带宽和仓库服务质量，镜像越大，下载时间越长，容器启动也因此变慢。为了解决镜像拉取速度慢和带宽浪费的问题，阿里巴巴技术团队在 2018 年开源了 Dragonfly 项目。</p><p>Dragonfly 的工作原理：首先，Dragonfly 在多个节点上启动 Peer 服务（类似 P2P 节点）。当容器系统下载镜像时，下载请求通过 Peer 转发到 Scheduler（类似 P2P 调度器），Scheduler 判断该镜像是否为首次下载：</p><ul><li>首次下载：Scheduler 启动回源操作，从源服务器获取镜像文件，并将镜像文件切割成多个“块”（Piece）。每个块会缓存到不同节点，相关配置信息上报给 Scheduler，供后续调度决策使用</li><li>非首次下载：Scheduler 根据配置，生成一个包含所有镜像块的下载调度指令</li></ul><p>最终，Peer 根据调度策略从集群中的不同节点下载所有块，并将它们拼接成完整的镜像文件。Dragonfly 的镜像下载加速流程与 P2P 下载加速非常相似，二者都是通过分布式节点和智能调度来加速大文件的传输与重组。</p><h2 id="加速容器镜像启动"><a href="#加速容器镜像启动" class="headerlink" title="加速容器镜像启动"></a>加速容器镜像启动</h2><p>容器镜像的大小直接影响启动时间，一些大型软件的镜像可能超过数 GB。例如，机器学习框架 TensorFlow 的镜像大小为 1.83 GB，冷启动时至少需要 3 分钟。大型镜像不仅启动缓慢、镜像内的文件往往未被充分利用（业内研究表明，通常镜像中只有 6% 的内容被实际使用）</p><p>2020 年，阿里巴巴技术团队发布了 Nydus 项目，它将镜像层的数据（blobs）与元数据（bootstrap）分离，容器第一次启动时，首先拉取元数据，再按需拉取 blobs 数据。相较于拉取整个镜像层，Nydus 下载的数据量大大减少。值得一提的是，Nydus 还使用 FUSE 技术（Filesystem in Userspace，用户态文件系统）重构文件系统，用户几乎无需任何特殊配置（感知不到 Nydus 的存在），即可按需从远程镜像中心拉取数据，加速容器镜像启动。</p><p>Nydus 将常见应用镜像的启动时间从几分钟缩短至仅几秒钟。</p><p>上述优化措施对于大规模集群，或对扩容延迟有严格要求的场景（如大促扩容、游戏服务器扩容等）来说，不仅能显著降低容器启动时间，还能大幅节省网络和存储成本。值得一提的是，这些技术调整对业务工程师完全透明，不会影响原有的业务流程。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基础</title>
      <link href="/2018/04/14/linux-basic/"/>
      <url>/2018/04/14/linux-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="硬盘分区、格式化和挂载"><a href="#硬盘分区、格式化和挂载" class="headerlink" title="硬盘分区、格式化和挂载"></a>硬盘分区、格式化和挂载</h1><h2 id="MBR分区模式"><a href="#MBR分区模式" class="headerlink" title="MBR分区模式"></a>MBR分区模式</h2><blockquote><p>主分区不能超过4个，拓展分区最多只能有1个，单个分区最大容量为2TB。</p></blockquote><p>服务器添加硬盘后会显示在<code>/dev</code>目录下，但是我们此时还不能使用这个硬盘，必须对其进行分区格式化和挂载，硬盘分区使用<code>fdisk</code>（MBR分区工具）。我们为虚拟机添加了1个8G的硬盘,使用<code>fdisk -l</code>看到<code>/dev/sdb</code>上并没有可用的分区表，使用<code>fdisk /dev/sdb</code>即可进入分区模式(注意：如果添加的分区是拓展分区,一个硬盘上拓展分区的数量最多只能有一个，拓展分区不能直接使用，必须添加逻辑分区,方法是进入到分区模式，然后按n，按照提示为拓展分区添加逻辑分区)。因为逻辑分区在拓展分区内部，所以如果删除拓展分区，它下面的逻辑分区将一同删除。<em>拓展分区的出现本身就是为了解决MBR中只能有4个主分区的问题。</em></p><h2 id="GPT分区模式"><a href="#GPT分区模式" class="headerlink" title="GPT分区模式"></a>GPT分区模式</h2><blockquote><p>主分区最多128个，分区的类型概念模糊了，单个分区的容量几乎没有限制(18EB,1EB&#x3D;1024PB,1PB&#x3D;1024TB)，GPT的主分区中不太适合安装X86架构的系统。</p></blockquote><p>GPT分区使用<code>parted</code>工具(MBR和GPT都支持)。</p><blockquote><p>固态硬盘中4K对其非常重要，对硬盘的性能会产生很大影响，通常将一块硬盘的起始的0~1MB的空间牺牲掉用来做4K对其。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ parted</span><br><span class="line">$ <span class="keyword">select</span> /dev/sdc <span class="comment"># 选择我们新添加的硬盘</span></span><br><span class="line">$ mklabel gpt <span class="comment"># 指定分区类型为gpt，还有一种是msdos表示MBR分区</span></span><br><span class="line">$ mkpart <span class="comment"># 按照提示进下下一步操作即可，注意start和end表示从第XXXMB开始到XXXMB结束</span></span><br><span class="line">$ mkpart part2 2000 3000 <span class="comment"># 分区名 上一个分区的结束位置 本分区的结束位置</span></span><br><span class="line">$ <span class="built_in">print</span> <span class="comment"># 第一列为分区编号</span></span><br><span class="line">$ <span class="built_in">rm</span> 3 <span class="comment"># 删除第3个分区</span></span><br><span class="line">$ unit GB <span class="comment"># 使用GB为单位指定分区的开始和结束位置</span></span><br></pre></td></tr></table></figure><p><em>fdisk工具需要输入w将分区信息更新写入，而gpt工具只需要分好之后退出即可</em></p><h2 id="分区格式化"><a href="#分区格式化" class="headerlink" title="分区格式化"></a>分区格式化</h2><p>分区格式化使用<code>mkfs</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkfs.ext4 /dev/sdb1 <span class="comment"># 将/dev/sdb1格式化为ext4</span></span><br><span class="line">$ mkfs -t ext3 /dev/sdb2</span><br></pre></td></tr></table></figure><h2 id="分区挂载"><a href="#分区挂载" class="headerlink" title="分区挂载"></a>分区挂载</h2><p>分区默认挂载目录是<code>/mnt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /mnt/test</span><br><span class="line">$ mount /dev/sdb1 /mnt/test</span><br><span class="line">$ umount /mnt/test <span class="comment"># 或者umount /dev/sdb1</span></span><br></pre></td></tr></table></figure><blockquote><p>通过mount命令挂载的分区在重启后会失效，需要将其写入到<code>/etc/fstab</code>中可以重启自动挂载。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi + /etc/fstab <span class="comment"># + 表示定位到最后一行,添加这样的一行即可</span></span><br><span class="line">$ /dev/sdb1       /mnt/test       ext3    defaults        0       0</span><br></pre></td></tr></table></figure><h2 id="为硬盘添加swap分区"><a href="#为硬盘添加swap分区" class="headerlink" title="为硬盘添加swap分区"></a>为硬盘添加swap分区</h2><p>首先建立普通分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk /dev/sdb</span><br><span class="line">$ p</span><br><span class="line">$ t <span class="comment"># 选择分区编号，输入6（最后一个分区）</span></span><br><span class="line">$ <span class="comment"># 系统提示改变16进制编码（输入L可看到全部编码，可以发现83为普通linux分区,82为交换分区，输入82,w保存退出）</span></span><br><span class="line">$ mkswap /dev/sdb6 <span class="comment"># 格式化交换分区</span></span><br><span class="line">$ swapon /dev/sdb6 <span class="comment"># 启用交换分区</span></span><br></pre></td></tr></table></figure><p>交换分区启用完成后可以使用<code>free</code>命令查看加载状况，还可以使用<code>swapoff /dev/sdb6</code>停用交换分区。</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">du</span> -h -s /tmp/ <span class="comment"># 统计/tmp目录大小</span></span><br><span class="line">$ <span class="built_in">du</span> -sh *.js <span class="comment"># 统计当前目录下js文件大小</span></span><br></pre></td></tr></table></figure><h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传公钥到服务器</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub | ssh devel@192.168.3.118 <span class="string">&#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sed-and-awk</title>
      <link href="/2018/04/14/sed-and-awk/"/>
      <url>/2018/04/14/sed-and-awk/</url>
      
        <content type="html"><![CDATA[<p>提取日志字段，实现类似<code>grep</code>的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/CONNECTED/p&#x27;</span> shuffleless-out.log</span><br></pre></td></tr></table></figure><p>以&#x2F;etc&#x2F;passwd文件为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">gopher:x:13:30:gopher:/var/gopher:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin</span><br><span class="line">saslauth:x:499:76:Saslauthd user:/var/empty/saslauth:/sbin/nologin</span><br><span class="line">postfix:x:89:89::/var/spool/postfix:/sbin/nologin</span><br><span class="line">sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">www:x:500:500::/home/www:/sbin/nologin</span><br><span class="line">mysql:x:501:501::/home/mysql:/sbin/nologin</span><br><span class="line">pusher:x:502:502::/home/pusher:/bin/bash</span><br><span class="line">HuangDongcong:x:503:503::/home/HuangDongcong:/bin/bash</span><br><span class="line">devel:x:504:504::/home/devel:/bin/bash</span><br><span class="line">ZhangPeng:x:505:505::/home/ZhangPeng:/bin/bash</span><br><span class="line">phper:x:506:506::/home/phper:/bin/bash</span><br><span class="line">SuperAdmin:x:507:507::/home/SuperAdmin:/bin/bash</span><br><span class="line">tcpdump:x:72:72::/:/sbin/nologin</span><br><span class="line">ntp:x:38:38::/etc/ntp:/sbin/nologin</span><br><span class="line">rsync_key:x:508:508::/home/rsync_key:/bin/bash</span><br><span class="line">huangdongcong:x:509:509::/home/huangdongcong:/bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;[^0-9]&#x27;</span> passwd <span class="comment"># 取出所有的非数字字符，取反操作</span></span><br><span class="line">grep <span class="string">&#x27;^$&#x27;</span> passwd <span class="comment"># 取空行</span></span><br><span class="line">grep <span class="string">&#x27;\bx\b&#x27;</span> passwd <span class="comment"># 匹配单词边界，仅匹配单独的x，不必配 axb中的x</span></span><br><span class="line"><span class="comment"># grep中的?和+表示重复的时候需要转义 \+ \?</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈函数式编程</title>
      <link href="/2017/05/05/function-programing/"/>
      <url>/2017/05/05/function-programing/</url>
      
        <content type="html"><![CDATA[<p>我们可以将匿名函数(anonymous function)作为参数，这种操作具有普遍意义。</p><h1 id="map实现"><a href="#map实现" class="headerlink" title="map实现"></a>map实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">arr,fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) ret.<span class="title function_">push</span>(<span class="title function_">fn</span>(item));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的操作对数组中的每个元素进行某种变换。</p><p>另一种常见的事情是对数组中的每个元素进行累加。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>;i++) ret += arr[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">join</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>;i++) ret += arr[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum和join函数很像，我们可以将它们抽象一下，把具有共性的代码写成一个通用的函数，将数组的元素合并成一个单一的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">fn,arr,init</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> s = init;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>;i++) s = <span class="title function_">fn</span>(s,arr[i]);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从而上面的sum和join函数可以变成下面的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; <span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a + b,arr,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">join</span> = arr =&gt; <span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a + b,arr,<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>让我们回过头来看map函数，当你需要对数组中的每一个元素依次进行处理时，实际情况可能是到底按照哪一种次序进行遍历实际上是无关紧要的：无论从头到尾，还是从尾到头都可以得到相同的结果。如果我们有2个CPU可以用，我们可以写一些代码，使得每个CPU遍历一般的元素，于是一瞬间map函数的运行效率就快了一倍。同理，我们可以将计算任务分配到多台服务器上。</p><p>如果我们将map和reduce函数看做任何人都可以调用并且确实是每个人都能用的函数，只需要找到一个超级天才，让他写出能够在全世界庞大的服务器阵列上分布式运行map和reduce函数，所有以前在单机上能够进行的循环操作(loop)的代码依然能够使用，并且速度提高了几十亿倍，同样的代码可以在很短的时间内处理完巨型问题！</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> 软件随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈第三方登陆</title>
      <link href="/2017/01/17/oauth2/"/>
      <url>/2017/01/17/oauth2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>水面的涟漪虽然已经消散了，但是仍然会有人记得风曾经吹过。</p></blockquote><blockquote><p>人无完人，何须自谦？世界之大，几个圣贤？脚下之路，何必回迁？</p></blockquote><blockquote><p>The furthest distance in the world is not between life and death. But when I stand in front of you. Yet you don’t know that I love you.</p></blockquote><blockquote><p>路：足各相汇，意行者殊，则前途相异。然行者固，前路亦有变，此乃人心之向也。<br>前途不可知并非前途不可造。万人愿，动天于心诚；万人行，生途于脚下。</p></blockquote><h1 id="微信登陆"><a href="#微信登陆" class="headerlink" title="微信登陆"></a>微信登陆</h1><ul><li>没有自己的账号体系，直接拉取微信用户信息进行网站登陆。</li><li>有自己的账号体系，授权成功后需要绑定自己的账号。</li></ul><p><a href="https://mp.weixin.qq.com/">微信公众平台</a>和<a href="https://open.weixin.qq.com/">微信开放平台</a>分别对应移动端和PC端，通过这两个接口进行授权登陆拿到的openid是不一样的。这样导致的问题就是在手机端通过微信公众平台绑定的用户信息和PC端通过开放平台绑定的用户是<em>互斥的</em>。解决这个问题可以在微信开放平台中绑定微信公众号。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 中的一些惯用法</title>
      <link href="/2016/12/28/awesome-java/"/>
      <url>/2016/12/28/awesome-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鸟宿池边树，僧敲月下门。</p></blockquote><p>java7中的try-resource语法语义自动关闭InputStream和JDBC Connection，就不需要在finally中close了。</p><h1 id="java中的锁是如何实现的"><a href="#java中的锁是如何实现的" class="headerlink" title="java中的锁是如何实现的"></a>java中的锁是如何实现的</h1><p>在java里锁是通过cas把当前线程id刷新到对象的头信息里，在获取锁时会去头信息里拿这个信息，如果没有则会cas刷新进去，刷新成功就获取到锁；刷新失败就表明有别的线程也在尝试刷新这个信息。</p><p>在操作系统层面有pv操作保证原子性，而pv操作也是利用cpu中原语指令，在获取锁时保证不会被别的指令打断（或被重排序）。</p><h2 id="白名单问题"><a href="#白名单问题" class="headerlink" title="白名单问题"></a>白名单问题</h2><blockquote><p>java中1&#x2F;0抛出算术异常，而1&#x2F;0.0结果为无穷大。</p></blockquote><p>一家信用卡公司中的账号是成千上万的，我们将用户账号保存在一个文件中，这个文件就是白名单。认为给定一个账户，我们需要检查该账号是否在白名单中。一个程序可用往往是不够的，如果没有<em>二分查找或者归并排序</em>这样的高效算法解决此类问题是不可能的。</p><h2 id="关于除法运算"><a href="#关于除法运算" class="headerlink" title="关于除法运算"></a>关于除法运算</h2><p>无论正负，<code>a / b</code>的<em>商会向0取整</em>。而余数满足这个公式：<code>(a/b) * b + a % b == a</code>。例如-14 &#x2F; 3 &#x3D;&#x3D; -4,-14 % 3 &#x3D;&#x3D; -2;14 &#x2F; -3 &#x3D;&#x3D; -4,14 % -3 &#x3D;&#x3D; 2.</p><h2 id="为什么数组索引从0开始"><a href="#为什么数组索引从0开始" class="headerlink" title="为什么数组索引从0开始"></a>为什么数组索引从0开始</h2><blockquote><p>这个习惯来源于机器语言。那时计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将初始索引设置为1要么会浪费数组的第一个元素的空间，要么会花费额外的时间将索引减1。</p></blockquote><h2 id="java中对象数组为什么保存的是引用"><a href="#java中对象数组为什么保存的是引用" class="headerlink" title="java中对象数组为什么保存的是引用"></a>java中对象数组为什么保存的是引用</h2><p>如果对象非常大，那么移动它们只需要操作引用本身而非对象本身，这就会大大提高效率；反之如果对象非常小，每次获取信息的时候都需要通过引用反而会降低效率。</p><h2 id="共变数组和类型擦除"><a href="#共变数组和类型擦除" class="headerlink" title="共变数组和类型擦除"></a>共变数组和类型擦除</h2><p>数组的协变性(covariant)是指：如果类Base是类Sub的基类，那么<code>Base[]</code>就是<code>Sub[]</code>的基类。而泛型是不可变的(invariant)，List<Base>不会是List<Sub>的基类，更不会是它的子类。</p><p>数组的协变性可能会导致一些错误，比如下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>]; </span><br><span class="line">array[<span class="number">0</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>它是可以编译通过的，因为数组是协变的，<code>Object[]</code>类型的引用可以指向一个<code>String[]</code>类型的对象，但是运行的时候是会报出如下异常的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.ArrayStoreException: java.lang.Integer </span><br></pre></td></tr></table></figure><p>但是对于泛型就不会出现这种情况了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); </span><br><span class="line">list.add(<span class="number">10</span>); </span><br></pre></td></tr></table></figure><p>以上代码在编译的时候都不能通过！</p><p>数组是具体化的(reified)，而泛型在运行时是被擦除的(erasure)。数组是在运行时才去判断数组元素的类型约束，而泛型正好相反，在运行时，泛型的类型信息是会被擦除的，只有编译的时候才会对类型进行强化。所以上面的例子中，数组的方法会在运行时报出ArrayStoreException，而泛型根本无法通过编译。 </p><p>虽然将集合看作是数组的抽象会有所帮助，但是数组还有一些集合不具备的特殊性质。</p><p>Java 语言中的数组是协变的（covariant），也就是说，如果 Integer扩展了 Number（事实也是如此），那么不仅 Integer是 Number，而且 Integer[]也是 Number[]，在要求 Number[]的地方完全可以传递或者赋予 Integer[]。（更正式地说，如果 Number是 Integer的超类型，那么 Number[]也是 Integer[]的超类型）。</p><p>您也许认为这一原理同样适用于泛型类型 —— List<Number>是 List<Integer>的超类型，那么可以在需要 List<Number>的地方传递 List<Integer>。不幸的是，情况并非如此。</p><p>不允许这样做有一个很充分的理由：</p><p>这样做将破坏要提供的类型安全泛型。如果能够将 List<Integer>赋给 List<Number>。那么下面的代码就允许将非 Integer的内容放入 List<Integer></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">List&lt;Number&gt; ln = li; <span class="comment">// illegal</span></span><br><span class="line">ln.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">3.1415</span>));</span><br></pre></td></tr></table></figure><p>因为 ln是 List<Number>，所以向其添加 Float似乎是完全合法的。但是如果 ln是 li的别名，那么这就破坏了蕴含在 li定义中的类型安全承诺 —— 它是一个整数列表，这就是泛型类型不能协变的原因。</p><blockquote><p>java中Boolean值用一个字节表示（而不是位），因为计算机访问内存都是以字节为单位。</p></blockquote><h1 id="长度可变的数组"><a href="#长度可变的数组" class="headerlink" title="长度可变的数组"></a>长度可变的数组</h1><p>利用可变参和泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] a = of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        String[] b = of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种用法在guava中比较常见</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] of(T... values) &#123;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h2><ul><li>日志收集中心</li><li>消息系统</li><li>网站活性追踪</li><li>流处理</li><li>事件源</li></ul><h2 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h2><ul><li>线程、堆分配、gc情况：visualvm</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Bind搭建智能DNS</title>
      <link href="/2016/12/27/dns-bind/"/>
      <url>/2016/12/27/dns-bind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Bind是加州大学伯克利分校开发维护的开源、稳定的DNS服务。</p></blockquote><p><code>www.baidu.com = www.baidu.com.</code>最后的一个<code>.</code>表示根域，<code>.com</code>是一级域,<code>baidu.com</code>是二级域。</p><h1 id="DNS解析记录分类"><a href="#DNS解析记录分类" class="headerlink" title="DNS解析记录分类"></a>DNS解析记录分类</h1><p>常见的有A记录，CNAME，MX和NS，参见<a href="http://linux.vbird.org/linux_server/0350dns.php#DNS_master_rr">鸟哥的Linux私房菜</a>。</p><h1 id="Bind安装和配置"><a href="#Bind安装和配置" class="headerlink" title="Bind安装和配置"></a>Bind安装和配置</h1><h2 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h2><blockquote><p>下面的例子中，DNS服务器为192.168.1.128。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y <span class="built_in">bind</span> bind-chroot bind-utils</span><br><span class="line">$ rpm -qa | grep <span class="built_in">bind</span></span><br><span class="line">$ rpm -ql <span class="built_in">bind</span> | more <span class="comment"># 查看具体安装了哪些内容</span></span><br><span class="line">$ service named start <span class="comment"># 启动DNS</span></span><br><span class="line">$ <span class="built_in">cp</span> /etc/named.conf /etc/named.conf.default <span class="comment"># 备份配置文件</span></span><br></pre></td></tr></table></figure><p>配置<code>/etc/named.conf</code>为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">       directory <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;baidu.com&quot;</span> &#123;</span><br><span class="line">       <span class="built_in">type</span> master;</span><br><span class="line">       file <span class="string">&quot;baidu.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建文件<code>/var/named/baidu.com.zone</code>，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 7200</span><br><span class="line">baidu.com. IN SOA baidu.com. consoles.baidu.com. (222 1H 15M 1W 1D)</span><br><span class="line">baidu.com. IN NS dns1.baidu.com.</span><br><span class="line">dns1.baidu.com. IN A 192.168.1.128</span><br><span class="line">www.baidu.com. IN A 2.2.2.2</span><br></pre></td></tr></table></figure><p>baidu.com.zone可以简写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 7200</span><br><span class="line">@ IN SOA baidu.com. consoles.baidu.com. (222 1H 15M 1W 1D)</span><br><span class="line">baidu.com. IN NS dns1.baidu.com.</span><br><span class="line">dns1 IN A 192.168.1.128</span><br><span class="line">www IN A 14.215.177.38</span><br></pre></td></tr></table></figure><blockquote><p>小提示：如果服务启动失败，可以使用<code>tail -f /var/log/messages</code>查看日志。</p></blockquote><p>第一行的consoles.baidu.com.其实是管理员邮箱<a href="mailto:&#x63;&#x6f;&#x6e;&#x73;&#111;&#108;&#101;&#115;&#64;&#98;&#x61;&#105;&#100;&#117;&#46;&#x63;&#111;&#109;">consoles@baidu.com</a>.（@是DNS的保留字，表示当前域名，即baidu.com.二级域名）。配置完成后<code>service named restart</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ dig @192.168.1.128 www.baidu.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; @192.168.1.128 www.baidu.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 3495</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.baidu.com.IN     A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># www.baidu.com的权威DNS解析结果为14.215.177.38</span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.baidu.com. 7200   IN     A      14.215.177.38</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># baidu.com 二级域名ns到了dns1.baidu.com</span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">baidu.com.     7200   IN     NS     dns1.baidu.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># dns1.baidu.com找到了192.168.1.128</span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">dns1.baidu.com.7200   IN     A      192.168.1.128</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 3 msec</span></span><br><span class="line"><span class="string">;; SERVER: 192.168.1.128#53(192.168.1.128)</span></span><br><span class="line"><span class="string">;; WHEN: Wed Dec 28 21:44:02 2016</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 82</span></span><br></pre></td></tr></table></figure><h2 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h2><p>CNAME，别名记录，多个域名指向同一个ip。上面的A记录中<a href="http://www.baidu.com解析到了14.215.177.38，我们要做的是将`baidu.admin.com`解析到14.215.177.38。">www.baidu.com解析到了14.215.177.38，我们要做的是将`baidu.admin.com`解析到14.215.177.38。</a></p><p>&#x2F;etc&#x2F;named.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">        directory <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;baidu.com&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;baidu.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">zone <span class="string">&quot;admin.com&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;admin.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&#x2F;var&#x2F;named&#x2F;admin.com.zone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$TTL 7200</span><br><span class="line">admin.com. IN SOA admin.com. admin.gmail.com. (4012100 1H 15M 1W 1D)</span><br><span class="line">admin.com. IN NS dns1.admin.com.</span><br><span class="line">dns1.admin.com. IN A 192.168.1.128</span><br><span class="line">baidu.admin.com. IN CNAME www.baidu.com.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 baidu.admin.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-38.el7_3 &lt;&lt;&gt;&gt; @127.0.0.1 baidu.admin.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 28830</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 1, ADDITIONAL: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;baidu.admin.com.      IN     A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string"># baidu.admin.com. CNAME 到了www.baidu.com.</span></span><br><span class="line"><span class="string">baidu.admin.com.       7200   IN     CNAME  www.baidu.com.</span></span><br><span class="line"><span class="string">www.baidu.com. 7200   IN     A      14.215.177.38</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">baidu.com.     7200   IN     NS     dns1.baidu.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">dns1.baidu.com.7200   IN     A      192.168.1.128</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 0 msec</span></span><br><span class="line"><span class="string">;; SERVER: 127.0.0.1#53(127.0.0.1)</span></span><br><span class="line"><span class="string">;; WHEN: 四 12月 29 06:13:42 CST 2016</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 119</span></span><br></pre></td></tr></table></figure><p>我们可以修改宿主机的dns为192.168.1.128，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup baidu.admin.com</span><br><span class="line">Server:192.168.1.128</span><br><span class="line">Address:       192.168.1.128#53</span><br><span class="line"></span><br><span class="line">baidu.admin.comcanonical name = www.baidu.com.</span><br><span class="line">Name:  www.baidu.com</span><br><span class="line">Address: 14.215.177.38</span><br></pre></td></tr></table></figure><h2 id="正向解析和反向解析"><a href="#正向解析和反向解析" class="headerlink" title="正向解析和反向解析"></a>正向解析和反向解析</h2><p>正向解析是通过域名查找IP，例如A记录；反向解析是使用IP查找域名，例如PTR记录。反向解析多用于邮件服务器，通常情况下并不需要使用。</p><h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>&#x2F;var&#x2F;named&#x2F;baidu.com.zone</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 7200</span><br><span class="line">@ IN SOA baidu.com. consoles.baidu.com. (222 1H 15M 1W 1D)</span><br><span class="line">baidu.com. IN NS dns1.baidu.com.</span><br><span class="line">dns1 IN A 192.168.1.128</span><br><span class="line">www IN A 14.215.177.38</span><br><span class="line">@ IN MX 10 mail</span><br><span class="line">mail IN A 192.168.1.165</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 mail.baidu.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-38.el7_3 &lt;&lt;&gt;&gt; @127.0.0.1 mail.baidu.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 15666</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;mail.baidu.com.       IN     A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">mail.baidu.com.7200   IN     A      192.168.1.165</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">baidu.com.     7200   IN     NS     dns1.baidu.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">dns1.baidu.com.7200   IN     A      192.168.1.128</span></span><br></pre></td></tr></table></figure><p>配置反向解析的域，&#x2F;etc&#x2F;named.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">        directory <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;baidu.com&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;baidu.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">zone <span class="string">&quot;admin.com&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;admin.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">zone <span class="string">&quot;1.168.192.in-addr.arpa&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">type</span> master;</span><br><span class="line">        file <span class="string">&quot;192.168.1.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意上面配置的时候使用ip倒置。</p></blockquote><p>192.168.1.zone配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$TTL</span> 3600</span><br><span class="line">@ IN SOA 1.168.192.in-addr.arpa. consoles.gmail.com. (2014012200 1H 15M 1W 1D)</span><br><span class="line">@ IN NS dns1.baidu.com.</span><br><span class="line">128 IN PTR dns1.baidu.com.</span><br><span class="line">165 IN PTR mail.baidu.com.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ dig -x 192.168.1.165 @127.0.0.1 <span class="comment"># 测试反向解析</span></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-38.el7_3 &lt;&lt;&gt;&gt; -x 192.168.1.165 @127.0.0.1</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 27561</span></span><br><span class="line"><span class="string">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;165.1.168.192.in-addr.arpa.   IN     PTR</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">165.1.168.192.in-addr.arpa. 3600 IN    PTR    mail.baidu.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">1.168.192.in-addr.arpa.3600   IN     NS     dns1.baidu.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">dns1.baidu.com.7200   IN     A      192.168.1.128</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 0 msec</span></span><br><span class="line"><span class="string">;; SERVER: 127.0.0.1#53(127.0.0.1)</span></span><br><span class="line"><span class="string">;; WHEN: 四 12月 29 06:49:06 CST 2016</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 118</span></span><br></pre></td></tr></table></figure><h1 id="DNS客户端工具"><a href="#DNS客户端工具" class="headerlink" title="DNS客户端工具"></a>DNS客户端工具</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ host -t SOA baidu.com</span><br><span class="line">$ host -t NS baidu.com</span><br><span class="line">$ host -t A baidu.com</span><br></pre></td></tr></table></figure><p>nslookup支持交互模式.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  named nslookup</span><br><span class="line">server 127.0.0.1</span><br><span class="line">Default server: 127.0.0.1</span><br><span class="line">Address: 127.0.0.1#53</span><br><span class="line">&gt; www.baidu.com</span><br><span class="line">Server:127.0.0.1</span><br><span class="line">Address:       127.0.0.1#53</span><br><span class="line"></span><br><span class="line">Name:  www.baidu.com</span><br><span class="line">Address: 14.215.177.38</span><br><span class="line">&gt; <span class="built_in">set</span> q=a</span><br><span class="line">&gt; baidu.com</span><br><span class="line">Server:114.114.114.114</span><br><span class="line">Address:       114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:  baidu.com</span><br><span class="line">Address: 220.181.57.217</span><br><span class="line">Name:  baidu.com</span><br><span class="line">Address: 111.13.101.208</span><br><span class="line">Name:  baidu.com</span><br><span class="line">Address: 123.125.114.144</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig -t a baidu.com @127.0.0.1 <span class="comment"># 使用127.0.0.1这个DNS服务器</span></span><br></pre></td></tr></table></figure><h1 id="Bind负载均衡"><a href="#Bind负载均衡" class="headerlink" title="Bind负载均衡"></a>Bind负载均衡</h1><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/dns-lookup.png" alt="递归查询和迭代查询"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cat</span> /etc/named.conf</span><br><span class="line">options &#123;</span><br><span class="line">       directory <span class="string">&quot;/var/named&quot;</span>;</span><br><span class="line">        <span class="comment"># recursion no;   默认为yes，允许递归查询</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;baidu.com&quot;</span> &#123;</span><br><span class="line">       <span class="built_in">type</span> master;</span><br><span class="line">       file <span class="string">&quot;baidu.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">zone <span class="string">&quot;admin.com&quot;</span> &#123;</span><br><span class="line">       <span class="built_in">type</span> master;</span><br><span class="line">       file <span class="string">&quot;admin.com.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">zone <span class="string">&quot;1.168.192.in-addr.arpa&quot;</span> &#123;</span><br><span class="line">       <span class="built_in">type</span> master;</span><br><span class="line">       file <span class="string">&quot;192.168.1.zone&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">➜  ~ dig @127.0.0.1 www.qq.com <span class="comment"># 本地没有配置www.qq.com的解析，发起递归查询</span></span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-38.el7_3 &lt;&lt;&gt;&gt; @127.0.0.1 www.qq.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- <span class="string">opcode: QUERY, status: NOERROR, id: 6921</span></span><br><span class="line"><span class="string">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 2, ADDITIONAL: 4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">; EDNS: version: 0, flags:; udp: 4096</span></span><br><span class="line"><span class="string">;; QUESTION SECTION:</span></span><br><span class="line"><span class="string">;www.qq.com.   IN     A</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ANSWER SECTION:</span></span><br><span class="line"><span class="string">www.qq.com.    300    IN     A      59.37.96.63</span></span><br><span class="line"><span class="string">www.qq.com.    300    IN     A      14.17.32.211</span></span><br><span class="line"><span class="string">www.qq.com.    300    IN     A      14.17.42.40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; AUTHORITY SECTION:</span></span><br><span class="line"><span class="string">www.qq.com.    86400  IN     NS     ns-tel2.qq.com.</span></span><br><span class="line"><span class="string">www.qq.com.    86400  IN     NS     ns-tel1.qq.com.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; ADDITIONAL SECTION:</span></span><br><span class="line"><span class="string">ns-tel1.qq.com.600    IN     A      183.2.186.153</span></span><br><span class="line"><span class="string">ns-tel1.qq.com.600    IN     A      182.140.184.140</span></span><br><span class="line"><span class="string">ns-tel2.qq.com.3600   IN     A      183.61.47.15</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">;; Query time: 4975 msec</span></span><br><span class="line"><span class="string">;; SERVER: 127.0.0.1#53(127.0.0.1)</span></span><br><span class="line"><span class="string">;; WHEN: 五 12月 30 05:19:53 CST 2016</span></span><br><span class="line"><span class="string">;; MSG SIZE  rcvd: 179</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 将options中的recursion设置为no再次发起对www.qq.com的dns查询</span></span><br><span class="line"><span class="string">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-38.el7_3 &lt;&lt;&gt;&gt; @127.0.0.1 www.qq.com</span></span><br><span class="line"><span class="string">; (1 server found)</span></span><br><span class="line"><span class="string">;; global options: +cmd</span></span><br><span class="line"><span class="string">;; Got answer:</span></span><br><span class="line"><span class="string">;; -&gt;&gt;HEADER&lt;&lt;- opcode</span>: QUERY, status: REFUSED, <span class="built_in">id</span>: 13654</span><br><span class="line">;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available <span class="comment"># 递归请求不可用</span></span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.qq.com.   IN     A</span><br><span class="line"></span><br><span class="line">;; Query <span class="keyword">time</span>: 2 msec</span><br><span class="line">;; SERVER: 127.0.0.1#53(127.0.0.1)</span><br><span class="line">;; WHEN: 五 12月 30 05:26:37 CST 2016</span><br><span class="line">;; MSG SIZE  rcvd: 39</span><br></pre></td></tr></table></figure><h2 id="子域授权"><a href="#子域授权" class="headerlink" title="子域授权"></a>子域授权</h2><p>A服务负责(baidu.com)的域名解析，授权B服务器子域(test.baidu.com)的域名解析。DNS迭代查询利用的就是子域授权。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络安全</title>
      <link href="/2016/12/16/linux-security/"/>
      <url>/2016/12/16/linux-security/</url>
      
        <content type="html"><![CDATA[<h1 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h1><p>用户组指的是具有<em>相同系统权限</em>的一组用户,配置文件位于<code>/etc/group</code>。该配置文件的格式为<code>组名:组密码占位符:组编号:组内用户名列表</code>。当组内只有一个用户且用户名和组名相同的时候可以省略组内的用户名列表，例如:<code>mysql:x:501:</code>。组号1~499为系统预留的组编号。</p><p><code>/etc/shadow</code>存放用户组的密码信息，和<code>/etc/group</code>一一对应。分别是<code>组名称:组密码:组管理者:组中用户名列表</code>。当组密码为空、星号或者感叹号的时候可以认为组密码为空.</p><p><code>/etc/passwd</code>，存放用户信息。<code>用户名：密码占位符：用户编号：用户组编号：用户注释信息：用户主目录：shell类型</code>。<code>/etc/shadow</code>存放用户密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd sexy <span class="comment"># 添加组</span></span><br><span class="line">$ groupmod -n market sexay <span class="comment"># 组改名</span></span><br><span class="line">$ groupmod -g 668 market <span class="comment"># 更改组id</span></span><br><span class="line">$ groupadd boss -g 666 <span class="comment"># 创建用户组并同时指定gid</span></span><br><span class="line">$ groupdel market <span class="comment"># 删除用户组之前必须先删除组中的用户，否则成了黑户口可能有权限影响</span></span><br><span class="line">$ groupadd sexy</span><br><span class="line">$ useradd sdf -g sexy</span><br><span class="line">$ useradd jzmb -g sexy</span><br><span class="line">$ <span class="comment"># 修改用户名</span></span><br><span class="line">$ usermod -l cls sdf</span><br><span class="line">$ usermod -d /home/cls cls</span><br><span class="line">$ usermod -G sexy imooc <span class="comment"># 将用户添加到组</span></span><br><span class="line">$ userdel jzmb <span class="comment"># 如果需要删除个人目录下，需要使用-r参数</span></span><br><span class="line">$ passwd -l cls <span class="comment"># 锁定账户</span></span><br><span class="line">$ passwd -u cls <span class="comment"># 解锁账户</span></span><br><span class="line">$ gpasswd -a cls boss <span class="comment"># 将cls用户添加到附属组boss，区别于useradd -g</span></span><br><span class="line">$ useradd -g main_group -G group1,group2 <span class="comment"># 创建用户并同时制定主组合附属组</span></span><br></pre></td></tr></table></figure><blockquote><p>创建用户的时候如果没有指定用户组，将会创建一个和用户名相同的用户组。建立<code>/etc/nologin</code>文件可以禁止除了root之外的所有用户登陆。<code>id</code>命令可以查看用户信息（用户名、用户编号;组编号、组列表）,<code>groups</code>显示用户所在的组。</p></blockquote><p>pem证书权限400。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a devel <span class="built_in">sudo</span> <span class="comment"># devel用户可以使用sudo运行部分命令</span></span><br></pre></td></tr></table></figure><h1 id="系统扫描和安全防范"><a href="#系统扫描和安全防范" class="headerlink" title="系统扫描和安全防范"></a>系统扫描和安全防范</h1><h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><blockquote><p>主机扫描命令<a href="http://fping.org/">fping</a>用于给目标主机发送ping请求，测试主机的存活情况。特点是并行发送，结果易读。<code>ping</code>实际上基于ICMP协议的，很多的运营商为了安全性屏蔽了ICMP封包，使用<code>ping</code>就无法准确知道主机是否存活。<a href="http://www.hping.org/">hping</a>支持TCP&#x2F;IP数据报组装。</p></blockquote><p>make hping的时候如果遇到以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -O2 -Wall    -g  main.c</span><br><span class="line">main.c:29:18: 致命错误：pcap.h：没有那个文件或目录</span><br><span class="line"> <span class="comment">#include &lt;pcap.h&gt;</span></span><br><span class="line">                  ^</span><br><span class="line">编译中断。</span><br><span class="line">make: *** [main.o] 错误 1</span><br></pre></td></tr></table></figure><p>需要使用<code>yum install -y libpcap-devel</code>，make clean后再次make报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">libpcap_stuff.c:19:21: 致命错误：net/bpf.h：没有那个文件或目录</span><br><span class="line"> <span class="comment">#include &lt;net/bpf.h&gt;</span></span><br><span class="line">                     ^</span><br><span class="line">编译中断。</span><br><span class="line">make: *** [libpcap_stuff.o] 错误 1</span><br></pre></td></tr></table></figure><p>执行<code>ln -sf /usr/include/pcap-bpf.h /usr/include/net/bpf.h</code>。make clean &amp;&amp; make 报错如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -ltcl</span><br><span class="line">collect2: 错误：ld 返回 1</span><br><span class="line">make: *** [hping3] 错误 1</span><br></pre></td></tr></table></figure><p>执行<code>yum -y install tcl-devel</code>。make clean &amp;&amp; make 成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对指定目标端口发起tcp探测(1.165机器上使用`sysctl -w net.ipv4.icmp_echo_ignore_all=1`写入内核参数可以忽略ICMP封包)</span></span><br><span class="line">hping -p 3306 -S 192.168.1.165</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪造来源IP，模拟DDOS攻击</span></span><br><span class="line"><span class="comment"># 在165机器上执行`tcpdump -npi eth0 src host 192.168.1.128`抓取来自128的数据包</span></span><br><span class="line"><span class="comment"># 在128机器上执行`hping -p 3306 -S 192.168.1.165`，抓包如下：</span></span><br><span class="line"></span><br><span class="line">05:15:11.885246 IP 192.168.1.128.dialog-port &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 25702362, win 512, length 0</span><br><span class="line">05:15:11.885805 IP 192.168.1.128.dialog-port &gt; 192.168.1.165.mysql: Flags [R], <span class="built_in">seq</span> 25702363, win 0, length 0</span><br><span class="line">05:15:12.885827 IP 192.168.1.128.h2250-annex-g &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1159234257, win 512, length 0</span><br><span class="line">05:15:12.886281 IP 192.168.1.128.h2250-annex-g &gt; 192.168.1.165.mysql: Flags [R], <span class="built_in">seq</span> 1159234258, win 0, length 0</span><br><span class="line">05:15:13.886156 IP 192.168.1.128.amiganetfs &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1926746266, win 512, length 0</span><br><span class="line">05:15:13.886446 IP 192.168.1.128.amiganetfs &gt; 192.168.1.165.mysql: Flags [R], <span class="built_in">seq</span> 1926746267, win 0, length 0</span><br><span class="line">05:15:14.886436 IP 192.168.1.128.rtcm-sc104 &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 877480920, win 512, length 0</span><br><span class="line">05:15:14.886804 IP 192.168.1.128.rtcm-sc104 &gt; 192.168.1.165.mysql: Flags [R], <span class="built_in">seq</span> 877480921, win 0, length 0</span><br><span class="line">05:15:15.886527 IP 192.168.1.128.zephyr-srv &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 92599202, win 512, length 0</span><br><span class="line">05:15:15.886898 IP 192.168.1.128.zephyr-srv &gt; 192.168.1.165.mysql: Flags [R], <span class="built_in">seq</span> 92599203, win 0, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们在128机器上伪造ip 111.111.111.111向165发送数据`hping -p 3306 -S 192.168.1.165 -a 111.111.111.111`，165上使用`tcpdump -npi eth0 src host 111.111.111.111`，抓包如下：</span></span><br><span class="line"></span><br><span class="line">05:20:47.637022 IP 111.111.111.111.cr-websystems &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1736489811, win 512, length 0</span><br><span class="line">05:20:48.637440 IP 111.111.111.111.precise-sft &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1884271442, win 512, length 0</span><br><span class="line">05:20:49.637893 IP 111.111.111.111.sent-lm &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1138710010, win 512, length 0</span><br><span class="line">05:20:50.638273 IP 111.111.111.111.attachmate-g32 &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1280639165, win 512, length 0</span><br><span class="line">05:20:51.638627 IP 111.111.111.111.cadencecontrol &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 964302270, win 512, length 0</span><br><span class="line">05:20:52.638932 IP 111.111.111.111.infolibria &gt; 192.168.1.165.mysql: Flags [S], <span class="built_in">seq</span> 1582924875, win 512, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果发送发发送比较频繁会，服务器会多次建立TCP3次握手等待和重试，导致165机器多次重试并回包给128询问为什么128没有建立第三次握手。165一直无法收到第三次回应的包导致资源耗尽或者网卡流量拥堵。</span></span><br></pre></td></tr></table></figure><h2 id="路由扫描"><a href="#路由扫描" class="headerlink" title="路由扫描"></a>路由扫描</h2><p>Linux下traceroute默认发送udp包，而windows下tracert发送ICMP包，目标端口一般大于30000.traceroute支持3种协议(tcp,udp和ICMP，使用tcp的方式可以获得更加可靠的侦测)。</p><p><code>mtr</code>测试主机到每一个路由的联通性。</p><p>以下是<code>mtr github.com</code>的结果：<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mtr.png" alt="mtr命令"></p><p>我们可以看到各个节点的丢包还是比较严重的。</p><h2 id="批量主机服务扫描"><a href="#批量主机服务扫描" class="headerlink" title="批量主机服务扫描"></a>批量主机服务扫描</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/nmap.png" alt="nmap"></p><blockquote><p>所谓的版开发是指不建立完整的TCP3次握手</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nmap -sP 192.168.1.0/24 <span class="comment"># 扫描主机段内哪些主机存活</span></span><br><span class="line">$ nmap -sS -p 0-30000 192.168.1.165 <span class="comment"># 发送SYN包，侦测主机服务，指定端口为0-30000</span></span><br></pre></td></tr></table></figure><h2 id="安全防范"><a href="#安全防范" class="headerlink" title="安全防范"></a>安全防范</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/syn-attack.png" alt="SYN攻击的原理"></p><p>攻击者伪造ip（利用hping）向目标主机发送SYN包，目标主机收到SYN&#x3D;x包后，向操作系统内核的backlog队列中写入记录，并向<em>不存在的地址</em>回包SYN&#x3D;y，ACK&#x3D;x+1，服务器无法收到第三次握手包。如果攻击的ip很多，会一直想backlog中写入记录，导致backlog队列满了。由于无法收到第三次握手包，服务器会不断重试回包（带宽满），导致服务器一直处于等待，导致系统资源占满。</p><p>解决方案：</p><ul><li>减少发送SYN+ACK包的重试次数：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_synack_retires=3</span><br><span class="line">$ sysctl -w net.ipv4.tcp_syn_retires=3</span><br></pre></td></tr></table></figure><ul><li>SYN Cookies技术</li></ul><p>不建立3次握手，不做等待<br><code>sysctl -w net.ipv4.tcp_syncookies=1</code></p><ul><li>增加backlog队列长度</li></ul><p><code>sysctl -w net.ipv4.tcp_max_syn_backlog=2048</code></p><p>其他补充策略：</p><ul><li>关闭ICMP:<code>sysctl -w net.ipv4.icmp_echo_ignore_all=1</code></li><li>iptables防止恶意扫描：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -A FORWARD -p tcp -syn -m <span class="built_in">limit</span> -<span class="built_in">limit</span> 1/s -limit-burst 5 -j ACCEPT</span><br><span class="line">$ iptables -A FORWARD -p tcp -tcp-flags SYN,ACK,FIN,RST RST -m <span class="built_in">limit</span> -<span class="built_in">limit</span> 1/s -j ACCEPT</span><br><span class="line">$ iptables -A FORWARD -p icmp -icmp-type echo-request -m <span class="built_in">limit</span> -<span class="built_in">limit</span> 1/s -j ACCEPT</span><br></pre></td></tr></table></figure><h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><blockquote><p>NetFilter是linux操作系统核心层内部的一个数据包模块。Hook point是数据包在Netfilter中的挂载点（PRE_ROUTING,INPUT,OUTPUT,FORWARD,POST_ROUTING），数据包在经过这5个挂载点的时候我们可以进行处理。</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/Netfilter.png" alt="NetFilter"></p><p>iptables &#x3D; 4张表(filter,nat,managle,raw) + 5条链(Hook Point) + 规则</p><p>Filter表：访问控制、规则匹配<br>Nat表：地址转发</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/data-filter-flow.png" alt="数据包在4张表和5条链中的流向"></p><h3 id="iptables规则组成"><a href="#iptables规则组成" class="headerlink" title="iptables规则组成"></a>iptables规则组成</h3><p>数据包访问控制：ACCEPT,DROP,REJECT。DROP是直接丢包，REJECT是返回客户端拒绝消息<br>数据包改写：SNAT（改写原地址）,DNAT（改写目标地址）<br>信息记录：LOG</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/iptables-rules.png" alt="iptables规则"></p><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><ul><li>对所有地址开发本机TCP(80,22,10-21)端口访问。</li><li>允许所有地址开放本机的基于ICMP协议的数据包访问。</li><li>其他未被允许的端口禁止访问。</li></ul><blockquote><p>以下命令均在192.168.1.128上完成。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -F <span class="comment"># 清除规则</span></span><br><span class="line">$ iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -p tcp --dport 22 -j ACCEPT <span class="comment"># SSH端口要在默认的规则中加入</span></span><br><span class="line">$ iptables -I INPUT -p tcp --dport 10:21 -j ACCEPT <span class="comment"># 端口范围为10-21</span></span><br><span class="line">$ iptables -I INPUT -p icmp -j ACCEPT <span class="comment"># 允许ICMP协议</span></span><br><span class="line">$ iptables -A INPUT -j REJECT <span class="comment"># 拒绝其他端口，注意该规则追加在末尾</span></span><br><span class="line">$ iptables -D INPUT -p tcp --dport 80 -j ACCEPT <span class="comment"># 删除规则</span></span><br><span class="line">$ iptables -I INPUT -p tcp -s 192.168.1.100 --dport 80 -j ACCEPT <span class="comment"># 只允许192.168.1.100访问web服务</span></span><br></pre></td></tr></table></figure><p>上面的规则中存在以下的几个问题：</p><ul><li>外部主机可以连接到22号端口，但是127.0.0.1（192.168.1.128上的）无法连接到22端口。（本机无法访问本机）</li><li>本机无法向外发送请求，例如在192.168.1.128上执行<code>curl http://www.baidu.com</code>。（本机无法访问其他主机）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -i lo -j ACCEPT <span class="comment"># 开放本机lo网卡</span></span><br><span class="line">$ iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT <span class="comment"># 已经建立TCP监听的时候放行</span></span><br></pre></td></tr></table></figure><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><blockquote><p>ftp主动模式客户端开放随机端口并使用<code>PORT</code>命令将该端口上传至服务器，服务器通过<em>20端口</em>向该随机端口推送数据。ftp被动模式是是客户端发送<code>PASV</code>命令给服务端，服务端会开放一个随机端口，并告诉客户端该端口，客户端会向服务端的该端口拉取数据。所谓的主动和被动是站在服务器的立场上说的。</p></blockquote><p><a href="http://www.imooc.com/article/15136">ftp主动模式和被动模式</a></p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ftp-active-mode.png" alt="主动模式"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ftp-passive-mode.png" alt="被动模式"></p><p>ftp默认使用的是被动模式。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/vsftpd.png" alt="vsftpd"></p><p>在128服务器上进行如下iptables设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -p tcp --dport 21 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -p icmp -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -j REJECT</span><br><span class="line">$ iptables -nL</span><br></pre></td></tr></table></figure><p>我们使用客户端进行登录，发现使用被动模式的时候连接被拒绝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ftp anonymous@192.168.1.128</span><br><span class="line">Connected to 192.168.1.128.</span><br><span class="line">220 (vsFTPd 3.0.2)</span><br><span class="line">331 Please specify the password.</span><br><span class="line">Password:</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system <span class="built_in">type</span> is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line">ftp&gt; <span class="built_in">ls</span></span><br><span class="line">229 Entering Extended Passive Mode (|||53438|).</span><br><span class="line">ftp: Can<span class="string">&#x27;t connect to `192.168.1.128&#x27;</span>: Connection refused</span><br><span class="line">200 EPRT <span class="built_in">command</span> successful. Consider using EPSV.</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">drwxr-xr-x    2 0        0               6 Nov 05 19:43 pub</span><br><span class="line">226 Directory send OK.</span><br><span class="line">ftp&gt;</span><br></pre></td></tr></table></figure><p>在上面的图中我们发现设置了iptables规则后，ftp被动模式连接被拒绝，使用主动模式可以正常连接（服务器使用20端口向外发送数据）。但是ftp为什么默认是被动模式？这主要是为了安全考虑（使用固定的20端口发送数据可能被黑客拦截）。</p><p>编辑vsftpd配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放被动模式的高端口</span></span><br><span class="line">pasv_min_port=50000</span><br><span class="line">pasv_max_port=60000</span><br></pre></td></tr></table></figure><p>第一种方式：在上面的主动模式下的iptables上加上如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -p tcp --dport 50000:60000 -j ACCEPT</span><br></pre></td></tr></table></figure><p>可以发现我们已经可以使用ftp的被动模式了！</p><p>第二种方式：加入内核的连接追踪模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -D INPUT -p tcp --dport 50000:60000 -j ACCEPT</span><br><span class="line">$ modprobe nf_conntrack_ftp <span class="comment"># 加入连接追踪模块</span></span><br></pre></td></tr></table></figure><p>永久生效需要修改配置文件：<code>/etc/sysconfig/iptables-config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPTABLES_MODULES=<span class="string">&quot;nf_conntrack_ftp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><ul><li>员工在公司内部（192.168.1.0&#x2F;24,192.168.2.0&#x2F;24）能访问服务器上的任何服务</li><li>员工出差（例如上海），通过VPN连接到公司外网（员工）-&gt;拨号到-&gt;VPN Server-&gt;内网ftp，samba，nfs，ssh</li><li>公司有一个门户网站需要允许公网访问</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -F</span><br><span class="line">$ iptables -I INPUT -i lo -j ACCEPT</span><br><span class="line">$ iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -s 192.168.2.0/24 -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -p tcp --dport 1723 -j ACCEPT <span class="comment"># VPN,pptp</span></span><br><span class="line">$ iptables -I INPUT -p icmp -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -j REJECT</span><br></pre></td></tr></table></figure><blockquote><p>可以将以上脚本写入到<code>/etc/rc.local</code>开机启动项中<code>/bin/sh /root/iptables_rules.sh</code>。</p></blockquote><h2 id="iptables-NAT表配置"><a href="#iptables-NAT表配置" class="headerlink" title="iptables NAT表配置"></a>iptables NAT表配置</h2><ul><li>SNAT:源地址转换，出口 POSTROUTING</li><li>DNAT:目的地址转换,入口 PREROUTING</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/snat.jpg" alt="SNAT网络拓扑结构"></p><p>以上的结构中101为宿主机，NAT Server2个网卡(hostonly + bridge)。</p><p>在NAT Server上进行如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/sysctl.conf</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">$ sysctl -p <span class="comment"># load value from file</span></span><br><span class="line">$ sysctl -a | grep ip_forward <span class="comment"># check if valid</span></span><br><span class="line">$ iptables -t nat -A POSTROUTING -s 172.16.61.0/24 -j SNAT --to 192.168.1.128 <span class="comment"># 将源地址改写</span></span><br><span class="line">$ iptables -t nat -L</span><br></pre></td></tr></table></figure><p>在客户机172.16.61.129上加入默认网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -rn <span class="comment"># 查看路由表</span></span><br><span class="line">$ route add 0.0.0.0 gw 172.16.61.128</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/dnat.jpg" alt="DNAT"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -d 192.168.1.128 -p tcp --dport 80 -j DNAT --to 172.16.61.129:80</span><br></pre></td></tr></table></figure><h2 id="iptables防CC攻击"><a href="#iptables防CC攻击" class="headerlink" title="iptables防CC攻击"></a>iptables防CC攻击</h2><p>connlimit模块用于限制每个客户端ip的并发连接数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -F</span><br><span class="line">$ iptables -I INPUT -p TCP --syn --dport 80 -m connlimit --connlimit-above 100 -j REJECT <span class="comment"># 每个客户端ip连接不能超过100</span></span><br></pre></td></tr></table></figure><p>limit模块用于限速和控制流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10个包之类放行，超过10个的时候仅允许每分钟1个</span></span><br><span class="line">$ iptables -A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 1/m --limit-burst 10 -j ACCEPT</span><br><span class="line">$ iptables -A INPUT -p icmp -j DROP <span class="comment"># 关掉默认的ICMP</span></span><br></pre></td></tr></table></figure><h2 id="使用iptables进行端口转发实现nginx代理功能"><a href="#使用iptables进行端口转发实现nginx代理功能" class="headerlink" title="使用iptables进行端口转发实现nginx代理功能"></a>使用iptables进行端口转发实现nginx代理功能</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当访问80端口的时候将流量转发到8080端口</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure><h2 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h2><p>关闭root登陆，密码登陆可以提升服务器安全性。ssh免密登陆，将公钥粘贴到服务器的<code>~/.ssh/authorized_keys</code>，并设置权限为600。重启ssh服务。</p><p>Fail2Ban软件可以对服务器安全进行记录。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 服务管理</title>
      <link href="/2016/12/11/linux-service/"/>
      <url>/2016/12/11/linux-service/</url>
      
        <content type="html"><![CDATA[<h1 id="Crontab周期性任务"><a href="#Crontab周期性任务" class="headerlink" title="Crontab周期性任务"></a>Crontab周期性任务</h1><blockquote><p><code>at</code>可以一次性执行。<code>service atd status</code>，它可以使用黑名单和白名单控制，参见<code>/etc/at.deny,at.allow</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ at now+5 minutes</span><br><span class="line">at&gt; <span class="built_in">echo</span> hehe <span class="comment"># ctrl + d保存退出</span></span><br><span class="line">$ atq <span class="comment"># 查看at任务</span></span><br><span class="line">$ at -c 1 <span class="comment"># 查看工作号执行的具体任务</span></span><br><span class="line">$ atrm 1 <span class="comment"># 删除at任务</span></span><br></pre></td></tr></table></figure><p>同理crontab也有访问控制文件<code>cron.deny</code>等。<br>系统服务crond每分钟会从配置文件中刷新定时任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l <span class="comment"># 列出任务，-r 清空</span></span><br><span class="line">$ service crond status <span class="comment"># 查看服务是否正常启动</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/linux-crontab.png" alt="crontab的格式"></p><p><code>crontab -e</code>可以编辑计划任务。在最后追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每分钟输出系统时间到文件</span></span><br><span class="line">*/1 * * * * <span class="built_in">date</span> &gt;&gt; /tmp/date.tmp</span><br><span class="line"><span class="comment"># 每天21:30重启apache</span></span><br><span class="line">30 21 * * * service httpd restart</span><br><span class="line"><span class="comment"># 每月1号、10号、22号4:45重启apache</span></span><br><span class="line">45 4 1,10,22 * * service httpd restart</span><br><span class="line"><span class="comment"># 每月1~10号的4:45重启apache</span></span><br><span class="line">45 4 1-10 * * service httpd restart</span><br><span class="line"><span class="comment"># 每隔2分钟</span></span><br><span class="line">*/2 * * * * service httpd restart</span><br><span class="line"><span class="comment"># 晚上11点到早上7点，每隔1小时</span></span><br><span class="line">0 23-7/1 * * * service httpd restart</span><br></pre></td></tr></table></figure><p>以root身份执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line">1-59/2 * * * * <span class="built_in">echo</span> <span class="string">&quot;奇数分钟&quot;</span></span><br><span class="line">$ crontab -e -u user1</span><br><span class="line">0-58/2 * * * * <span class="built_in">echo</span> <span class="string">&quot;偶数分钟&quot;</span></span><br><span class="line">$ <span class="built_in">tail</span> -f /var/log/cron</span><br></pre></td></tr></table></figure><p>查看crond的日志文件可以发现每次都是新启动了一个进程。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>/etc/crontab</code>,<code>/etc/crond/filename</code>，这两个是系统级的定时任务，使用<code>crontab -l</code> 命令无法列出。</p><p>在<code>/etc/crontab</code>中实际上是指定了<code>MAILTO=root</code>，即将定时任务执行的结果发送给root，我们可以查看<code>/var/spool/mail/root</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * root <span class="built_in">echo</span> <span class="string">&quot;job in the /etc/crontab&quot;</span></span><br><span class="line">*/1 * * * * user1 <span class="built_in">echo</span> <span class="string">&quot;job in the /etc/cron.d/user1&quot;</span></span><br></pre></td></tr></table></figure><p><code>crontab -l</code>命令列出的任务实际上位于<code>/var/spool/cron/username</code>文件。</p><p>crontab最小单位是1分钟，如何让每0.5分钟执行一次？其实可以配置<code>sleep</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * <span class="built_in">date</span> &gt;&gt; /tmp/tmp.date</span><br><span class="line">*/1 * * * * <span class="built_in">sleep</span> 30s;<span class="built_in">date</span> &gt;&gt; /tmp/tmp.date</span><br></pre></td></tr></table></figure><blockquote><p><code>/usr</code>其实不是user的缩写，而是Unix System Resource的缩写。</p></blockquote><p>系统定时任务我们也可以将脚本拷贝到<code>/etc/cron.daily|hourly|monthly|weekly</code>中将被anacron自动管理，推荐使用这种方式。</p><h2 id="anacron配置"><a href="#anacron配置" class="headerlink" title="anacron配置"></a>anacron配置</h2><p>如果执行定时任务之前宕机了，anacron会自动判断是否需要重新执行定时任务。其配置文件位于<code>/etc/anacrontab</code>。</p><h1 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h1><p><a href="https://zh.wikipedia.org/zh-hans/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB">系统运行级别</a>可以使用<code>runlevel</code>查看，可以使用<code>init level</code>进入特定的运行级别。</p><p><code>/etc/services</code>文件写了常规服务和端口的映射。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig --list | grep nginx</span><br><span class="line">$ chkconfig --level 2345 nginx on <span class="comment"># 设置nginx开机自启动（2，3，4，5指定运行级别）</span></span><br></pre></td></tr></table></figure><p>第二种方式设置开机自启动可以编辑配置文件<code>/etc/rc.d/rc.local</code>（别忘了赋予可执行权限），该文件和<code>/etc/rc.local</code>是一个软链接，修改哪个都一样。</p><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=media/linux-services.pdf">centos中的服务</a></p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><blockquote><p>有计划重启服务器是系统维护的重要原则。</p></blockquote><p><code>ps aux</code>中TIME指的是进程占用CPU的时间，使用<code>pstree -pu</code>可以显示进程树（包含用户名和pid）。<br><code>top</code>命令支持交互模式(P，CPU排序，M，内存排序，N，pid排序),该命令的前5行解释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 20:19:51 up 19 days, 16:38,  2 <span class="built_in">users</span>,  load average: 0.15, 0.19, 0.18 <span class="comment"># 1min,5min,15min的平均负载，单核不能大于1，双核不能大于2</span></span><br><span class="line">Tasks: 241 total,   1 running, 240 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.7%us(用户空间占用),  0.2%sy(内核空间占用),  0.0%ni(改变过优先级的进程占用), 98.9%<span class="built_in">id</span>(空闲，不能低于20%),  0.1%wa(IO等待进程),  0.0%hi(硬中断请求),  0.0%si(软中断请求),  0.0%st(虚拟时间steal <span class="keyword">time</span>，当有虚拟机时，虚拟CPU等待实际CPU的百分比)</span><br><span class="line">Mem:  12148312k total, 12006948k used,   141364k free,   401640k buffers</span><br><span class="line">Swap:  2096444k total,    13472k used,  2082972k free,  7821136k cached</span><br></pre></td></tr></table></figure><p><code>w</code>命令可以查看登陆到当前系统中的用户，使用<code>pkill</code>可以按照登陆的终端号踢出用户，例如：<code>pkill -9 -t tty1</code></p><h1 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h1><p>就是将程序放到后台执行。将程序放入后台有2种方法：</p><ol><li>在执行的命令后面加上<code>&amp;</code>（后台运行）；</li><li>执行命令后按下<code>Ctrl+Z</code>（后台暂停）。</li></ol><p>放入后台后可以使用<code>jobs -l</code>命令查看后台工作(<code>+</code>表示最后一个放入到后台的工作，<code>-</code>表示倒数第二个)。需要注意的是放入后台的任务不能和用户交互。<br><code>fg %工作号</code>将后台挂起的进程恢复到前台执行；<code>bg %工作号</code>用于将后台暂停的工作(Ctrl+Z)恢复到后台执行。</p><blockquote><p><code>touch</code>命令并不是新建文件，而是<em>修改文件的时间戳</em>。</p></blockquote><blockquote><p>把命令放入后台执行只能在当前终端执行，一旦退出或者关闭终端后台程序就会终止（发送了SIGHUB信号）！标准方法是使用<code>nohub 命令 &amp;</code>。</p></blockquote><blockquote><p><code>time</code>命令用于统计程序的运行时间，包括用户态和内核态。详见：<a href="https://my.oschina.net/aiguozhe/blog/41052">开源中国</a>。</p></blockquote><p>Linux上源码安装的3个步骤是<code>./configure &amp;&amp; make &amp;&amp; make install</code>，在configuration的时候可以使用<code>-h</code>查看编译选项。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络管理和权限配置</title>
      <link href="/2016/12/04/linux-network/"/>
      <url>/2016/12/04/linux-network/</url>
      
        <content type="html"><![CDATA[<p>arp协议是网络层的协议，但是具体工作在数据链路层，将ip地址和mac地址对应，我们可以使用<code>arp -a</code>命令查看。TCP三次握手建立了<em>可靠连接</em>，这个问题其实是一个<a href="http://baike.baidu.com/link?url=0kkmBIEO4AWwRXMtKY6Z0a8snxODh4LDGqygJSrNhta1WkvTMDazvGgsLBQcdE75pZ7q-YByptCopPSx8pPIHk-zqsnUcoU_LHudccG2VWILpupx6qd7xzOjIKqNkR3S">两军问题</a>，其实*在不可靠的通信中，不管进行几次握手都是有风险的，因为永远无法确定最后一次通信到达，这个问题其实是一个无解的问题。*3次被认为是相对可靠了。子网掩码不一定要是255，只要连续的1即可，例如一个B类网络可以将<code>255.255.255.0</code>作为子网掩码，那么该网络的可用主机数就只有254了（0是网络号，255是广播地址）。ftp协议会使用2个端口（20用于传输数据，21用于发送命令）。SMTP-25，POP3-110。</p><h1 id="linux网络配置"><a href="#linux网络配置" class="headerlink" title="linux网络配置"></a>linux网络配置</h1><p>通过ifconfig命令配置的网络只能临时生效。</p><h2 id="网卡信息文件"><a href="#网卡信息文件" class="headerlink" title="网卡信息文件"></a>网卡信息文件</h2><p>位于<code>/etc/sysconfig/network-scripts/ifcfg-deviceName</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=<span class="string">&quot;eth2&quot;</span></span><br><span class="line">IPADDR=<span class="string">&quot;192.168.1.112&quot;</span></span><br><span class="line">NETWORK=<span class="string">&quot;192.168.1.0&quot;</span></span><br><span class="line">GATEWAY=<span class="string">&quot;192.168.1.1&quot;</span></span><br><span class="line">BROADCAST=<span class="string">&quot;192.168.1.255&quot;</span></span><br><span class="line">BOOTPROTO=<span class="string">&quot;static&quot;</span> <span class="comment"># 可以为dhcp</span></span><br><span class="line">HWADDR=<span class="string">&quot;00:0C:29:14:65:DC&quot;</span> <span class="comment"># mac地址</span></span><br><span class="line">IPV6INIT=<span class="string">&quot;yes&quot;</span></span><br><span class="line">NM_CONTROLLED=<span class="string">&quot;yes&quot;</span></span><br><span class="line">ONBOOT=<span class="string">&quot;yes&quot;</span> <span class="comment"># 启动时开启网络服务</span></span><br><span class="line">TYPE=<span class="string">&quot;Ethernet&quot;</span></span><br><span class="line">UUID=646b18f4-56d3-47bf-bcd9-78fdf96de301</span><br><span class="line">DNS1=192.168.1.111</span><br><span class="line">DNS2=114.114.114.114</span><br><span class="line">USERCTL=no <span class="comment"># 不允许非root用户控制该网卡</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://jingyan.baidu.com/article/7f41ecec1b022e593d095c1e.html">Centos7修改网卡为eht0</a></p></blockquote><h2 id="主机名文件"><a href="#主机名文件" class="headerlink" title="主机名文件"></a>主机名文件</h2><p><code>/etc/sysconfig/network</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=<span class="built_in">yes</span> <span class="comment"># 为no表示不工作</span></span><br><span class="line">HOSTNAME=localhost.localdomain</span><br></pre></td></tr></table></figure><h2 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h2><p><code>/etc/resolv.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 10.0.80.11</span><br><span class="line">nameserver 10.0.80.12</span><br></pre></td></tr></table></figure><p>配置好以上的3个参数后执行<code>service network restart</code>即可。</p><blockquote><p>Centos 6以后的网卡配置文件多了uuid字段，如果局域网内uuid重复就可能导致网络启动失败。解决方案</p></blockquote><ol><li>删除<code>/etc/sysconfig/network-scripts/ifcfg-deviceName</code>中的HWADDR行;</li><li>删除网卡和MAC地址绑定文件，<code>rm -rf /etc/udev/rules.d/70-persistent-net.rules</code>；</li><li>reboot。</li></ol><p>连接到内网的网卡是不能设置网关的。</p><blockquote><p>设置grep高亮显示.编辑<code>~/.bashrc</code>，加入<code>alias grep=&#39;grep --color=auto&#39;</code>即可。</p></blockquote><blockquote><p>运行<code>tcpdump -i eth0 -nnX port 21</code>，可以对ftp通信进行抓包。非对称加密算法中发送端和接受端都维护者自己的公钥和私钥，发送数据的时候发送端使用接收端的公钥（所以我们可以在首次连接的时候看到提示是否下载远程主机的公钥）进行加密，接收端收到数据后使用自己的私钥进行解密。——发送端想要将数据发送给谁就使用谁的公钥进行加密。</p></blockquote><p>抓取特定主机的特定端口<code>tcpdump -i eth4 -nnX &#39;((tcp) and (port 9001) and ((src host 192.168.1.74) or (dst host 192.168.1.74)))&#39;</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rmp -qf filename <span class="comment"># 查看文件属于哪个rpm包</span></span><br></pre></td></tr></table></figure><p>yum源的配置文件位于<code>/etc/yum.repos.d</code></p><p>配置光盘yum源只需要将默认的yum源配置文件改名，然后修改<code>/etc/yum.repos.d/Centos-Media.repo</code>修改为光盘挂载点并让它enabled即可。我们之所以可以使用<code>service xxx restart</code>的方式启动程序是因为这些程序被安装到了<code>/etc/init.d</code>。</p><p>在使用源码安装软件的时候一般按照约定的格式，即:<code>/usr/local/src</code>保存源码包，软件安装位置为<code>/usr/local</code>，安装源码包使用的<code>./configure</code>实际上是生成makefile，使得以后的make和make install可以执行，如果安装报错可以执行<code>make clean</code>进行清理。SELinux的来头很大，是美国国家安全局，配置位于<code>/etc/selinux/confg</code>。</p><p>显示公网ip只需要访问ipecho.net.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -s http://ipecho.net/plain</span><br></pre></td></tr></table></figure><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><blockquote><p>如果对文件具有写权限，能够对文件内容进行修改，但是不能删除文件，因为文件是属于上一级目录的，必须对上一级目录具有写权限。对文件来讲最高权限是x，而对目录来讲最高权限是w(目录的权限只有0，5(rx),7(rwx)有意义，剩余的所有权限都没有意义)。创建一个文件或者目录，其初始权限是<code>umask</code>表示的值（4个数字，其中第一个表示特殊权限，后面的表示文件权限的掩码)。文件的执行权限必须手工赋予，所以文件的默认最大权限为666，666(-rw-rw-rw-)减去umask 022（—–w–w-）,得到644(-rw-r–r–)，目录最大权限为777，减去umask 022得到755。注意<em>不能拿数字直接相减，例如umask为033，创建出来的文件权限一样是644</em>。umask的配置文件位于<code>/etc/profile</code>。</p></blockquote><h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><p>由于Linux只有owner，group和other3种权限，所以某些场景下可能会权限不够用，此时可用ACL权限，我们可以使用<code>dumpe2fs -h /dev/sda2</code>命令查看输出中的<code>Default mount options:    user_xattr acl</code>可以知道该分区支持ACL权限，如果没有我们可以使用<code>mount -o remount,acl /</code>重新挂载根分区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">whoami</span> <span class="comment"># root</span></span><br><span class="line">$ useradd tony</span><br><span class="line">$ groupadd stu</span><br><span class="line">$ <span class="built_in">mkdir</span> /av</span><br><span class="line">$ <span class="built_in">chown</span> tony:stu /av</span><br><span class="line">$ <span class="built_in">chmod</span> 770 /av</span><br><span class="line">$ useradd lw</span><br><span class="line">$ setfacl -m u:lw:rx /av <span class="comment"># 给用户添加ACL权限是u，同理给组添加是g执行完这个之后文件权限最后一位变成了加号,表示ACL权限，drwxrwx---+</span></span><br><span class="line">$ getfacl /av <span class="comment"># 查看ACL权限</span></span><br></pre></td></tr></table></figure><p>getfacl命令会返回mask，这个mask表示的是最大有效权限，该mask和我们使用<code>setfacl</code>命令进行与运算可以得到真正的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ setfacl -m m:rx /av <span class="comment"># -R参数可以设置递归ACL权限</span></span><br><span class="line">$ getfacl /av </span><br><span class="line">$ setfacl -m u:tony:rx /av</span><br><span class="line">$ setfacl -x u:lw /av <span class="comment"># 删除lw的ACL权限</span></span><br><span class="line">$ setfacl -b /av <span class="comment"># 清除目录/av的所有ACL权限</span></span><br></pre></td></tr></table></figure><blockquote><p>设置ACL权限的时候使用<code>-R</code>参数设置递归，则文件可能会产生“权限溢出”，因为给目录设置了执行权限，递归过去文件就有了执行权限。ACL权限的权限溢出很难控制，所以尽量少用ACL权限。如果给目录设置了默认ACL权限，那么该目录中所有<em>新建的文件</em>都会继承该目录的ACL权限：<code>setfacl -m -d:u:username:rx dirname</code>。</p></blockquote><h2 id="sudo权限"><a href="#sudo权限" class="headerlink" title="sudo权限"></a>sudo权限</h2><p>把本来只有root用户执行的命令赋予普通用户执行，命令是<code>visudo</code>，实际上编辑的是<code>/etc/sudoers</code>。普通用户可以使用<code>sudo -l</code>查看能执行的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">用户名 被管理的主机地址=(可使用的身份)授权命令(绝对路径)</span><br><span class="line">%wheel  ALL=(ALL)       ALL</span><br><span class="line">%组名 被管理的主机地址=(可使用的身份)授权命令(绝对路径)</span><br><span class="line">user1 ALL=(ALL) /sbin/shoutdown -r now <span class="comment"># 普通用户只能执行这一条命令，如果只写shutdown，那么可以执行shutdown后面跟任意参数</span></span><br><span class="line"><span class="comment"># 给普通用户授予添加用户和设置密码的权限，因为执行passwd的时候身份会切回root，所以使用正则进行了限制，防止root密码被修改！</span></span><br><span class="line">user1 ALL=/usr/bin/useradd</span><br><span class="line">user1 ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd <span class="string">&quot;&quot;</span>, !/usr/bin/passwd root</span><br><span class="line">user1 ALL=/bin/vi <span class="comment"># sudo vi会切换到root，此命令非常危险 </span></span><br></pre></td></tr></table></figure><h2 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h2><p>setuid，setgid和sticky bit权限非常不安全，系统需要使用它进行一些特定的功能，如果滥用可能导致极其严重的后。</p><h3 id="setuid"><a href="#setuid" class="headerlink" title="setuid"></a>setuid</h3><p><code>chmod 4755 filename</code> 或者 <code>chmod u+s 文件名</code>（u+s是suid，g+s是sgid，o+s是sbid）</p><ul><li>只有可执行程序才可以设置suid权限。</li><li>命令执行者需要对该程序具有执行权限。</li><li>命令执行者在执行该程序时获得该程序文件属主的身份（在程序执行过程中灵魂附体为该文件的属主）。</li><li>仅在程序执行过程中有效，也就是说用户身份改变只在程序运行过程中生效。</li></ul><p>密码保存文件<code>/etc/shadow</code>的权限是000，那么普通用户是如何更改自己密码的呢？答案就在passwd命令中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwsr-xr-x. 1 root root 28K 6月  10 2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure><p>该文件具有suid权限，任何用户对该文件具有执行权限，所以普通用户使用<code>passwd</code>回车的瞬间获得了<code>/usr/bin/passwd</code>文件所有者（root）的权限。那么问题来了，既然普通用户执行passwd的命令的时候身份已经变成了root，那不就可以修改别人的密码了么？答案是普通用户在执行<code>passwd</code>的时候后面不能跟任何参数。</p><p>suid非常危险，最典型的就是给<code>chmod 4755 /bin/vi</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwsr-xr-x. 1 root root 889K 6月  10 2014 /bin/vi <span class="comment"># 任何普通用户执行vi身份会变为root</span></span><br></pre></td></tr></table></figure><p>为了严格控制suid权限，我们应该定期扫描系统中的suid权限的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索系统中所有拥有suid和sgid权限的文件</span></span><br><span class="line">find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">cat</span> /tmp/setuid.check)</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    grep <span class="variable">$i</span> /root/suid.list &gt; /dev/null</span><br><span class="line">    <span class="comment"># 检测上一个命令的返回值，如果不为0，证明上个命令报错</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> != <span class="string">&quot;0&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$i</span> is not in listfile&quot;</span> &gt;&gt; /root/suid_log_$(<span class="built_in">date</span> +%)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">rm</span> -rf /tmp/setuid.check        </span><br></pre></td></tr></table></figure><h3 id="setgid"><a href="#setgid" class="headerlink" title="setgid"></a>setgid</h3><p><code>chmod 2755 filename</code>。</p><ul><li>只有可执行程序才能设置sgid</li><li>命令执行者需要对该程序具有执行权限。</li><li>命令执行过程中组身份改变为该文件的属组。</li></ul><p><code>locate</code>命令用于快速搜索文件,实际上搜索的是<code>/var/lib/mlocate/mlocate.db</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-----. 1 root slocate 716K 12月 11 06:46 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure><p>普通用户没有该文件的任何权限，但是普通用户是可以通过locate命令进行按名查找的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwx--s--x. 1 root slocate 40K 6月  10 2014 /usr/bin/locate</span><br></pre></td></tr></table></figure><p>当普通用户执行该命令时组都会切换为slocate组，而slocate组对数据库文件具有读权限。</p><p>对文件和目录生效。</p><h3 id="sticky-bit"><a href="#sticky-bit" class="headerlink" title="sticky bit"></a>sticky bit</h3><p>仅对目录生效。要求所有普通用户对目录具有7权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /home/user1/abc</span><br><span class="line">$ <span class="built_in">chmod</span> 777 /home/user1/abc</span><br><span class="line">$ <span class="built_in">chmod</span> o+t /home/user1/abc <span class="comment"># 或者chmod 1777  </span></span><br><span class="line">$ l /home/user1/abc</span><br><span class="line">$ drwxrwxrwt. 2 root  root     6 12月 11 07:10 abc</span><br></pre></td></tr></table></figure><p>任何普通用户都能在&#x2F;home&#x2F;user1&#x2F;abc建立文件，但是只能删除自己创建的文件。</p><p><code>/tmp</code>目录默认拥有sbit权限。任何用户都可以在该目录下新建文件，但只能删除自己创建的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ll -d /tmp </span><br><span class="line">drwxrwxrwt.   7 root root   88 12月 11 06:46 tmp</span><br></pre></td></tr></table></figure><h2 id="chattr权限"><a href="#chattr权限" class="headerlink" title="chattr权限"></a>chattr权限</h2><ul><li>选项i。如果对文件设置，不能对文件进行删除、改名，也不能添加和修改数据；如果对目录设置，只能修改目录下文件数据，但是不能建立和删除文件。</li><li>选项a。对文件设置只能对文件追加数据(&gt;&gt;的方式，vi之类的编辑器被禁用，日志非常适合)，不能删除和修改数据；对目录设置，只能在目录中建立和修改文件，不能删除。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chattr +i abc <span class="comment"># 该文件被锁定了，无法更改和删除</span></span><br><span class="line">lsattr abc</span><br></pre></td></tr></table></figure><h1 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h1><p><code>vmstat</code>命令是CPU、内存、IO的整合。<code>dmesg | grep CPU</code>命令可以查看系统自检信息。查看CPU信息<code>cat /proc/cpuinfo</code>。查看系统架构最简单的方法是使用file命令查看一个系统自带命令<code>file /bin/ls</code>。<code>lsb_release  -a</code>查看centos发行版(<code>yum install lsb</code>)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lsof /sbin/init <span class="comment"># 查看某个文件被哪个进程占用</span></span><br><span class="line">$ lsof -c sshd <span class="comment"># 查看sshd进程占用了哪些文件</span></span><br><span class="line">$ lsof -u root <span class="comment"># 查看root用户的进程占用的文件</span></span><br></pre></td></tr></table></figure><blockquote><p>cache和buffer分别是加速数据读取和写入的，策略分别是LRU和FIFO。</p></blockquote><h1 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h1><p>系统日志存放目录为<code>/var/log/</code>，包含messages(系统主日志文件)，secure（认证、安全），dmesg（启动自检）。</p><p>分析nginx日志，得到最多访问网站的ip地址的命令为:<code>cat /var/log/nginx/access.log | awk &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr</code>。</p><blockquote><p>创建一个目录，并进入到该目录：<code>mkdir test &amp;&amp; cd $_</code></p></blockquote><h1 id="关于TCP数据包到达顺序的问题"><a href="#关于TCP数据包到达顺序的问题" class="headerlink" title="关于TCP数据包到达顺序的问题"></a>关于TCP数据包到达顺序的问题</h1><p>以前作者也一直以为数据包先发的不一定先到，直到今天才意识这个问题的缺陷，数据包是不一定先发先到，但是对于TCP有一点特殊，若我们接受的数据包是在应用层，并且应用层用的是TCP的传输协议的话，这个顺序是保证，这个顺序的保证是在传输层保证的，举个例子：</p><p>client发生数据A,B给server，使用的TCP传输，client发送毫无疑问是先发送A，然后发送B，但是有些搞网络的同学可能会有这个疑问，A跟B在物理层走的链路不一样，传输速度不一样，B是会比A先到达Server,这个是没有错的，但是这个数据包被接受是在网络层跟传输层，请记住网络跟传输层的作用，网络层是保证同一个包的完整，就是说若你的传输层发出的包过大，在网络层（也就是IP层）会被分包，同时在Sever的网络接受的时候会被组包，有一个完整的包才会交给传输层，若包不完整是会丢弃，同时他也不保证你的包的是否达到，数据包的保证是在传输层做的，就是说若传输层(TCP协议才会，UDP并不保证)没有收到对方的确认包，会有超时重传，每个数据包也是有序列号的，同时，传输层就是根据这个序列号来保证A,B包的顺序，即使B比A先到达了，TCP也会是等A到达之后，先把A提交给应用层，再把B的数据提交给应用层，从而保证了，同一条TCP链接，先发的包先到</p><p>注：这个顺序的保证是传输层做的，TCP这个协议保证的，UDP并不保证，网络层接收包的顺序是错乱的。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcached 初窥</title>
      <link href="/2016/10/18/memcached/"/>
      <url>/2016/10/18/memcached/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h1><p>考虑这样一种情形：申请 20M 内存，释放 15M 内存，然后又需要申请 12M 内存，这样就产生了 3M 的内存碎片，随着程序的运行，碎片会越来越多。memcached 采用了 Slab Allocator 分配机制:基本原理是按照预先规定的大小，将分配的内存分割成特定长度的块(chunk)，并将尺寸相同的chunk 分成组(chunk 的集合)，尽可能（完全解决内存碎片是不可能的）解决内存碎片问题。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/memcached-slab-allocator.png" alt="Slab Allocator"></p><p>根据收到的数据大小自动选择最合适的 slab（具体实现是 memcached 中保存着 slab 空闲 chunk 的列表，根据这个列表选择空的 chunk 并将数据缓存其中），例如 100bytes 的 item 将会被存放在上图中的 Slab2，但是<em>剩下的12字节同样被浪费了，无法重新利用</em>，这种做法只是<strong>尽可能减少内存碎片</strong>。使用<code>memcached -vvv</code>启动服务的时候可以看到类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slab class   1: chunk size        96 perslab   10922</span><br><span class="line">slab class   2: chunk size       120 perslab    8738</span><br><span class="line">slab class   3: chunk size       152 perslab    6898</span><br><span class="line">slab class   4: chunk size       192 perslab    5461</span><br><span class="line">slab class   5: chunk size       240 perslab    4369</span><br><span class="line">slab class   6: chunk size       304 perslab    3449</span><br><span class="line">slab class   7: chunk size       384 perslab    2730</span><br><span class="line">slab class   8: chunk size       480 perslab    2184</span><br></pre></td></tr></table></figure><p>仔细观察可以发现:120&#x2F;96 &#x3D; 152 &#x2F; 120 &#x3D; 1.25，这个 chunk 的增长比例就叫做增长因子(grow factor，默认 1.25,启动时可指定<code>-f</code>命令行参数) 。</p><blockquote><p>警告：如果我们要存 100bytes 数据，正常情况下应该保存在 chunk size 为 120bytes 的仓库（即 slab2），但是slab2已经满了，<em>并不会选择存到更大的 slab，例如 slab3，而是将老的数据挤出去，其策略是惰性过期机制和LRU删除机制！</em></p></blockquote><h1 id="过期和删除机制"><a href="#过期和删除机制" class="headerlink" title="过期和删除机制"></a>过期和删除机制</h1><ol><li>当某个值过期时，并没有从内存中删除，因此 stats 命令统计的时候<code>curr_items</code>有其信息；</li><li>取值的时候先判断是否过期，如果过期则返回空清空该 key 占用的 chunk，<code>curr_items</code>就减少了；</li><li>如果之前没有 get 过，将不会自动删除，当某个新值占用其位置时，将会被当做空 chunk 来用。</li></ol><blockquote><p>过期指的是让用户看不到数据，并不是在过期瞬间正真从内存中移除，被称为惰性失效(lazy expiration)。惰性的好处是节省了 CPU 时间和检测是否过期的成本。</p></blockquote><p>删除机制使用的 LRU，对 key 进行更新，查询将会刷新 key 为最新（被认为是新数据）。<em>即使某个 key 被设置为永久有效期也一样会被踢出</em>，这个就是大名鼎鼎的永久数据被踢的现象（看似违背直觉，但是确是内存管理机制的必然结果）。以 122bytes 大小的 chunk 为例，如果 122bytes 的 chunk 满了，又有新的值需要加入（长度为120bytes ），应该挤掉最近最久未使用的。</p><h1 id="memcached中的一些参数限制"><a href="#memcached中的一些参数限制" class="headerlink" title="memcached中的一些参数限制"></a>memcached中的一些参数限制</h1><ul><li>key 的长度限制为 250bytes,<a href="https://github.com/memcached/memcached/releases/tag/1.3.2">二进制协议</a>支持 65535 字节。</li><li>value 限制为 1M(100W 字符)。</li></ul><h1 id="分布式取模算法的缺陷"><a href="#分布式取模算法的缺陷" class="headerlink" title="分布式取模算法的缺陷"></a>分布式取模算法的缺陷</h1><p>所谓的分布式就是将不同的键存储到多态服务器，这样就引来一个问题？如何确定键和服务器的对应关系？最容易的算法是将 key 转化成数字（例如hash 签名算法或者 CRC32），然后将这个数字对服务器数量进行 MOD 运算。这种算法存在一个很大的弊端：原先有 3 个 server 分别按照 hash 取余，存储的数据对应关系为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server1 - key0,key3 <span class="comment"># mod = 0</span></span><br><span class="line">server2 - key1,key4 <span class="comment"># mod = 1</span></span><br><span class="line">server3 - key2 <span class="comment"># mod = 2</span></span><br></pre></td></tr></table></figure><p>如果 server3 宕机，查询 key3 的时候，计算出来的是<code>3 mod 2 = 1</code>，即：我们应该到 server2 去取 key3，肯定是无法找到的！然而 key3 对应的数据依然好好滴在 server1 上存储着，一个严重的问题是：<em>缓存命中率大大降低</em>。</p><blockquote><p>从数学上讲，当服务器从 N 变成 N-1 之后，在<code>[0,N*N-1]</code>范围内只有<code>[0,N-1]</code>算出来的余数没有改变（一共N个数），即：每<code>N*N-1</code>个key只有N个key的模没有变，命中率为:<code>N/(N*N-1) = 1/N-1</code>。所以10台服务器变成9台服务器的时候11台变成10台服务器的时候命中率只有10%了，下降了90%!，并且服务器越多后果越严重，买的服务器越多结果性能越差，这不就亏大了？</p></blockquote><p>求余算法的另一个缺点是打乱了原有的数据存储，例如：原来有 3 台服务器，存储数据为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server1 - 0,3,6,9</span><br><span class="line">server2 - 1,4,7</span><br><span class="line">server3 - 2,5,8</span><br></pre></td></tr></table></figure><p>当 server2 宕机时，按照求余算法，数据分布为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server1 - 0,2,4,6,8</span><br><span class="line">server3 - 1,3,5,7,9</span><br></pre></td></tr></table></figure><p>可以发现原来的 3 和 9 在 server1 上好好滴放着被迁移到了 server3，原来的 2 和 8 在 server3 上放着被迁移到了 server1，我们理想的情况是将宕机的 server2 中的数据分配到 server1 和 server3 就行了。<em>数据迁移是很耗性能的</em>。</p><p>鉴于分布式取余的以上缺点，我们使用一致性哈希。</p><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><blockquote><p>把服务器各个节点映射放在钟表的各个时刻上，把 key 也映射到钟表的某个时刻上。该 key 沿着钟表顺时针走，碰到的第一个节点即为该 key 的存储节点。如图所示：</p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/consistent-hash.png" alt="memcached一致性哈希"></p><p>以上有 2 点疑问：</p><ol><li>时钟上的指针的最大才 11 点，如果有上百个 memcached 节点该怎么办？时钟只是为了便于理解做的比喻。在实际应用中我们可以在圆环上分布<code>[0,2^32-1]</code>个数字，这样全世界的服务器都可以装下了。</li><li>如何将“节点名”和“键名”转化为整数。可以使用现成的函数，例如：crc32()。也可以自定义转化规则，但是要注意转化的<em>碰撞率</em>要低（碰撞值的是：不同的输入得到了相同的输出）。</li></ol><h2 id="一致性hash对其他节点的影响"><a href="#一致性hash对其他节点的影响" class="headerlink" title="一致性hash对其他节点的影响"></a>一致性hash对其他节点的影响</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/consistent-hash-range.png" alt="一致性哈希的影响范围"></p><p>从上图可以看出：当某个节点宕机之后只影响该节点顺时针之后的一个节点，而其他节点不受此影响，<em>一致性哈希最大限度抑制了键的重新分布</em>。（re-hash）</p><h2 id="一致性哈希-虚拟节点对缓存命中率的影响"><a href="#一致性哈希-虚拟节点对缓存命中率的影响" class="headerlink" title="一致性哈希 + 虚拟节点对缓存命中率的影响"></a>一致性哈希 + 虚拟节点对缓存命中率的影响</h2><p>由上图我们可以看出，在理想状态下：</p><ol><li>节点在圆环上分配均匀，因此承担的任务也是平均的，但事实上：一般的哈希函数对于节点在圆环上的映射并不均匀。</li><li>当某个节点宕机之后直接冲击下一个节点，对下一个节点的冲击过大，所以能否把 down 掉的节点上的压力平均分配到其他所有存活着的节点上？</li></ol><p>我们可以通过引入虚拟节点完全解决上述问题。</p><p>每个真实节点可以映射成 M 个虚拟节点，则 N 个真实节点就映射为 <code>M*N</code> 个虚拟节点散列在圆环上。各个真实节点对应的虚拟节点<em>交错分布</em>。这样，某个真实节点 down 掉之后，则把其影响分到到其他所有节点上。如图所示：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/consistent-hash-virtual-node.png" alt="memcached虚拟节点"></p><p>即：N 台服务器变成 N-1 台服务器之后，剩下的 N-1 台服务器分担宕机的 1 台服务器的影响，从而<em>不命中率</em>为 1&#x2F;N-1，和分布式取模算法刚好相反！<a href="https://gitee.com/gaopengfei/dsa4j/tree/master/src/main/java/io/github/consoles/distribution">java代码实现</a>，<a href="https://gitee.com/gaopengfei/dsa4j/tree/master/src/main/webapp/memcached">这个实验</a>模拟了当 5 台服务器挂掉一台之后不同算法对缓存命中率的影响：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/distribution-mod.png" alt="分布式取模"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/distribution-hash.png" alt="一致性hash"></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> memcached </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim技巧</title>
      <link href="/2016/10/09/vim-skill/"/>
      <url>/2016/10/09/vim-skill/</url>
      
        <content type="html"><![CDATA[<h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><ul><li><code>=</code>：一个常用的场景就是粘贴代码后格式乱了，使用<code>v</code>命令进入多选模式，选中几行，然后<code>=</code>。</li><li><code>vi abc.txt +</code>:打开文件abc.txt并定位到最后一行。</li><li><code>vi abc.txt +3</code>:打开abc.txt并定位到第3行(如果行号过大就会定位到最后一行和直接使用<code>+</code>一样)。</li><li><code>vi message-center/chatServer.js +/data</code>，找出chatServer.js中所有的data，我们可以使用<code>n</code>（下一个）或者<code>N</code>（上一个）进行切换。</li><li><code>vi a.txt b.txt c.txt</code>,创建或者打开3个文件(可以使用<code>:ls</code>查看打开的所有文件)，我们可以使用<code>:n</code>(向下切换,<code>:next</code>)或者<code>:N</code>（向上切换,<code>:prev</code>）当前文件名。</li><li><code>/xxx</code>（从光标位置向后搜索）,<code>?xxx</code>（从光标位置向前搜索）</li><li><code>ctrl+f</code>(向下翻页，forward)，<code>ctrl+b</code>(上翻页，backward)。</li><li><code>yy</code>复制光标所在行，<code>p</code>在光标所在行下方粘贴(<code>P</code>在所在行上方粘贴)。</li><li><code>w</code>下一个单词(word)，<code>b</code>上一个单词(backword)。</li><li><code>shift+v</code>:选择多行，然后上下左右移动。前面说的是整行选择，我们也可以使用<code>v</code>，然后方向键进行选择。</li><li>删除：一个字母<code>x</code>，一个单词<code>dw</code>，一行<code>dd</code>，多行：<code>shift+v</code>，然后<code>x</code>或者<code>d</code>。</li><li>复制：单词：<code>yw</code>,当前行<code>yy</code>，粘贴<code>p</code>,复制粘贴时格式错乱可以使用<code>set paste</code>进入粘贴模式。重复上次操作<code>.</code></li></ul><h1 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h1><ul><li>fuzzy find模糊搜索</li><li>MRU插件（Most Recently used files）</li></ul><h1 id="为什么有时候使用自带的方向键向下左右变成了-A-B-D-C"><a href="#为什么有时候使用自带的方向键向下左右变成了-A-B-D-C" class="headerlink" title="为什么有时候使用自带的方向键向下左右变成了^[[A^[[B^[[D^[[C"></a>为什么有时候使用自带的方向键向下左右变成了<code>^[[A^[[B^[[D^[[C</code></h1><p>readline的问题，详见<a href="https://www.zhihu.com/question/21518507">知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript正则表达式</title>
      <link href="/2016/10/05/js-regexp/"/>
      <url>/2016/10/05/js-regexp/</url>
      
        <content type="html"><![CDATA[<p>使用场景：在当前目录下查找所有的TXT文件：<code>find ./ -name *.txt</code>。</p><p>一个比较好的在线<a href="https://regexper.com/">正则表达式可视化网站</a>可以将正则表达式图形化表示出来，我们也可以找到它在<a href="https://github.com/javallone/regexper-static">github上的地址</a>将其安装到本地。还有一个<a href="https://jex.im/regulex/">比较酷的网站</a>。</p><h1 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h1><p>正则表达式默认是贪婪模式，也就是说：尽可能多地匹配。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123456789&#x27;</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/\d&#123;3,6&#125;/</span>,<span class="string">&#x27;X&#x27;</span>) <span class="comment">// &#x27;X789&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的正则可以匹配3，4，5，6个数字，但是会默认匹配6个数字。如果想要尽可能少匹配加上量词<code>?</code>即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/\d&#123;3,6&#125;?/</span>,<span class="string">&#x27;X&#x27;</span>) <span class="comment">// &#x27;X456789&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>匹配一个小写字母加上一个数字连续出现3次的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;a1b2c3d4&#x27;</span></span><br><span class="line">str.<span class="title function_">replace</span>(<span class="regexp">/(\w\d)&#123;3&#125;/</span>,<span class="string">&#x27;X&#x27;</span>) <span class="comment">// &#x27;Xd4&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="反向引用和分组捕获"><a href="#反向引用和分组捕获" class="headerlink" title="反向引用和分组捕获"></a>反向引用和分组捕获</h3><p>例如将2015-12-25替换为12&#x2F;25&#x2F;2015：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;2015-12-25&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>,<span class="string">&#x27;$2/$3/$1&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="lastIndex属性"><a href="#lastIndex属性" class="headerlink" title="lastIndex属性"></a><code>lastIndex</code>属性</h2><p><code>RegExp.prototype.test</code>方法每次执行结果会作用到正则表达式本身的<code>lastIndex</code>属性(当前匹配结果的最后一个字符的下一个字符的索引)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;ab&#x27;</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// false</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(str) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面的结果很奇怪，实际上是<code>lastIndex</code>发生了变化,每次匹配的时候都是从上次匹配停下来的地方开始的，当<code>lastIndex</code>为<code>undefined</code>时会被再次重置为0.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; reg.test(str)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; reg.lastIndex</span><br><span class="line">1</span><br><span class="line">&gt; reg.test(str)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; reg.lastIndex</span><br><span class="line">2</span><br><span class="line">&gt; reg.test(str)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; reg.lastIndex</span><br><span class="line">0</span><br><span class="line">&gt; reg.test(str)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; reg.lastIndex</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>这个错误是<em>很隐晦的</em>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\w/g</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">reg.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面的现象很容易让人产生错觉：正则是不可靠的，只有奇数次的执行结果是对的。于是一种所谓的解决方案产生了：<code>/\w/g.test(&#39;a&#39;)</code>，每次使用的时候实例化一个Rex对象就可以保证正确性了，但是这样做也是有缺点的：另外的性能开销。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java NIO</title>
      <link href="/2016/09/10/java-nio/"/>
      <url>/2016/09/10/java-nio/</url>
      
        <content type="html"><![CDATA[<blockquote><p>jdk1.7中提供了<code>Object.equals</code>,<code>Object.hashCode</code>方法非常方便。</p></blockquote><h1 id="传统的socket分析"><a href="#传统的socket分析" class="headerlink" title="传统的socket分析"></a>传统的socket分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10086</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server started&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">// Blocking</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a new client connected&quot;</span>);</span><br><span class="line">            handler(socket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(buf); <span class="comment">// Blocking</span></span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,read));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;socket closed&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码有2个地方阻塞：<code>ServerSocket.accept</code>和<code>InputStream.read</code>。当我们启动上述server，一旦有一个客户端连接到server，server就会<em>阻塞</em>，从而以后的客户端想要连接到server都不会打印”a new client connected”。一种常见的解决方案是创建一个新的handler线程，每个客户端连接的时候都创建一个新的线程为其服务，就好比一个餐厅每来一个客人都安排一个服务生，资源消耗非常大。所以传统的socket是无法实现长连接的服务器的，但是用短连接还是比较合适的，老版本的tomcat就是基于socket，因为http的问答机制，不会出现线程一直被一个客户端占用的情况，一个线程可以为多个客户端服务。</p><blockquote><p>传统的socket单线程情况下只能为一个客户端服务，用线程池的情况下可以为多个客户端服务，但是资源消耗太大。</p></blockquote><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>daily build很痛苦，每次commit都需要跑一个较大的CI，很耗时。让小的和频繁的升级成为可能，应用架构更加弹性可伸缩（横向拓展的一个重要目标就是无状态）。微服务带来的一个挑战是我们面对的不仅仅是一个应用，而是多个应用，有点像分布式系统。</p><h2 id="为什么nginx比apache性能高很多"><a href="#为什么nginx比apache性能高很多" class="headerlink" title="为什么nginx比apache性能高很多"></a>为什么nginx比apache性能高很多</h2><p>nginx采用事件驱动的epoll模型，而apache采用select轮询机制（类似于死循环）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tech.meituan.com/2018/10/18/netty-direct-memory-screening.html">Netty堆外内存泄漏排查</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> nio </tag>
            
            <tag> netty </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 学习笔记</title>
      <link href="/2016/09/06/learn-redis/"/>
      <url>/2016/09/06/learn-redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis 序列化协议使用的是文本协议，客户端的开发非常简单，易于解析。</p></blockquote><h1 id="常见的一些数据库和缓存性能对比"><a href="#常见的一些数据库和缓存性能对比" class="headerlink" title="常见的一些数据库和缓存性能对比"></a>常见的一些数据库和缓存性能对比</h1><p>MYSQL QPS：8000 读，4000 写; redis 10W 读写。</p><p>memcached 的瓶颈在于<a href="http://libevent.org/">libevent</a>，而 redis 用了 epoll。</p><h1 id="一些典型的使用场景"><a href="#一些典型的使用场景" class="headerlink" title="一些典型的使用场景"></a>一些典型的使用场景</h1><ol><li>最新 N 个数据的操作。例如取网站的最新文章，我们可以将最新的5000条评论的id放入到 redis 的 <code>list</code> 中，并将超出链表的部分从 DB 获取（热数据缓存）。</li><li>构建队列系统。使用<code>list</code>可构建队列，使用<code>sorted set</code>可以构建优先级队列。</li><li>使用 <code>setbit</code> 记录连续登陆 7 天的用户（每天一个 key，用户登陆就把对应的位设置 1，最后将 7 天的 key 做按位 and），使用 DB 的话表大，并且要 sum，group 计算。和《编程珠玑》中的<a href="http://blog.csdn.net/yangtrees/article/details/8000653">位图排序</a>有异曲同工之妙。</li><li>使用 <code>srandommember</code> 做有放回的抽奖，<code>spop</code> 做不放回的抽奖。</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>二进制安全，也就是说 redis 的 string 可以包含任何数据，例如 jpg 图片或者序列化的对象，内部实现可以看做 byte 数组，上限为 1GB，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="type">long</span> len;</span><br><span class="line">   <span class="type">long</span> <span class="built_in">free</span>;</span><br><span class="line">   <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis 抛弃了 C 中的原生字符串，实现了动态字符串（SDS），这样做的好处：</p><ol><li>O(1) 复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数(内存重分配涉及复杂算法，并且可能执行系统调用，比较耗时)，具体实现就是使用 free 记录未使用的字节数将 buf 数组和字符串解耦</li><li>二进制安全（C字符串除了字符串的末尾不能包含空字符，这限制了 C 字符串只能保存文本）</li><li>兼容部分 C 函数（SDS 的末尾是空字符可以重用 string.h 库）</li></ol><p>通过未使用空间，SDS 实现了空间预分配（优化字符串增长，小字符串拓展采用的是拓展 2 倍长度策略，大字符串的拓展采用的是增加 1MB 的策略）和惰性空间释放 2 种优化策略。—— 可以参考 ArrayList 扩容缩容可能带来的空间震荡问题。</p><p>底层编码：int(1-10000), embstr(常见的字符串，例如 OK, ERR), raw</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>说白了就是链表（redis使用双向链表实现的List）。使用该结构可以轻松实现最新消息排行榜等功能（sina微博的timeline）。另外一个作用就是消息队列，利用<code>PUSH</code>操作将任务存在List中，然后工作线程用<code>POP</code>操作将任务取出并执行。提供了操作List某一段元素的API，可直接查询、删除List中某一段元素。</p><p>当列表包含的元素比较多或者列表中的元素都是比较长的字符串的时候，它的底层采用<em>链表</em>这种底层数据结构来实现。它是一个双端无环链表，head 和 tail 都指向 NULL，并且保存了链表长度。（它还用来实现发布订阅、慢查询、监视器等）</p><p>底层编码：ziplist, linkedlist</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>当一个哈希键包含的 k-v 比较多或者 k-v 中的元素都是比较长的字符串的时候，Redis 会使用<em>字典</em>作为哈希键的底层实现。此外 Redis 数据库本身也是基于字典的操作。</p><blockquote><p>什么情况下需要 rehash：当哈希表的负载因子（已存储的元素和哈希表总容量的比值）超过某个阈值的时候（通常情况下哈希冲突会变大）通过创建一个更大的哈希表来重新计算所有元素的哈希值并将它们插入新表的过程，rehash 的目的是为了保持哈希表的性能，避免过多的哈希冲突。</p></blockquote><p>底层编码：ziplist, hashtable</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>例如在weibo应用中，将一个用户所有关注的人存储在一个集合中，将其粉丝存在一个集合中。redis针对集合提供了方便的求交集、并集、补集等操作，可以非常方便实现共同关注、共同喜好、二度好友等功能，集合也可以存储在一个新的集合中。使用<code>SPOP</code>命令可以方便实现抽签功能（已经抽过签的人不能再次抽签），使用<code>SINTER</code>可以方便实现张三选了课，李四选了课，求张三和李四的公共选课这样的需求。</p><p>底层编码：intset, hashtable</p><h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>有序集将Set中的元素增加了一个权重参数score，使得集合中的元素能够按照score进行升序排列，例如一个存储全班成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候就已经进行了天然的排序（游戏用户得分排行榜）。另外还可以使用有序集来做带权重的队列，例如普通消息的score为1，重要消息的score为2，然后工作线程可以按照score的逆序来获取工作任务。让重要的任务先执行。</p><p>底层编码：ziplist, skiplist</p><h1 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a>事务和锁</h1><p>Redis 中的事务需要和数据库中的事务有区别，它的原子性是相对的（轻量级事务），因为一个事务中如果有一条命令执行失败，其后的命令仍然会被继续执行，lua 脚本也存在这个问题。它是将命令放到队列中，是没有<em>回滚</em>概念的，它是 DISCARD。</p><p>提供了 Watch 功能，对 key 进行 watch，然后再执行 transaction（<code>multi</code>,<code>exec</code>），在这个过程中，如果这个 watched 的 key 被修改，那么这个 transaction 会发现并拒绝执行（返回 <code>nil</code>）。例如：以下的命令在多客户端连接的时候可能出现数据一致性问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> age 10</span><br><span class="line">incr age</span><br><span class="line">incr age <span class="comment"># 此时有一个客户端进行get age，将得到11</span></span><br><span class="line">get age</span><br></pre></td></tr></table></figure><p>以上的命令打包成一个原子操作即可解决。使用 watch 可以实现乐观锁。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>rename-command CONFIG &quot;&quot;</code>,命令重命名，在共享环境下可以重命名相对危险的命令，例如把<code>CONFIG</code>重命名为一个不容易猜测的字符。<code>rename-command CONFIG dsfd8324kndskdksfjdfdsjnfdsdfjsl</code>，如果想要删除这个别名直接重命名为空字符串即可。 </p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><ul><li>RDB，默认为 dump.rdb，内存快照，<code>SAVE</code> 和 <code>BGSAVE</code> 命令, SAVE 会阻塞当前进程，而 BGSAVE 会 fork 出子进程进行处理。</li><li>AOF，(append only file)记录每一次操作，生成日志文件,更加精细的持久化方案(文件更大)。当我们对一个 key 进行反复操作时，就会产生多条记录，AOF 重写指的是在某一瞬间将内存中的数据<em>直接逆化</em>到文件中(<code>BGREWRITEAOF</code>命令)。</li><li>混合持久化：Redis 4.0 之后新增的方式。混合持久化结合了 RDB 和 AOF 的优点，在写入的时候，先把当前数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启的速度，又能降低数据丢失。</li></ul><p><em>如果AOF和RDB同时存在，将会优先加载 AOF</em>, 因为它能更精确恢复到最新状态，这 2 种方式可同时配置。</p><p><code>appendfsync</code> 选项的不同值(always, everysec, no)对 AOF 持久化的安全性以及性能有非常大的影响。</p><p>虽然 Redis 将生成新 AOF 文件替换旧 AOF 文件的功能命名为 “AOF 文件重写”，但是实际上， AOF 文件重写<em>不需要对现有的 AOF 文件进行任何访问</em>，这个功能是通过<em>直接读取数据库状态</em>来实现的。例如：对服务器进行了以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list <span class="string">&quot;A&quot;</span> <span class="string">&quot;B&quot;</span> // [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]</span><br><span class="line">RPUSH list <span class="string">&quot;C&quot;</span> // [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line">RPUSH list <span class="string">&quot;D&quot;</span> <span class="string">&quot;E&quot;</span> // [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line">LPOP list // [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line">LPOP list // [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>]</span><br><span class="line">RPUSH list <span class="string">&quot;F&quot;</span> <span class="string">&quot;G&quot;</span> // [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>]</span><br></pre></td></tr></table></figure><p>服务器为了保存 list 键的状态，必须在 AOF 文件中写入 6 条命令。如果想用尽量少的命令来记录 list 键的状态，那么最简单高效的方法是直接从数据库中读取 list 键的值，使用 <code>RPUSH list &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot;</code> 1 条命令来替代的 6 条命令。</p><blockquote><p>在实际中，为了避免执行命令的时候导致客户端缓冲区溢出，重写程序在处理 list，hash，set，zset 这 4 种可能会带有多个元素的键的时候，会检查键中所包含的元素个数，如果数量太多的时候（REDIS_AOF_REWRITE_ITEMS_PER_CMD, 64）会使用多条命令而不是使用单一命令。</p></blockquote><h2 id="使用子进程重写-AOF"><a href="#使用子进程重写-AOF" class="headerlink" title="使用子进程重写 AOF"></a>使用子进程重写 AOF</h2><p>Redis 使用子进程处理 AOF 重写，这样做的目的：</p><ol><li>子进程重写 AOF 期间，服务器进程（父进程）可以继续处理命令请求</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下避免竞争条件。</li></ol><p>这样带来了一个问题：在子进程重写 AOF 文件期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据进行修改，这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。解决方案：引入 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</p><p>当子进程完成 AOF 重写之后，会向父进程发送一个信号，父进程收到该信号之后，会调用一个信号处理函数，执行以下工作：</p><ol><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中, 此时新 AOF 文件保存的数据库状态和当前服务器一致</li><li>对新的 AOF 文件进行改名，原子地覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。在整个 BGREWRITEAOF 中，只有信号处理函数会对服务器进程进行阻塞，将 AOF 重写对服务器性能的影响降到最低。</p><h2 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a>如何选择合适的持久化方式</h2><p>AOF 日志文件的命令通过非常可读的方式进行记录，这个特性<strong>非常适合做灾难性的误删除的紧急恢复</strong>。比如某人不小心用 flushall 命令清空了所有数据，只要这个时候后台 rewrite 还没有发生，那么就可以立即拷贝 AOF 文件，将最后一条 flushall 命令给删了，然后再将该 AOF 文件放回去，就可以通过恢复机制，自动恢复所有数据。redis 为了避免 AOF 文件过大的问题，会对 AOF 文件进行 rewrite，rewrite 的时候是直接<strong>基于当前内存中的数据进行指令的重新构建</strong>，而不是基于旧的指令日志进行 merge，这样鲁棒性会好很多。</p><p>redis需要同时开启AOF和RDB。用AOF来保证数据不丢失，作为数据恢复的第一选择；而使用RDB来做不同程度的冷备，在AOF问你见你都丢失或者损坏不可用的时候还可以使用RDB来进行快速的数据恢复。</p><h1 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h1><p>定期删除 + 惰性删除。</p><p>所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><p>假设 redis 里放了 10w 个 key，都设置了过期时间，你每隔几百毫秒，就检查 10w 个 key，那 redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。注意，这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。</p><p>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？所以就是惰性删除了。这就是说，在你获取某个 key 的时候，redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p><p>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</p><p>答案是：走内存淘汰机制（比如最常用的是allkeys-lru）。</p><h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><p>服务器处理下面的 2 类事件：</p><ol><li>file event: 服务器对套接字操作的抽象。文件事件处理器是基于 Reactor 模式实现的网络通信程序。</li><li>time event: 处理需要周期性的操作，例如 serverCron 函数。</li></ol><blockquote><p>Reactor 模式是一种高效的事件处理模式，通过事件驱动和职责分离的设计，能够很好地支持高并发场景。它的核心思想是将事件的监听、分发和处理分离，利用 I&#x2F;O 多路复用技术实现非阻塞的事件处理。</p></blockquote><p>serverCron 函数的职责：</p><ol><li>更新服务器的各类统计信息，例如：时间、内存占用</li><li>更新 DB 中的过期键值对</li><li>关闭清理连接失效的客户端</li><li>尝试进行 AOF 或者 RDB 持久化</li><li>如果服务器是从服务器，对从服务器进行定期同步</li><li>如果处于集群模式，对集群进行定期同步和连接测试</li></ol><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redis-event-loop.png" alt="Redis 事件循环"></p><p>因为文件事件是随机出现的，如果等待并处理一次文件事件之后，仍然没有任何时间事件到达，那么服务器将再次等待并处理文件事件。随着文件事件的不断执行，事件会逐渐向事件事件所设置的到达时间逼近，并最终来到到达时间，这个时候服务器就可以开始处理到达的时间事件了。文件事件和时间事件的处理都是<strong>同步、有序、原子</strong>地执行的，服务器不会中断事件处理，也不会对事件进行抢占。因此，无论是文件事件的处理器还是时间事件的处理器，它们都会尽可能减少程序的阻塞时间，并在有需要的时候主动让出执行权，从而降低事件饥饿的可能性。例如，在命令回复处理器将一个命令回复写入到客户端套接字的时候，如果写入字节数超过了一个预设常量的话，命令回复处理器就会主动用 break 跳出写入循环，将余下的数据留到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子线程或者子进程执行。因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的处理时间通常会比设定的时间稍微晚一点。</p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>从网络拓扑上有下面的两种架构，一种是传统的星型结构，另一种是线性结构。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redis-master-slave-arch.png" alt="redis主从复制架构"></p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/redis-master-salve.png" alt="redis主从复制原理"></p><p>以 6379 为 master 节点，6380 和 6381 为slave节点(需要配置 slaveof)。</p><p>现在 master down 掉，设置 6380 为新的 master（<code>SLAVEOF no one</code>;<code>CONFIG SET slave-read-only no</code>），6381 作为 6380 的 slave(<code>SLAVEOF 127.0.0.1 6380</code>)。我们可以使用 redis 自带的<a href="https://segmentfault.com/a/1190000002680804">sentinel</a>自动完成上述操作。</p><h2 id="如何实现复制功能"><a href="#如何实现复制功能" class="headerlink" title="如何实现复制功能"></a>如何实现复制功能</h2><p>旧版本复制功能分为 2 步：同步(sync) 和命令传播(command propagate)。</p><ol><li>同步：将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>命令传播：当主服务器的数据库状态发生变更的时候导致从服务器的数据库状态不一致的时候，让从服务器重回一致性。</li></ol><p>当客户端向从服务器发送 <code>SLAVEOF</code> 命令要求从服务器复制主服务器状态的时候，从服务器首先需要进行同步操作（通过向主服务器发送 <code>SYNC</code> 命令来完成）：</p><ol><li>slave 向 master 发送 SYNC 命令</li><li>master 收到 SYNC 命令后执行 BGSAVE，在后台生成 RDB，并且使用一个缓冲区记录从现在开始的所有写命令</li><li>当 master 完成 RDB 生成之后，master 将自己生成的 RDB 文件发送给 slave，salve 会载入这个 RDB, 将数据库状态更新到 master BGSAVE 时的状态</li><li>master 将缓冲区记录的写命令发送给 slave，slave 会接收并执行这些写命令，更新 slave 的数据库状态。</li></ol><p>存在问题：每次 slave 断开后（无论是主动断开还是由于网络故障被动断开）再连接 master 需要重新同步（昂贵操作，生成 rdb，载入 rdb，CPU,内存，网路带宽，阻塞），即：同步的过程需要重新执行一遍。所以一定要记住：多台 slave 不要一下子都启动起来，否则 master 可能 IO 飙升。</p><p>从 Redis 2.8 开始使用 PSYNC 代替 SYNC 执行同步操作。SYNC 提供完整重同步和部分重同步。其中的部分重同步能很好处理断线的问题：当 slave 在断线重连后，如果条件允许，master 可以将断开连接期间执行的写命令发送给 slave，slave 只要接收并执行这些写命令就可以将 DB 更新到 master 的当前状态。</p><p>部分重同步实现原理：</p><ol><li><p>master 和 slave 分别维护有复制偏移量(replication offset)</p></li><li><p>master 有复制积压缓冲区（replication backlog），定长的 FIFO, 保存最近进行传播的写命令。</p></li><li><p>服务器 run ID：用于区分重新连接的主服务器是否断线之前的主服务器。</p></li><li><p>master 向 slave 传播 N 字节的时候将自己的复制偏移量加上 N</p></li><li><p>slave 收到 master 传播过来的 N 字节的时候将自己的复制偏移量加上 N</p></li></ol><p>当 master 和 slave 处于一致的时候，复制偏移量是一样的。不一致的时候，master 在进行 PSYNC 的时候，如果还能在自己的 replication backlog 中找到最近的写命令就进行部分重同步，否则进行完整重同步。</p><p>在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。</p><h2 id="如何实现-redis-的高可用和高并发"><a href="#如何实现-redis-的高可用和高并发" class="headerlink" title="如何实现 redis 的高可用和高并发"></a>如何实现 redis 的高可用和高并发</h2><p>redis 实现高并发主要依靠<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万 QPS，多从用来查询数据，多个从实例可以提供每秒 10w 的 QPS。</p><p>如果想要在实现高并发的同时，容纳大量的数据，那么就需要 redis 集群，使用 redis 集群之后，可以提供每秒几十万的读写并发。</p><p>redis 高可用，如果是做主从架构部署，那么加上哨兵就可以了，就可以实现，任何一个实例宕机，可以进行主备切换。</p><h3 id="redis主从架构实现高并发"><a href="#redis主从架构实现高并发" class="headerlink" title="redis主从架构实现高并发"></a>redis主从架构实现高并发</h3><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p><p>redis 采用异步方式复制数据到 slave 节点.注意，如果采用了主从架构，那么建议<strong>必须开启 master node 的持久化</strong>，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能<strong>确保启动的时候，是有数据的</strong>，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。</p><p>redis的主从复制支持断点续传、无磁盘化复制（master在内存中创建RDB发送给slave），对于过期key的处理是master过期了key或者LRU淘汰了一个key，那么会模拟一条del命令发送给salve。</p><h3 id="基于哨兵集群的高可用"><a href="#基于哨兵集群的高可用" class="headerlink" title="基于哨兵集群的高可用"></a>基于哨兵集群的高可用</h3><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ul><p>相比于节点取余和一致性哈希能做到没有任何数据丢失，并且在整个的数据迁移过程中能达到客户端无痛的效果,集群伸缩就是槽和数据在节点之间的移动。</p><p>在 master 节点上执行 <code>cluster meet slaveIp slavePort</code> 可以将 slave 孤立节点添加到 master 节点所在的集群里面。在任意节点上执行 <code>cluster nodes</code> 可以查看集群信息。从 5.0 推荐使用 <code>redis --cluster</code> 来进行集群管理。使用 <code>cluster slots</code> 可以查看 redis 集群的槽分配信息。</p><p>Redis 集群推荐使用直连的方式而不是使用增加一层中间代理的方式，这样可以减少一次网络开销。智能客户端需要自己处理 MOVED 和 ASK 异常。</p><h4 id="哨兵核心知识"><a href="#哨兵核心知识" class="headerlink" title="哨兵核心知识"></a>哨兵核心知识</h4><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是<em>不保证数据零丢失</em>的，只能保证 redis 集群的高可用性。</li><li>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul><h1 id="运维常用命令"><a href="#运维常用命令" class="headerlink" title="运维常用命令"></a>运维常用命令</h1><p><code>dbsize</code>查看有多少个键; <code>config get/config set</code> 查看或者设置redis的配置; <code>SLOWLOG get</code>查看慢日志。</p><blockquote><p>如果不小心运行了<code>flushall</code>命令清空了redis中的数据怎么办？必须马上运行<code>shutdown nosave</code>命令，然后编辑 AOF 文件，删除掉最后一条命令(<code>flushall</code>),因为别的进程可能向 redis 中写入数据导致 AOF 重写了，重写后的 AOF 被清空了。复制 rdb 文件需要在 redis 进程处于杀掉状态的时候进行，进程处于活动状态的时候复制的是<em>同样的句柄</em>。</p></blockquote><p>redis 数据迁移只需要 dump 出 rdb，然后从此文件恢复即可。</p><h1 id="redis5-0新特性"><a href="#redis5-0新特性" class="headerlink" title="redis5.0新特性"></a>redis5.0新特性</h1><h2 id="Stream数据类型"><a href="#Stream数据类型" class="headerlink" title="Stream数据类型"></a>Stream数据类型</h2><p>本质是抽象日志，基于时间序列的数据。物联网，各种传感器产生的时间序列数据，定位未来。</p><p><a href="https://mp.weixin.qq.com/s/rjTt0HMNCk9VO5x5Mi_c-w">redis5.0之stream尝鲜</a></p><h2 id="Timers-Cluster-API"><a href="#Timers-Cluster-API" class="headerlink" title="Timers &amp; Cluster API"></a>Timers &amp; Cluster API</h2><h2 id="RDB现在存储LFU和LRU信息"><a href="#RDB现在存储LFU和LRU信息" class="headerlink" title="RDB现在存储LFU和LRU信息"></a>RDB现在存储LFU和LRU信息</h2><h2 id="集群管理器从Ruby-redis-trib-rb-移植到C"><a href="#集群管理器从Ruby-redis-trib-rb-移植到C" class="headerlink" title="集群管理器从Ruby(redis-trib.rb)移植到C"></a>集群管理器从Ruby(redis-trib.rb)移植到C</h2><blockquote><p>集群限制：key 批量操作支持有限，例如 mget, mset 必须在一个 slot。</p></blockquote><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>集群创建不用先安装ruby。配置3主3从的redis集群：端口范围是5001~5006</p><p>redis5001.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 5001</span><br><span class="line">pidfile /usr/local/var/run/redis5001.pid</span><br><span class="line">logfile /tmp/logs/redis/redis-server5001.<span class="built_in">log</span></span><br><span class="line">cluster-config-file redis5001.conf</span><br></pre></td></tr></table></figure><p>其他配置文件类似。使用6个配置文件启动redis。可以使用<code>redis-cli --cluster help</code>命令查看帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群,主从比例为1:1</span></span><br><span class="line">➜  redis-cluster redis-cli --cluster create 127.0.0.1:5001 127.0.0.1:5002 127.0.0.1:5003 127.0.0.1:5004 127.0.0.1:5005 127.0.0.1:5006 --cluster-replicas 1</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 127.0.0.1:5004 to 127.0.0.1:5001</span><br><span class="line">Adding replica 127.0.0.1:5005 to 127.0.0.1:5002</span><br><span class="line">Adding replica 127.0.0.1:5006 to 127.0.0.1:5003</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span><br><span class="line">[WARNING] Some slaves are <span class="keyword">in</span> the same host as their master</span><br><span class="line">M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004</span><br><span class="line">   replicates a118aa98313f9d7bb3799ad942f3a69489e55e89</span><br><span class="line">S: 51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005</span><br><span class="line">   replicates 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">S: f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006</span><br><span class="line">   replicates 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span></span><br><span class="line">....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:5001)</span><br><span class="line">M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">S: 2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a118aa98313f9d7bb3799ad942f3a69489e55e89</span><br><span class="line">M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>从上面的信息可以看出16384个slots几乎平均分配给了3个master节点，3个slave节点是没有slots的，分别和对应的主节点的数据是一致的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli -c -p 5001</span><br><span class="line">127.0.0.1:5001&gt; <span class="built_in">set</span> a 1</span><br><span class="line">-&gt; Redirected to slot [15495] located at 127.0.0.1:5003</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:5003&gt; get a</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:5003&gt; <span class="built_in">set</span> b 2</span><br><span class="line">-&gt; Redirected to slot [3300] located at 127.0.0.1:5001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:5001&gt; get b</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:5001&gt; keys *</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 当前连接到了5001端口，这个服务器上只存放了b的key</span></span><br><span class="line">127.0.0.1:5001&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:469</span><br><span class="line">cluster_stats_messages_pong_sent:463</span><br><span class="line">cluster_stats_messages_sent:932</span><br><span class="line">cluster_stats_messages_ping_received:458</span><br><span class="line">cluster_stats_messages_pong_received:469</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:932</span><br><span class="line">127.0.0.1:5001&gt; CLUSTER NODES</span><br><span class="line">51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005@15005 slave 6592afc22ce09055b713a049c594445ecdf9246c 0 1550143239486 5 connected</span><br><span class="line">965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003@15003 master - 0 1550143238000 3 connected 10923-16383</span><br><span class="line">a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001@15001 myself,master - 0 1550143237000 1 connected 0-5460</span><br><span class="line">f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006@15006 slave 965e863a346c5c0558623313bbc4b9124a7707ee 0 1550143240496 6 connected</span><br><span class="line">2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004@15004 slave a118aa98313f9d7bb3799ad942f3a69489e55e89 0 1550143240000 4 connected</span><br><span class="line">6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002@15002 master - 0 1550143240000 2 connected 5461-10922</span><br></pre></td></tr></table></figure><h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>创建2个配置文件5007和5008并启动服务器。</p><h4 id="添加主节点5007"><a href="#添加主节点5007" class="headerlink" title="添加主节点5007"></a>添加主节点5007</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli --cluster add-node 127.0.0.1:5007 127.0.0.1:5001</span><br><span class="line">&gt;&gt;&gt; Adding node 127.0.0.1:5007 to cluster 127.0.0.1:5001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:5001)</span><br><span class="line">M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">S: 2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a118aa98313f9d7bb3799ad942f3a69489e55e89</span><br><span class="line">M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:5007 to make it <span class="built_in">join</span> the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:5001&gt; CLUSTER NODES</span><br><span class="line">51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005@15005 slave 6592afc22ce09055b713a049c594445ecdf9246c 0 1550143794065 5 connected</span><br><span class="line">965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003@15003 master - 0 1550143797086 3 connected 10923-16383</span><br><span class="line">a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001@15001 myself,master - 0 1550143797000 1 connected 0-5460</span><br><span class="line">f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006@15006 slave 965e863a346c5c0558623313bbc4b9124a7707ee 0 1550143795000 6 connected</span><br><span class="line">32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007@15007 master - 0 1550143795071 0 connected</span><br><span class="line">2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004@15004 slave a118aa98313f9d7bb3799ad942f3a69489e55e89 0 1550143796079 4 connected</span><br><span class="line">6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002@15002 master - 0 1550143798092 2 connected 5461-10922</span><br></pre></td></tr></table></figure><p>新添加的5007节点作为了master节点，但是还没有slots，暂时还不能存储数据，需要进行<em>分片</em>的操作将其他master节点的slots分一些给5007节点均衡一下存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli --cluster reshard 127.0.0.1:5007</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:5007)</span><br><span class="line">M: 32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a118aa98313f9d7bb3799ad942f3a69489e55e89</span><br><span class="line">M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">S: f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 500</span><br><span class="line">What is the receiving node ID? 32a4a4886b43f7005c265b3b5813fea2fe578541 <span class="comment"># 输入5007的id</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: all</span></span><br><span class="line"></span><br><span class="line">Ready to move 500 slots.</span><br><span class="line">  Source nodes:</span><br><span class="line">    M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">       slots:[0-5460] (5461 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">    M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">       slots:[5461-10922] (5462 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">    M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">       slots:[10923-16383] (5461 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">  Destination node:</span><br><span class="line">    M: 32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007</span><br><span class="line">       slots: (0 slots) master</span><br><span class="line">  Resharding plan:</span><br><span class="line">    Moving slot 5461 from 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">    Moving slot 11088 from 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">Do you want to proceed with the proposed reshard plan (<span class="built_in">yes</span>/no)? <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h4 id="添加从节点5008"><a href="#添加从节点5008" class="headerlink" title="添加从节点5008"></a>添加从节点5008</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cluster redis-cli --cluster add-node 127.0.0.1:5008 127.0.0.1:5001</span><br></pre></td></tr></table></figure><p>上面的操作将5008添加为了master节点（可以使用客户端连上使用CLUSTER NODES查看），需要设置其变为从节点:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli -c -p 5008</span><br><span class="line">127.0.0.1:5008&gt; CLUSTER NODES</span><br><span class="line">965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003@15003 master - 0 1550144560000 3 connected 11089-16383</span><br><span class="line">32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007@15007 master - 0 1550144562933 7 connected 0-165 5461-5627 10923-11088</span><br><span class="line">f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006@15006 slave 965e863a346c5c0558623313bbc4b9124a7707ee 0 1550144560914 3 connected</span><br><span class="line">a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001@15001 master - 0 1550144561920 1 connected 166-5460</span><br><span class="line">aafdcb6b443c9449ca0131562e1ee516f2f6a6e4 127.0.0.1:5008@15008 myself,master - 0 1550144559000 0 connected</span><br><span class="line">51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005@15005 slave 6592afc22ce09055b713a049c594445ecdf9246c 0 1550144561000 2 connected</span><br><span class="line">6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002@15002 master - 0 1550144560000 2 connected 5628-10922</span><br><span class="line">2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004@15004 slave a118aa98313f9d7bb3799ad942f3a69489e55e89 0 1550144559903 1 connected</span><br><span class="line">127.0.0.1:5008&gt; CLUSTER REPLICATE 32a4a4886b43f7005c265b3b5813fea2fe578541</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:5008&gt; CLUSTER NODES</span><br><span class="line">965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003@15003 master - 0 1550144580000 3 connected 11089-16383</span><br><span class="line">32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007@15007 master - 0 1550144579000 7 connected 0-165 5461-5627 10923-11088</span><br><span class="line">f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006@15006 slave 965e863a346c5c0558623313bbc4b9124a7707ee 0 1550144579000 3 connected</span><br><span class="line">a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001@15001 master - 0 1550144582129 1 connected 166-5460</span><br><span class="line">aafdcb6b443c9449ca0131562e1ee516f2f6a6e4 127.0.0.1:5008@15008 myself,slave 32a4a4886b43f7005c265b3b5813fea2fe578541 0 1550144578000 0 connected</span><br><span class="line">51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005@15005 slave 6592afc22ce09055b713a049c594445ecdf9246c 0 1550144581114 2 connected</span><br><span class="line">6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002@15002 master - 0 1550144580104 2 connected 5628-10922</span><br><span class="line">2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004@15004 slave a118aa98313f9d7bb3799ad942f3a69489e55e89 0 1550144581000 1 connected</span><br><span class="line">127.0.0.1:5008&gt;</span><br></pre></td></tr></table></figure><h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><h4 id="删除从节点"><a href="#删除从节点" class="headerlink" title="删除从节点"></a>删除从节点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:5008 aafdcb6b443c9449ca0131562e1ee516f2f6a6e4</span><br></pre></td></tr></table></figure><h4 id="删除主节点"><a href="#删除主节点" class="headerlink" title="删除主节点"></a>删除主节点</h4><p>删除主节点之前要先进行分片，将slots中的数据分配给集群中的其他master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli --cluster reshard 127.0.0.1:5007</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:5007)</span><br><span class="line">M: 32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007</span><br><span class="line">   slots:[0-165],[5461-5627],[10923-11088] (499 slots) master</span><br><span class="line">M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">   slots:[166-5460] (5295 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002</span><br><span class="line">   slots:[5628-10922] (5295 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates a118aa98313f9d7bb3799ad942f3a69489e55e89</span><br><span class="line">M: 965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003</span><br><span class="line">   slots:[11089-16383] (5295 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 6592afc22ce09055b713a049c594445ecdf9246c</span><br><span class="line">S: f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 965e863a346c5c0558623313bbc4b9124a7707ee</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 500 <span class="comment"># 因为扩容的时候分配了500个</span></span><br><span class="line">What is the receiving node ID? a118aa98313f9d7bb3799ad942f3a69489e55e89 <span class="comment"># 随机挑选一个master节点，此处为node1</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: 32a4a4886b43f7005c265b3b5813fea2fe578541 # 5007的id</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"></span><br><span class="line">Ready to move 500 slots.</span><br><span class="line">  Source nodes:</span><br><span class="line">    M: 32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007</span><br><span class="line">       slots:[0-165],[5461-5627],[10923-11088] (499 slots) master</span><br><span class="line">  Destination node:</span><br><span class="line">    M: a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001</span><br><span class="line">       slots:[166-5460] (5295 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">  Resharding plan:</span><br><span class="line">    Moving slot 0 from 32a4a4886b43f7005c265b3b5813fea2fe578541</span><br><span class="line">    Moving slot 1 from 32a4a4886b43f7005c265b3b5813fea2fe578541</span><br><span class="line">    Moving slot 11088 from 32a4a4886b43f7005c265b3b5813fea2fe578541</span><br><span class="line">Do you want to proceed with the proposed reshard plan (<span class="built_in">yes</span>/no)? <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  redis-cluster redis-cli -c -p 5001</span><br><span class="line">127.0.0.1:5001&gt; CLUSTER NODES</span><br><span class="line">51c8959f1b428fe9e21b634800bf1da80b2d97e7 127.0.0.1:5005@15005 slave 6592afc22ce09055b713a049c594445ecdf9246c 0 1550145060000 5 connected</span><br><span class="line">965e863a346c5c0558623313bbc4b9124a7707ee 127.0.0.1:5003@15003 master - 0 1550145058000 3 connected 11089-16383</span><br><span class="line">a118aa98313f9d7bb3799ad942f3a69489e55e89 127.0.0.1:5001@15001 myself,master - 0 1550145061000 8 connected 0-5627 10923-11088</span><br><span class="line">f0ba58939c6ae6de4e178e7f7070c78ed19d376d 127.0.0.1:5006@15006 slave 965e863a346c5c0558623313bbc4b9124a7707ee 0 1550145061000 6 connected</span><br><span class="line">32a4a4886b43f7005c265b3b5813fea2fe578541 127.0.0.1:5007@15007 master - 0 1550145061643 7 connected</span><br><span class="line">2c06122ac54a7cf34027d1248a6b89df4e74ff0d 127.0.0.1:5004@15004 slave a118aa98313f9d7bb3799ad942f3a69489e55e89 0 1550145062000 8 connected</span><br><span class="line">6592afc22ce09055b713a049c594445ecdf9246c 127.0.0.1:5002@15002 master - 0 1550145062649 2 connected 5628-10922</span><br></pre></td></tr></table></figure><p>5007的slots已经分配给了别人！最后从集群中移除5007</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:5007 32a4a4886b43f7005c265b3b5813fea2fe578541</span><br></pre></td></tr></table></figure><h2 id="新的sorted-set命令zpopmin-max和阻塞变种"><a href="#新的sorted-set命令zpopmin-max和阻塞变种" class="headerlink" title="新的sorted set命令zpopmin&#x2F;max和阻塞变种"></a>新的sorted set命令zpopmin&#x2F;max和阻塞变种</h2><p>取出集合中分值最大和最小的元素。</p><h2 id="主动碎片整理V2-更好的内存统计报告"><a href="#主动碎片整理V2-更好的内存统计报告" class="headerlink" title="主动碎片整理V2 &amp; 更好的内存统计报告"></a>主动碎片整理V2 &amp; 更好的内存统计报告</h2><p>当删除一个key的时候，redis并不会立即回收内存空间。如果反复进行增删键值，内存中将产生大量碎片，这就会影响到之后申请大块连续的内存，所以有必要对内存碎片进行整理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速产生测试数据</span></span><br><span class="line">127.0.0.1:6379&gt; DEBUG populate  300000 abc 1000</span><br><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:326834704</span><br><span class="line">used_memory_human:311.69M</span><br><span class="line">used_memory_rss:317788160</span><br><span class="line">used_memory_rss_human:303.07M</span><br><span class="line">used_memory_peak:331743840</span><br><span class="line">used_memory_peak_human:316.38M</span><br><span class="line">used_memory_peak_perc:98.52%</span><br><span class="line">used_memory_overhead:17232110</span><br><span class="line">used_memory_startup:988032</span><br><span class="line">used_memory_dataset:309602594</span><br><span class="line">used_memory_dataset_perc:95.01%</span><br><span class="line">allocator_allocated:326801360</span><br><span class="line">allocator_active:317750272</span><br><span class="line">allocator_resident:317750272</span><br><span class="line">total_system_memory:8589934592</span><br><span class="line">total_system_memory_human:8.00G</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line">allocator_frag_ratio:0.97</span><br><span class="line">allocator_frag_bytes:18446744073700500528</span><br><span class="line">allocator_rss_ratio:1.00</span><br><span class="line">allocator_rss_bytes:0</span><br><span class="line">rss_overhead_ratio:1.00</span><br><span class="line">rss_overhead_bytes:37888</span><br><span class="line">mem_fragmentation_ratio:0.97</span><br><span class="line">mem_fragmentation_bytes:-9013200</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:49694</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line">mem_allocator:libc</span><br><span class="line">active_defrag_running:0</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure><p>上述used_memory_human:311.69M，而used_memory_rss_human:303.07M，rss比used还小，这种情况比较糟糕，redis服务器的内存可能被OS换到了交换空间中了，相反如果used小很多的话可能有大量内存碎片；还可以查看<code>mem_fragmentation_ratio</code>，这个参数大于1是比较理想的情况，如果这个只为几十或者几百也表示有大量内存碎片。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MEMORY STATS</span><br><span class="line"> 1) <span class="string">&quot;peak.allocated&quot;</span> <span class="comment"># 最大内存</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 331743840 </span><br><span class="line"> 3) <span class="string">&quot;total.allocated&quot;</span> <span class="comment"># 当前已使用的内存</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 326834688</span><br><span class="line"> 5) <span class="string">&quot;startup.allocated&quot;</span> <span class="comment"># 服务启动初始化之后的内存</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 988032</span><br><span class="line"> 7) <span class="string">&quot;replication.backlog&quot;</span> <span class="comment"># 主从复制中backlog占用</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 0</span><br><span class="line"> 9) <span class="string">&quot;clients.slaves&quot;</span></span><br><span class="line">10) (<span class="built_in">integer</span>) 0</span><br><span class="line">11) <span class="string">&quot;clients.normal&quot;</span></span><br><span class="line">12) (<span class="built_in">integer</span>) 49694</span><br><span class="line">13) <span class="string">&quot;aof.buffer&quot;</span></span><br><span class="line">14) (<span class="built_in">integer</span>) 0</span><br><span class="line">15) <span class="string">&quot;lua.caches&quot;</span></span><br><span class="line">16) (<span class="built_in">integer</span>) 0</span><br><span class="line">17) <span class="string">&quot;db.0&quot;</span></span><br><span class="line">18) 1) <span class="string">&quot;overhead.hashtable.main&quot;</span></span><br><span class="line">    2) (<span class="built_in">integer</span>) 16194384</span><br><span class="line">    3) <span class="string">&quot;overhead.hashtable.expires&quot;</span></span><br><span class="line">    4) (<span class="built_in">integer</span>) 0</span><br><span class="line">19) <span class="string">&quot;overhead.total&quot;</span></span><br><span class="line">20) (<span class="built_in">integer</span>) 17232110</span><br><span class="line">21) <span class="string">&quot;keys.count&quot;</span></span><br><span class="line">22) (<span class="built_in">integer</span>) 300002</span><br><span class="line">23) <span class="string">&quot;keys.bytes-per-key&quot;</span></span><br><span class="line">24) (<span class="built_in">integer</span>) 1086</span><br><span class="line">25) <span class="string">&quot;dataset.bytes&quot;</span></span><br><span class="line">26) (<span class="built_in">integer</span>) 309602578</span><br><span class="line">27) <span class="string">&quot;dataset.percentage&quot;</span></span><br><span class="line">28) <span class="string">&quot;95.014816284179688&quot;</span></span><br><span class="line">29) <span class="string">&quot;peak.percentage&quot;</span></span><br><span class="line">30) <span class="string">&quot;98.520195007324219&quot;</span></span><br><span class="line">31) <span class="string">&quot;allocator.allocated&quot;</span></span><br><span class="line">32) (<span class="built_in">integer</span>) 326801360</span><br><span class="line">33) <span class="string">&quot;allocator.active&quot;</span></span><br><span class="line">34) (<span class="built_in">integer</span>) 312306688</span><br><span class="line">35) <span class="string">&quot;allocator.resident&quot;</span></span><br><span class="line">36) (<span class="built_in">integer</span>) 312306688</span><br><span class="line">37) <span class="string">&quot;allocator-fragmentation.ratio&quot;</span></span><br><span class="line">38) <span class="string">&quot;0.95564687252044678&quot;</span></span><br><span class="line">39) <span class="string">&quot;allocator-fragmentation.bytes&quot;</span></span><br><span class="line">40) (<span class="built_in">integer</span>) -14494672</span><br><span class="line">41) <span class="string">&quot;allocator-rss.ratio&quot;</span></span><br><span class="line">42) <span class="string">&quot;1&quot;</span></span><br><span class="line">43) <span class="string">&quot;allocator-rss.bytes&quot;</span></span><br><span class="line">44) (<span class="built_in">integer</span>) 0</span><br><span class="line">45) <span class="string">&quot;rss-overhead.ratio&quot;</span></span><br><span class="line">46) <span class="string">&quot;1.0001213550567627&quot;</span></span><br><span class="line">47) <span class="string">&quot;rss-overhead.bytes&quot;</span></span><br><span class="line">48) (<span class="built_in">integer</span>) 37888</span><br><span class="line">49) <span class="string">&quot;fragmentation&quot;</span></span><br><span class="line">50) <span class="string">&quot;0.95576280355453491&quot;</span></span><br><span class="line">51) <span class="string">&quot;fragmentation.bytes&quot;</span></span><br><span class="line">52) (<span class="built_in">integer</span>) -14456784</span><br><span class="line"><span class="comment"># 查看单个键占用的内存</span></span><br><span class="line">127.0.0.1:6379&gt; MEMORY USAGE abc:2</span><br><span class="line">(<span class="built_in">integer</span>) 1053</span><br></pre></td></tr></table></figure><h2 id="许多带有子命令的命令现在都有一个HELP子命令"><a href="#许多带有子命令的命令现在都有一个HELP子命令" class="headerlink" title="许多带有子命令的命令现在都有一个HELP子命令"></a>许多带有子命令的命令现在都有一个HELP子命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XINFO <span class="built_in">help</span></span><br><span class="line">1) XINFO &lt;subcommand&gt; arg arg ... arg. Subcommands are:</span><br><span class="line">2) CONSUMERS &lt;key&gt; &lt;groupname&gt;  -- Show consumer <span class="built_in">groups</span> of group &lt;groupname&gt;.</span><br><span class="line">3) GROUPS &lt;key&gt;                 -- Show the stream consumer <span class="built_in">groups</span>.</span><br><span class="line">4) STREAM &lt;key&gt;                 -- Show information about the stream.</span><br><span class="line">5) HELP                         -- Print this <span class="built_in">help</span>.</span><br><span class="line">127.0.0.1:6379&gt; XINFO CONSUMERS codehole cg1</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;c1&quot;</span></span><br><span class="line">   3) <span class="string">&quot;pending&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 2</span><br><span class="line">   5) <span class="string">&quot;idle&quot;</span></span><br><span class="line">   6) (<span class="built_in">integer</span>) 675253</span><br><span class="line">127.0.0.1:6379&gt; XINFO STREAM codehole</span><br><span class="line"> 1) <span class="string">&quot;length&quot;</span></span><br><span class="line"> 2) (<span class="built_in">integer</span>) 3</span><br><span class="line"> 3) <span class="string">&quot;radix-tree-keys&quot;</span></span><br><span class="line"> 4) (<span class="built_in">integer</span>) 1</span><br><span class="line"> 5) <span class="string">&quot;radix-tree-nodes&quot;</span></span><br><span class="line"> 6) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 7) <span class="string">&quot;groups&quot;</span></span><br><span class="line"> 8) (<span class="built_in">integer</span>) 2</span><br><span class="line"> 9) <span class="string">&quot;last-generated-id&quot;</span></span><br><span class="line">10) <span class="string">&quot;1550066609501-0&quot;</span></span><br><span class="line">11) <span class="string">&quot;first-entry&quot;</span></span><br><span class="line">12) 1) <span class="string">&quot;1550066141188-0&quot;</span></span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;youming&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;60&quot;</span></span><br><span class="line">13) <span class="string">&quot;last-entry&quot;</span></span><br><span class="line">14) 1) <span class="string">&quot;1550066609501-0&quot;</span></span><br><span class="line">    2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">       2) <span class="string">&quot;xiaorui&quot;</span></span><br><span class="line">       3) <span class="string">&quot;age&quot;</span></span><br><span class="line">       4) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;   </span><br></pre></td></tr></table></figure><p>pubsub，xgroup也有子命令。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li>批量处理。将一次处理一条数据改善为1次处理多条数据性能可成倍提高。网络 IO。</li><li>最好在本机部署，性能提高 10~20 倍。</li><li>少用 get&#x2F;set，多用 hset。主要是为了内存考虑。假设一个k-v单元最少占用512bytes，即使只存储了一个字节也占用了512bytes。这时候有一个设计模式，可以将key复用，几个k-v对放在一个key中，将value作为一个set存入，同样512bytes可存储10~100倍的容量。</li></ol><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li><a href="http://ifeve.com/redis-lock/">redis实现分布式锁</a></li><li><a href="https://segmentfault.com/a/1190000009853286">最强大的命令之一-sort</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用 MySQL 架构</title>
      <link href="/2016/08/02/high-availability-mysql/"/>
      <url>/2016/08/02/high-availability-mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>There are one hundred ways to fix a problem. However, the ultimate solution is, don’t give it any chance to happen. (纠正一个错误的方法有很多，而解决一个错误的终极方法 就是不给它任何发生的机会。)<br>知之为知之，不知为不知，是知也。<br>也许是天赋不足、也许是智商捉急，更可能是懒惰和拖延作祟。但是既然开始了，就不愿意停下来。<br>我本微末凡尘，却也心向天空。—— 我吃西红柿·《莽荒纪》<br>我在起点与终点之间两全其美,却无法禅定于一夜琴声。直至悠悠的琴声被暗香淹没，我才刚刚赶到岸边，片刻之间，已被一缕清风绣在水面。 ——仓央嘉措</p></blockquote><h1 id="数据库复制功能"><a href="#数据库复制功能" class="headerlink" title="数据库复制功能"></a>数据库复制功能</h1><p>数据库服务器由于事务性不能像web服务器那样简单增加机器的数量来进行拓展（事务）。MySQL的复制功能提供了分担<em>读负载</em>的办法。增加多个备库分担主服务器的读负载，为高可用、灾难恢复、备份提供更多选择。MySQL复制利用<em>二进制</em>日志进行增量异步复制，需要的带宽少。其原理是在备库上重放主库上的二进制日志文件。</p><h2 id="MySQL二进制日志"><a href="#MySQL二进制日志" class="headerlink" title="MySQL二进制日志"></a>MySQL二进制日志</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-log.png" alt="MySQL日志分类"></p><p>在二进制文件中记录了所有对数据库的修改事件，包括CRUD和对表结构的修改事件。有一点需要注意：二进制日志文件中记录的都是成功执行了的，已经回滚了的或者有语法错误的SQL是不在二进制日志文件中的。</p><h3 id="二进制日志的格式"><a href="#二进制日志的格式" class="headerlink" title="二进制日志的格式"></a>二进制日志的格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;binlog_format&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>基于段的格式：binlog_format&#x3D;STATEMENT,日志记录量相对较小，节约磁盘和网络IO，缺点是：必须记录上下文信息，保证语句在从服务器上执行结果和主服务器上相同。对特定函数，例如：UUID(),USER()这样的非确定性函数无法复制（可能造成主从服务器数据不一致）。也称为基于SQL语句的复制，相比于基于行的复制会造成更多的行锁，因为基于行的复制仅仅是插入一条数据。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> session binlog_format=statement;</span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">mysql&gt; flush logs; -- 会产生新的binlog文件</span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line">mysql&gt; create database crn;</span><br><span class="line">mysql&gt; use crn;</span><br><span class="line">mysql&gt; create table t(<span class="built_in">id</span> int,c1 varchar(10));</span><br><span class="line">mysql&gt; insert t values(1,<span class="string">&#x27;a&#x27;</span>),(2,<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mysql&gt; update t <span class="built_in">set</span> c1 = <span class="string">&#x27;dd&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>以上我们进行了数据的CRUD操作，接下来使用mysqlbinlog工具查看二进制日志文件（数据目录下）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog muke-49-468585-v52l3-bin.000004</span><br></pre></td></tr></table></figure><p>在此日志文件中我们可以很清楚看到执行的SQL语句。</p><ul><li>基于行的日志格式：binlog_format&#x3D;ROW,该种格式可以避免MySQL主从复制中不一致的问题，是5.7之后的默认格式。和基于段的日志不同的是：同一语句修改了1000条数据，基于段的日志只会记录1条SQL，而基于行的复制会有1000条记录分别记录每一行的数据修改。<em>如果修改了DB中的数据，同时又没有备份可以恢复的时候我们可以通过分析二进制日志，对日志中记录的操作进行反向处理来恢复数据</em>。该种日志默认保存每一行，日志量大，但是可以通过binlog_row_image&#x3D;MINIMAL（默认值为FULL,还可以是NOBLOB(与FULL相似，区别仅为不记录TEXT和BLOB)）来达到节约网络和磁盘IO的目的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> session binlog_format=row;</span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;binlog_row_image&#x27;</span>;</span><br><span class="line">mysql&gt; alter table t add t2 text; <span class="comment"># 重用上面的t表并为其增加字段</span></span><br><span class="line">mysql&gt; insert t values(3,<span class="string">&#x27;hehe&#x27;</span>,<span class="string">&#x27;hahahaha&#x27;</span>);</span><br><span class="line">mysql&gt; delete from t <span class="built_in">where</span> <span class="built_in">id</span> = 1;</span><br></pre></td></tr></table></figure><p>使用mysqlbinlog命令查看二进制文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlbinlog -vv muke-49-468585-v52l3-bin.000006 | less <span class="comment"># 注意基于ROW的二进制日志需要加入-vv参数</span></span><br></pre></td></tr></table></figure><p>混合日志格式binlog_format&#x3D;MIXED是基于段的和基于行的日志格式的一种折衷选择。根据SQL语句由系统决定在基于段和基于行的日志格式间进行选择，大部分会采用STATEMENT,而类似于UUID之类的会采用基于ROW的日志格式；数据量大小由所执行的SQL决定。</p><p>MySQL的复制功能必须依赖于二进制日志文件，其工作原理如下图：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-copy.png" alt="MySQL复制"></p><p>在实际应用中建议使用混合的或者基于ROW的日志格式。</p><h2 id="基于日志点的复制的配置步骤："><a href="#基于日志点的复制的配置步骤：" class="headerlink" title="基于日志点的复制的配置步骤："></a>基于日志点的复制的配置步骤：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;从Server IP段&#x27;</span> identified by <span class="string">&#x27;password&#x27;</span>; -- 在主DB上建立复制账号</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;从Server IP段&#x27;</span>;</span><br></pre></td></tr></table></figure><p>主服务器上有2个参数需要配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>从服务器上配置对应的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=2</span><br><span class="line">relay_log=mysql-relay-bin</span><br><span class="line">log_slave_update=on <span class="comment"># 可选</span></span><br><span class="line">read_only=on <span class="comment"># 可选，安全考虑</span></span><br></pre></td></tr></table></figure><p>在从服务器上启动复制链路</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST = <span class="string">&#x27;master_host_ip&#x27;</span>,MASTER_USER=<span class="string">&#x27;repl&#x27;</span>,MASTER_PASSWORD=<span class="string">&#x27;password&#x27;</span>,MASTER_LOG_FILE=<span class="string">&#x27;master_log_file_name&#x27;</span> MASTER_LOG_POS=4;</span><br></pre></td></tr></table></figure><p>下面是实际操作：</p><p>主库：192.168.1.4(server-id&#x3D;1)，从库:192.168.1.5(server-id&#x3D;2)，IP地址的查看可以使用<code>ip addr</code>命令。</p><ol><li>在主库上创建并授权用户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create user repl@<span class="string">&#x27;192.168.1.%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>; -- 主库创建用户</span><br><span class="line">mysql&gt; grant replication slave on *.* to repl@<span class="string">&#x27;192.168.1.%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>从主库导出数据并根据此数据初始化从库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -uroot -p123456 --single-transaction --master-data --triggers --routines --all-databases &gt;&gt; all.sql</span><br><span class="line">$ scp all.sql root@192.168.1.5:/root</span><br></pre></td></tr></table></figure><ol start="3"><li>在从库上导入sql文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p123456 &lt; all.sql</span><br></pre></td></tr></table></figure><ol start="4"><li>在从库上使用<code>change master</code>命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;192.168.1.4&#x27;</span>,MASTER_USER=<span class="string">&#x27;repl&#x27;</span>,MASTER_PASSWORD=<span class="string">&#x27;123456&#x27;</span>,MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000012&#x27;</span>, MASTER_LOG_POS=429; -- 最后2个参数可以从all.sql中得到</span><br></pre></td></tr></table></figure><p>以上就完成了主从备份的配置，我们可以在从库上使用<code>start slave;</code>启动备份，并使用<code>show slave status\G;</code>观察可以发现IO进程和SQL进程都已经起来了。在master和slaver上我们也可以分别执行<code>show processlist;</code>来查看mysql进程。</p><h2 id="基于GDIT的复制"><a href="#基于GDIT的复制" class="headerlink" title="基于GDIT的复制"></a>基于GDIT的复制</h2><p>全局事务ID，保证为每一个在主库上提交的事务在复制集群中可以生成唯一ID。5.6版本开始起，新支持的复制方式，和基于日志的方式存在很大不同。基于日志的方式要求告诉从主库的哪个二进制文件的偏移量进行增量同步，如果指定错误会造成遗漏或者重复，从而造成数据一致性问题。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-gtid-copy.png" alt="基于GDIT的复制"></p><p>GTID&#x3D;source_id:transaction_id，GTID由2部分组成。source_id是主库的server-uuid，在DB启动时自动生成（数据目录下的auto.cnf）,可以保证每个MySQL实例的server-uuid都是不同的。</p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>首先在主库上建立账号，并授权（同基于日志点的复制）。主库和从库都需要配置<code>log-bin</code>和<code>server-id</code>。相比于基于日志点的复制，需要在主库上多设置如下内容：<br>是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br><span class="line">log_slave_updates=on</span><br><span class="line">master_info_repository=table</span><br><span class="line">relay_log_info_repository=table</span><br></pre></td></tr></table></figure><p>从库配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br><span class="line">log_slave_updates=on</span><br></pre></td></tr></table></figure><p>接下来导出主库数据并在从库上恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -uroot -p123456 --single-transaction --master-data=2 --triggers --routines --all-databases &gt; all2.sql</span><br><span class="line">$ scp -P22 all2.sql root@192.168.1.5:/root</span><br></pre></td></tr></table></figure><p>最后使用<code>change master</code>命令指定复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;192.168.1.4&#x27;</span>,MASTER_USER=<span class="string">&#x27;repl&#x27;</span>,MASTER_PASSWORD=<span class="string">&#x27;123456&#x27;</span>,MASTER_AUTO_POSITION=1;</span><br><span class="line">mysql&gt;start slave;</span><br><span class="line">mysql&gt;show slave status\G;</span><br></pre></td></tr></table></figure><p>我们可以在从库上执行<code>stop slave;set global slave_parallel_workers=4;start slave;show processlist;</code>进行多线程复制。</p><p>这种方式的优点是可以很方便地进行故障转移，从库不会丢失主库上的任何修改（建立在主库的二进制日志文件没有被删除）</p><blockquote><p>mysql查看用户授权：<code>use mysql;show grants for repl@&#39;192.168.1.%&#39;;</code></p></blockquote><p>基于GTID的复制方式在数据完整性和安全性上较高。</p><h2 id="MySQL复制性能优化"><a href="#MySQL复制性能优化" class="headerlink" title="MySQL复制性能优化"></a>MySQL复制性能优化</h2><p>MySQL复制是异步的，只有事务在主库上执行完并记录到二进制日志中之后，从库才能从二进制日志中读取并执行事务</p><h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><p>HA(High Availability)指的是通过尽量缩短因日常维护操作和突发的系统崩溃导致的停机时间，以提高系统和应用的可用性。5个9的可用性要求全年只有5min对外不提供服务：360<em>24</em>60*(1-0.99999)&#x3D;5.26.</p><h3 id="MMM"><a href="#MMM" class="headerlink" title="MMM"></a>MMM</h3><p>Multi-Master Replication Manager。监控MySQL的主主复制拓扑，在当前主服务器失效时，进行主备服务器之间的主从切换和故障转移。</p><p>主库：192.168.1.4和5互为主从，192.168.4为主，6为从。首先使用基于日志点的复制方法导出主库数据。接下来在三个节点上都安装3M包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install mysql-mmm-agent</span><br></pre></td></tr></table></figure><p>在监控节点192.168.1.6上安装3M监控<code>apt get install mysql-mmm-common mysql-mmm-monitor mysql-mmm-tools</code></p><p>在4上建立DB账号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;grant replication client on *.* to <span class="string">&#x27;mmm_monitor&#x27;</span>@<span class="string">&#x27;192.168.1.%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">mysql&gt;grant super,replication client,process on *.* to <span class="string">&#x27;mmm_agent&#x27;</span>@<span class="string">&#x27;192.168.1.%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-mmm.png" alt="MMM架构"></p><p><code>/etc/mysql-mmm/mmm_common.conf</code>是通用配置，所有集群节点中都是一致的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">active_master_role     writer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;host default&gt;</span><br><span class="line">       cluster_interface      eth0</span><br><span class="line"></span><br><span class="line">       pid_path       /var/run/mmm_agentd.pid</span><br><span class="line">       bin_path       /usr/lib/mysql-mmm/</span><br><span class="line"></span><br><span class="line">    <span class="comment"># repl的用户名和密码</span></span><br><span class="line">    replication_user        repl</span><br><span class="line">    replication_password    123456</span><br><span class="line"></span><br><span class="line">       agent_user     mmm_agent</span><br><span class="line">       agent_password 123456</span><br><span class="line">&lt;/host&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主库</span></span><br><span class="line">&lt;host db1&gt;</span><br><span class="line">       ip     192.168.1.4</span><br><span class="line">       mode   master</span><br><span class="line">       peer   db2</span><br><span class="line">&lt;/host&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主备</span></span><br><span class="line">&lt;host db2&gt;</span><br><span class="line">       ip     192.168.1.5</span><br><span class="line">       mode   master</span><br><span class="line">       peer   db1</span><br><span class="line">&lt;/host&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从</span></span><br><span class="line">&lt;host db3&gt;</span><br><span class="line">       ip     192.168.1.6</span><br><span class="line">       mode   slave</span><br><span class="line">&lt;/host&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主、主备，虚拟ip</span></span><br><span class="line">&lt;role writer&gt;</span><br><span class="line">       hosts  db1, db2</span><br><span class="line">       ips    192.168.1.50</span><br><span class="line">       mode   exclusive</span><br><span class="line">&lt;/role&gt;</span><br><span class="line"></span><br><span class="line">&lt;role reader&gt;</span><br><span class="line">       hosts  db1, db2, db3</span><br><span class="line">       ips    192.168.1.51, 192.168.1.52, 192.168.1.53</span><br><span class="line">       mode   balanced</span><br><span class="line">&lt;/role&gt;</span><br></pre></td></tr></table></figure><p>将以上配置复制到各个节点的对应位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scp mmm_common.conf root@192.168.1.5:/etc/mysql-mmm/mmm_common.conf</span><br><span class="line">$ scp mmm_common.conf root@192.168.1.6:/etc/mysql-mmm/mmm_common.conf</span><br></pre></td></tr></table></figure><p>分别配置3台节点上的<code>mmm_agent.conf</code>为db1,db2和db3</p><p>现在为止我们已经配置完成了db节点，接下来需要配置监控节点192.168.1.6,<code>/etc/mysql-mmm/mmm_mon.conf</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">include mmm_common.conf</span><br><span class="line"></span><br><span class="line">&lt;monitor&gt;</span><br><span class="line">        ip                                      192.168.1.6</span><br><span class="line">        pid_path                                /var/run/mmm_mond.pid</span><br><span class="line">        bin_path                                /usr/lib/mysql-mmm/</span><br><span class="line">        status_path                             /var/lib/misc/mmm_mond.status</span><br><span class="line">        ping_ips                                192.168.1.4, 192.168.1.5, 192.168.1.6</span><br><span class="line">&lt;/monitor&gt;</span><br><span class="line"></span><br><span class="line">&lt;host default&gt;</span><br><span class="line">        monitor_user                    mmm_monitor</span><br><span class="line">        monitor_password                RepMonitor</span><br><span class="line">&lt;/host&gt;</span><br><span class="line"></span><br><span class="line">debug 1</span><br></pre></td></tr></table></figure><p>使用apt-get安装完3M后会在<code>/etc/init.d/</code>下生成2个脚本，分别表示代理和监控。在集群所有节点中启动所有的代理进程，可能会遇到下面的问题：mmm_agent_navy2.conf is world readable! at &#x2F;usr&#x2F;share&#x2F;perl5&#x2F;MMM&#x2F;Common&#x2F;Config.pm line 132，解决方案是：<code>chmod 640 /etc/mysql-mmm/*</code>。在最后一个节点启动监控服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/mysql-mmm-agent start</span><br><span class="line">$ /etc/init.d/mysql-mmm-monitor start</span><br></pre></td></tr></table></figure><p>以上即完成了3M集群，当一台主服务器宕机时将写操作转到另一个DB。它提供了读写VIP（虚拟IP），使服务器角色的变更对前端应用透明。在服务器出现大量的主从延迟或者主从链路中断时可以把这台服务器上的读的虚拟IP漂移到集群中其他正常的服务器上，提供了了从服务器的延迟监控，提供了主DB故障转移后从服务器对新主的重新同步功能。但是缺点也是明显的：发布时间较早，不支持MySQL新的复制功能（GDIT复制）；没有读负载均衡的能力；进行主从切换时容易造成数据丢失，由于3M监控服务器只有一台，因此容易造成单点故障。</p><h2 id="MHA架构"><a href="#MHA架构" class="headerlink" title="MHA架构"></a>MHA架构</h2><p>全称是Master High Availability,由Perl脚本开发，可在30s内完成主从切换。集群中有3个节点都是192.168.1网段，分别是4(主)，5（从），6（从，监控节点）。3个节点上都运行着一个MySQL实例，并且启用了GTID_MODE(<code>show variables like &#39;%gtid_mode%&#39;;</code>)。以4为主库，5，6为从库，使用change master命令建立基于GTID的复制。</p><h3 id="配置各个节点SSH免认证登陆"><a href="#配置各个节点SSH免认证登陆" class="headerlink" title="配置各个节点SSH免认证登陆"></a>配置各个节点SSH免认证登陆</h3><ol><li>使用<code>ssh-keygen</code>命令生成密钥（简单回车即可）,在4上执行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen <span class="comment"># 一路回车</span></span><br><span class="line">$ ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@192.168.1.4</span><br><span class="line">$ ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@192.168.1.5</span><br><span class="line">$ ssh-copy-id -i /root/.ssh/id_rsa -p 22 root@192.168.1.6</span><br></pre></td></tr></table></figure><p>在集群中所有节点进行类似操作。</p><ol start="2"><li><p>mha软件包认为node和manager，前者需要安装在集群中的所有节点，后者只需要安装在监控节点(使用apt-get即可)。</p></li><li><p>主库节点（4）上建立用户</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on *.* to mha@<span class="string">&#x27;192.168.1.%&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>在监控节点（6）上进行MHA配置：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p /etc/mha;<span class="built_in">mkdir</span> -p /home/mysql_mha <span class="comment"># 建立工作目录和配置目录</span></span><br><span class="line">$ vim /etc/mha/mysql_mha.conf <span class="comment"># 配置文件如下</span></span><br><span class="line">[server default]</span><br><span class="line">user=mha</span><br><span class="line">password=123456</span><br><span class="line">manager_workdir=/home/mysql_mha</span><br><span class="line">manager_log=/home/mysql_mha/manager.log</span><br><span class="line">remote_workdir=/home/mysql_mha</span><br><span class="line">ssh_user=root</span><br><span class="line">repl_user=repl</span><br><span class="line">repl_password=123456</span><br><span class="line">ping_interval=1</span><br><span class="line">master_binlog_dir=/var/log/mysql</span><br><span class="line">[server1]</span><br><span class="line">hostname=192.168.1.4</span><br><span class="line">candidate_master=1</span><br><span class="line">[server2]</span><br><span class="line">hostname=192.168.1.5</span><br><span class="line">candidate_master=1</span><br><span class="line">[server3]</span><br><span class="line">hostname=192.168.1.6</span><br><span class="line">no_master=1</span><br></pre></td></tr></table></figure><ol start="5"><li>在监控节点(6)上进行基础环境的检测</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ masterha_check_ssh --conf=/etc/mha/mysql_mha.conf</span><br><span class="line">$ masterha_check_repl --conf=/etc/mha/mysql_mha.conf</span><br></pre></td></tr></table></figure><ol start="6"><li>步骤5的检测通过后使用<code>nohup masterha_manager --conf=/etc/mha/mysql_mha.conf &amp;</code>在监控节点上启动mha。</li></ol><h2 id="读写分离和负载均衡"><a href="#读写分离和负载均衡" class="headerlink" title="读写分离和负载均衡"></a>读写分离和负载均衡</h2><h3 id="为什么要读写分离？"><a href="#为什么要读写分离？" class="headerlink" title="为什么要读写分离？"></a>为什么要读写分离？</h3><p>一般来说，写负载时不可分担的，而且只能在主上进行写操作，而读操作在主和从上都可以进行。为了分担主库的压力，将读操作分离到从库上。主从复制一般有2种：</p><ol><li>程序实现读写分离</li><li>中间件实现读写分离，例如：mysql-proxy和maxScale。由中间件根据查询语法进行分析，自动完成读写分离，对应用程序透明，已有程序不需要做任何修改。缺点是查询效率降低（降低50%~70%的QPS），因此使用中间件需要进行必要的基准测试。</li></ol><h3 id="读写分离中间件maxScale"><a href="#读写分离中间件maxScale" class="headerlink" title="读写分离中间件maxScale"></a>读写分离中间件maxScale</h3><p><a href="https://mariadb.com/products/mariadb-maxscale">maxscale</a>是<a href="https://mariadb.org/">mariadb</a>公司开发的读写分离中间件。</p><p><a href="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-arch.png">高可用MySQL架构</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 查询优化和数据库监控</title>
      <link href="/2016/08/02/mysql-query-optimize/"/>
      <url>/2016/08/02/mysql-query-optimize/</url>
      
        <content type="html"><![CDATA[<h1 id="如何确定查询处理的各个阶段所消耗的时间"><a href="#如何确定查询处理的各个阶段所消耗的时间" class="headerlink" title="如何确定查询处理的各个阶段所消耗的时间"></a>如何确定查询处理的各个阶段所消耗的时间</h1><h2 id="使用profile"><a href="#使用profile" class="headerlink" title="使用profile"></a>使用profile</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> profiling=1; -- 启用profile，这是一个session级别的配置</span><br><span class="line">mysql&gt; <span class="keyword">select</span> count(*) from film; -- 执行任意SQL</span><br><span class="line">mysql&gt; show profiles; -- 查看profile，可以看到query <span class="built_in">id</span>，duration和具体的sql</span><br><span class="line">mysql&gt; show profile <span class="keyword">for</span> query 5; -- 查看某个query <span class="built_in">id</span>的各个阶段的消耗时间</span><br><span class="line">mysql&gt; show profile cpu <span class="keyword">for</span> query 5; -- 查看CPU信息</span><br><span class="line">-- 以上的查询中我们可以看到都有一个警告信息</span><br><span class="line">mysql&gt; show warnings; -- 查看警告信息,发现警告信息是show profile已经被废弃了，官方建议使用Performance Schema</span><br></pre></td></tr></table></figure><h2 id="使用performance-schema"><a href="#使用performance-schema" class="headerlink" title="使用performance_schema"></a>使用performance_schema</h2><p> 和profile不同的是，该配置是全局的。要使用这个配置需要在<code>performance_schema</code>数据库下执行下面的2条update语句：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `setup_instruments` <span class="keyword">SET</span> enabled<span class="operator">=</span><span class="string">&#x27;yes&#x27;</span>,timed<span class="operator">=</span><span class="string">&#x27;yes&#x27;</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;stage%&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> `setup_consumers` <span class="keyword">SET</span> enabled<span class="operator">=</span><span class="string">&#x27;yes&#x27;</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;events%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>执行完上面的2句执行任意的SQL，查看这些SQL在各个阶段的执行时间可以采用如下的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.THREAD_ID,SQL_TEXT,c.EVENT_NAME,(c.TIMER_END <span class="operator">-</span> c.TIMER_START)<span class="operator">/</span><span class="number">1000000000</span> <span class="keyword">AS</span> <span class="string">&#x27;DURATION(ms)&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> events_statements_history_long a</span><br><span class="line"><span class="keyword">JOIN</span> threads b <span class="keyword">ON</span> a.THREAD_ID <span class="operator">=</span> b.THREAD_ID</span><br><span class="line"><span class="keyword">JOIN</span> events_stages_history_long c <span class="keyword">ON</span> c.THREAD_ID <span class="operator">=</span> b.THREAD_ID <span class="keyword">AND</span> c.EVENT_ID <span class="keyword">BETWEEN</span> a.EVENT_ID <span class="keyword">AND</span> a.END_EVENT_ID</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a.THREAD_ID,c.EVENT_ID;</span><br></pre></td></tr></table></figure><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-query-optimize-proformance-schema.png" alt="mysql proformance_schema"></p><p>如上图，我们可以看到和profile类似的结果。</p><h1 id="特定SQL的查询优化"><a href="#特定SQL的查询优化" class="headerlink" title="特定SQL的查询优化"></a>特定SQL的查询优化</h1><h2 id="关于大表的更新"><a href="#关于大表的更新" class="headerlink" title="关于大表的更新"></a>关于大表的更新</h2><ul><li>大表的数据最好分批处理，例如1000W条数据中删除或者更新100W行记录，我们一次最好只删除或者更新5000行记录，并且为了减少对主从复制的压力，我们可以在每次修改后暂停若干秒，大表的更新和删除可以采用如下的存储过程：</li><li>对大表结构的修改是一个更为严重的问题——修改表结构将会锁表，且无法解决主从复制数据库延迟的问题。一个比较好的方法是建立一个新表，将老表中的数据导入到新表中，并且在老表中建立一系列的触发器（把老表中数据的修改同步到新表中），当老表和新表的数据同步后对老表加一个<em>排它锁</em>，然后重新命名新表为老表的名字，最后删除重命名的老表。这种操作只会在重命名的时候加一个短暂的锁，通常对应用不会有影响，并且可以有效降低主从延迟。我们可以使用<a href="http://blog.chinaunix.net/uid-16844903-id-4010770.html">pt-online-schema-shange工具</a>帮助我们完成上述复杂的操作。</li></ul><h2 id="如何优化NOT-IN和的查询"><a href="#如何优化NOT-IN和的查询" class="headerlink" title="如何优化NOT IN和&lt;&gt;的查询"></a>如何优化<code>NOT IN</code>和<code>&lt;&gt;</code>的查询</h2><p>NOT IN通常可以转化为LEFT JOIN可以避免对子查询表的多次查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id,first_name,last_name,email <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> customer_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> customer_id <span class="keyword">FROM</span> payment); <span class="comment">-- 查询没有支付的用户记录</span></span><br><span class="line"><span class="comment">-- 我们可以使用LEFT JOIN对以上的查询进行优化,可以避免对payment表进行多次关联查询</span></span><br><span class="line"><span class="keyword">SELECT</span> a.customer_id,a.first_name,a.last_name,a.email <span class="keyword">FROM</span> customer a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> payment b <span class="keyword">ON</span> a.customer_id <span class="operator">=</span> b.customer_id <span class="keyword">WHERE</span> b.customer_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>如果需要分担数据库的读负载，我们可以使用主从复制的方式为数据库增加若干从服务器，通过读写分离的方式就可以将数据库的读负载分担到各个从服务器。但是随着业务的增长可能单一的主服务器就承担不了写的负载了。分库分表主要有以下的几种方式：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-db-partion-1.png" alt="MySQL分库分表1"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-db-partion-2.png" alt="MySQL分库分表2"></p><p>注意上图中的一个数据库节点并不是一台数据库物理机器，而是多台机器组成的集群，集群中的数据是一致的。</p><p>如果上面的2种方式还是不能满足要求就可以放终极大招了：表的水平拆分（又称为数据库分片），通常说的分库分表就是这种方式：</p><p>对一个库中的相关表进行水平拆分到不同实例的数据库中。对数据库分片并不容易，并且对数据库分片后还会变得难以维护，不到万不得已不要轻易使用！</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-db-partion-3.png" alt="MySQL分库分表3"></p><h1 id="数据库监控"><a href="#数据库监控" class="headerlink" title="数据库监控"></a>数据库监控</h1><ul><li>对数据库服务的可用性进行监控。这里需要注意一点：数据库进程或者端口存在并不意味着数据库是可用的。我们必须通过网络连接到数据库并且确定数据库对外是可以提供服务的。</li><li>对DB性能进行监控，最常见的2个指标是QPS和TPS。</li><li>主从复制进行监控。主从复制状态的监控以及主从复制延迟的监控，定期确定主从复制的数据是否一致。</li><li>对服务器资源进行监控。</li></ul><h2 id="DB可用性监控"><a href="#DB可用性监控" class="headerlink" title="DB可用性监控"></a>DB可用性监控</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqladmin -umonitor_user -p -h ping</span><br><span class="line">$ telnet ip db_port</span><br></pre></td></tr></table></figure><p>但是<strong>最好</strong>的方式是通过程序通过网络建立数据库连接。除了监控DB服务可用，还需要确认DB是否可读写。</p><ul><li>检查DB的read_only是否为off。</li><li>建立一张专门用于监控的表，通过程序定期对表进行读写操作。</li><li>连接到DB后进行<code>select @@version</code>进行查询。</li></ul><p>最后需要监控DB的连接数，连接数目过大将不会对外提供服务。有很多原因可能导致数据库的连接过大，例如：出现阻塞或者缓存失效。</p><ul><li>首先获得最大连接的数量：<code>show variables like &#39;max_connections&#39;;</code></li><li>获取当前DB连接数量：<code>show global status like &#39;Threads_connected&#39;;</code></li><li>当Threads_connected &#x2F; max_connections &gt; .8的时候可以发出报警。</li></ul><h2 id="DB性能监控"><a href="#DB性能监控" class="headerlink" title="DB性能监控"></a>DB性能监控</h2><h3 id="如何计算QPS和TPS"><a href="#如何计算QPS和TPS" class="headerlink" title="如何计算QPS和TPS"></a>如何计算QPS和TPS</h3><p>需要注意的是这里的Query并不特制SELECT，它包含DB处理的所有请求。TPS为每秒执行的事务数量，指的是INSERT,UPDATE,DELETE。DBMS的性能会随着并发处理请求的数量的增加而下降。通常情况下DB的并发量是固定的，并且远小于同一时间连接到DB的线程的数量。</p><p>监控InnoDB的阻塞可以周期性执行以下的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.trx_mysql_thread_id <span class="keyword">AS</span> <span class="string">&#x27;被阻塞线程&#x27;</span>,</span><br><span class="line">b.trx_query <span class="keyword">AS</span> <span class="string">&#x27;被阻塞SQL&#x27;</span>,</span><br><span class="line">c.trx_mysql_thread_id <span class="string">&#x27;阻塞线程&#x27;</span>,</span><br><span class="line">c.trx_query <span class="keyword">AS</span> <span class="string">&#x27;阻塞SQL&#x27;</span>,</span><br><span class="line">(UNIX_TIMESTAMP() <span class="operator">-</span> UNIX_TIMESTAMP(c.trx_started)) <span class="keyword">AS</span> <span class="string">&#x27;阻塞时间&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> information_schema.innodb_lock_waits a</span><br><span class="line"><span class="keyword">JOIN</span> information_schema.innodb_trx b <span class="keyword">ON</span> a.requesting_trx_id <span class="operator">=</span> b.trx_id</span><br><span class="line"><span class="keyword">JOIN</span> information_schema.innodb_trx c <span class="keyword">ON</span> a.blocking_trx_id <span class="operator">=</span> c.trx_id</span><br><span class="line"><span class="keyword">WHERE</span> (UNIX_TIMESTAMP() <span class="operator">-</span> UNIX_TIMESTAMP(c.trx_started)) <span class="operator">&gt;</span> <span class="number">60</span>; <span class="comment">-- 查询阻塞时间超过60s</span></span><br></pre></td></tr></table></figure><h2 id="主从复制的监控"><a href="#主从复制的监控" class="headerlink" title="主从复制的监控"></a>主从复制的监控</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-master-slave-monitor.png" alt="主从复制的监控"></p><p>使用<a href="http://blog.chinaunix.net/uid-16844903-id-3360228.html">pt-table-checksum</a>工具可以检查主从复制数据一致性</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引优化</title>
      <link href="/2016/07/29/mysql-index-optimize/"/>
      <url>/2016/07/29/mysql-index-optimize/</url>
      
        <content type="html"><![CDATA[<p>索引的主要作用就是告诉存储引擎如何快速找到我们所需要的数据,它是一种数据结构。MySQL的索引是在<em>存储引擎层</em>实现的，而不是在服务器层实现的，这就决定了不同的存储引擎的工作方式可能是不同的，同时也不是所有的存储引擎都支持所有的索引类型。即使是同一种索引在不同的存储引擎上其底层实现也不一定相同。</p><h1 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h1><p>Btree索引以<a href="http://baike.baidu.com/link?url=zpWnyU-KY1FbA2f2V2HItCW-7CqrdSt6iZ1k1eb2pdZkqQhgkt0GUYqHVZAFjcdaNMprBZgSX_-0_eihPEt41_">B+树</a>这种数据结构<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-Btree-index.png" alt="B+树数据结构"></p><p>只有叶子节点才保存真正的信息（相关表的行位置），在索引的根节点中存放了指向下层子节点的指针，存储引擎根据指针向下层进行查找。通过比较节点的值和要查找的值就可以得到合适的指针进入到下层子节点，而这些指针实际上是定义了子节点中值得上下限。叶子节点的指针指向的是被索引的数据而不是其他的叶子节点。在InnoDB中，叶子节点指向的是主键，在MyISAM中，叶子节点指向数据的物理地址。</p><p>在DB中增加或者删除一行会导致B+树改变，B+树需要自我整理和自我平衡。B+树中插入和删除操作都是O(log(N))，所以添加过多索引减缓了快速插入、更新或者删除表中的某一行的操作，因为数据库要以昂贵的代价(O(log(N)))来更新索引</p><p>BTree索引可以帮助我们进行排序以避免使用磁盘临时表带来的IO消耗。</p><p>能够把随机IO变为顺序IO。</p><h2 id="为什么使用BTree"><a href="#为什么使用BTree" class="headerlink" title="为什么使用BTree"></a>为什么使用BTree</h2><p>红黑树其实也是能实现索引的，但是文件系统和DBMS普遍采用BTree作为索引结构的主要原因如下：</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往<strong>以索引文件的形式存储的磁盘上</strong>。这样的话，<strong>索引查找过程中就要产生磁盘I&#x2F;O消耗</strong>，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-&#x2F;+Tree作为索引的效率。</p><h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/6d743320-9350-11ea-8ed4-bf514abbd811.png" alt="image.png"></p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3afffb30-9351-11ea-8ed4-bf514abbd811.png" alt="磁盘整体结构"></p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/cb1b4ee0-9351-11ea-8ed4-bf514abbd811.png" alt="磁盘结构"></p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h3 id="局部性原理和磁盘预读"><a href="#局部性原理和磁盘预读" class="headerlink" title="局部性原理和磁盘预读"></a>局部性原理和磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I&#x2F;O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：**当一个数据被用到时，其附近的数据也通常会马上被使用。**程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I&#x2F;O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>一般使用磁盘I&#x2F;O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I&#x2F;O。</p><p>B-Tree中一次检索最多需要h-1次I&#x2F;O（根节点常驻内存），渐进复杂度为O(h)&#x3D;O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I&#x2F;O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p><strong>BTree索引适合范围查找</strong>，因此它的使用场景如下：</p><ol><li>全值匹配的查询。例如：我们在订单号order_sn上建立的索引，然后查询编号为98763478976的订单记录。</li><li>匹配最左前缀的查询。如果我们在order_sn上并没有建立索引，而是建立了order_sn和order_date两个字段上的联合索引，对于查询订单编号为98763478976的记录，我们同样可以利用这个联合索引，也就是说<em>如果联合索引的第一列符合查询条件，这个索引就会被用到，但是如果只是这个联合索引的第二列符合条件就无法利用索引</em>，例如：查询order_date为2016-07-08的记录就无法利用到索引。</li><li>匹配列前缀的查询。例如：<code>order_sn like 9876%</code>匹配列前缀的查询。</li><li>匹配范围值得查询。<code>order_sn&gt;9888343243 and order_sn &lt; 9999999999</code>。</li><li>精确匹配左前列并范围匹配另外一列。例如联合索引order_sn和order_date。精确匹配order_sn并范围匹配order_date。</li><li>只访问索引的查询。也称为覆盖索引，查询只需要访问索引不需访问数据行。</li></ol><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><ol><li>如果不是按照索引的最左列开始查找的，则无法使用索引。联合索引order_sn和order_date，如果我们只把订单日期作为查询条件，就无法使用这个联合索引。</li><li>使用索引的时候不能跳过索引中的列。例如：order_date,name,tel 3列组成的联合索引，如果我们在查找中只包含order_date和tel,那么对于这个查询来说就只能使用到order_date这一列来进行查询过滤而无法使用到tel，因为我们在查询条件中跳过了name这一列。</li><li><code>NOT IN</code>和<code>&lt;&gt;</code>无法使用索引。</li><li><strong>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</strong></li></ol><h1 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h1><p>Hash索引基于hash表，只有查询条件精确匹配hash索引中的所有列时，才能够使用到hash索引。也就是说<strong>hash索引只能用在等值查询中</strong>。对于hash索引中的每一列，存储引擎都会为每一行计算出一个hash码，hash索引中存储的就是hash码</p><p>使用hash索引需要进行2次查找，无法用于排序，不支持部分索引，不支持范围查找，有可能产生hash冲突（不同列产生的hash码是相同的），例如性别列就不能使用hash索引，身份证号列上建立hash索引比较合适。</p><blockquote><p>Q:为什么索引能够减少存储引擎需要扫描的数据量？<br>A:索引列的大小通常会远小于数据列的大小。以InnoDB来说：InnoDB发生一次IO，最小的单位是页（默认16K），一页内存储的信息越多，效率越高。相比存储数据，一页内能够存储更多的索引。通过索引进行查询需要读取的页的数量少，减少需要扫描的数据量。</p></blockquote><p><em>索引并不是越多越好</em>。索引会增加写操作的成本，为了解决这个问题InnoDB采用了<a href="http://blog.163.com/ji_1006/blog/static/1061234120138277177253/">插入缓存</a>能够将多次插入合并为1次插入。太多的索引也会增加查询优化器的选择时间。</p><h1 id="安装演示DB"><a href="#安装演示DB" class="headerlink" title="安装演示DB"></a>安装演示DB</h1><p><a href="http://downloads.mysql.com/docs/sakila-db.tar.gz">MySQL演示数据库sakila</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p123456 &lt; sakila-schema.sql</span><br><span class="line">$ mysql -uroot -p123456 &lt; sakila-data.sql</span><br></pre></td></tr></table></figure><h1 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h1><p>索引的选择性指的是不重复的索引值和表的记录数的比值，由此可见主键和唯一索引的选择性最高。选择性越高，效率越高。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index-optimize1.png" alt="索引列上不能使用表达式或者函数"></p><p>使用索引的一个常见误区就是对表的每一列都建立索引。我们可以使用联合索引，联合索引列的顺序至关重要：</p><ol><li>经常被用到的列优先</li><li>选择性高的列优先</li><li>宽度小的列优先</li></ol><p>包含了查询字段的全部值得索引被称为覆盖索引。覆盖索引可以避免对InnoDB主键索引的二次查询，避免对MyISAM表进行系统调用。覆盖索引也有以下的限制：查询中使用了太多的列(select * 无法使用覆盖索引)；存储引擎不支持覆盖索引；使用了双%的like查询。</p><p>使用演示数据库sakila进行以下的查询计划：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index.png" alt="MySQL覆盖索引"></p><p>注意到在上图中，<code>select *</code> 无法使用到覆盖索引。</p><h2 id="使用索引来优化排序"><a href="#使用索引来优化排序" class="headerlink" title="使用索引来优化排序"></a>使用索引来优化排序</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index-sort.png" alt="使用索引优化排序"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index-sort1.png" alt="使用索引排序"></p><p>在上面的右图中如果我们将查询计划改为：<code>explain select * from rental where rental_date=&#39;2005-01-01&#39; order by inventory_id desc,customer_id\G;</code>那么在Extra将会变为：“Extra: Using index condition; Using filesort”，因为它违反了使用索引进行优化的第二条规则。</p><h2 id="使用Btree索引模拟hash索引"><a href="#使用Btree索引模拟hash索引" class="headerlink" title="使用Btree索引模拟hash索引"></a>使用Btree索引模拟hash索引</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table film add title_md5 char(32);</span><br><span class="line">mysql&gt; update film <span class="built_in">set</span> title_md5=md5(title);</span><br><span class="line">mysql&gt; create index idx_md5 on film(title_md5);</span><br><span class="line">mysql&gt; explain <span class="keyword">select</span> * from film <span class="built_in">where</span> title_md5=md5(<span class="string">&#x27;EGG IGBY&#x27;</span>) and title=<span class="string">&#x27;EGG IGBY&#x27;</span>\G; -- 由于MD5可能<span class="built_in">hash</span>冲突，所以还需要使用title=<span class="string">&#x27;EGG IGBY&#x27;</span>进行过滤</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           <span class="built_in">id</span>: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film</span><br><span class="line">   partitions: NULL</span><br><span class="line">         <span class="built_in">type</span>: ref</span><br><span class="line">possible_keys: idx_title,idx_md5</span><br><span class="line">          key: idx_title</span><br><span class="line">      key_len: 767</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 5.00</span><br><span class="line">        Extra: Using <span class="built_in">where</span></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span>, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="利用索引优化锁"><a href="#利用索引优化锁" class="headerlink" title="利用索引优化锁"></a>利用索引优化锁</h2><p>索引可以减少锁定的行数和加快数据的处理速度，同时加快锁的释放。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop index idx_actor_last_name on actor;</span><br></pre></td></tr></table></figure><p>开2个session，使用事务，发现session2被阻塞了：<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-lock.png" alt="MySQL锁"><br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index-lock.png" alt="使用索引优化锁"></p><h2 id="索引的维护和优化"><a href="#索引的维护和优化" class="headerlink" title="索引的维护和优化"></a>索引的维护和优化</h2><p>MySQL允许在同一列上创建多个索引，但是过多的索引将会冗余，例如：<br><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-index-optimize1.png" alt="冗余索引"></p><p>一种常见的误区就是认为<code>UNIQUE KEY</code>是唯一约束，很多人错误地为它建立了索引。</p><p>确定冗余和重复的索引可以采用<a href="https://www.percona.com/doc/percona-toolkit/2.2/index.html">pt-duplicate-key-checker</a></p><p>MySQL查询优化器可以通过索引的统计信息来制定合适的查询策略。如果索引的统计信息不当就会影响查询的性能。可以通过<code>analyze table table_name</code>。BTree索引进行更新的是偶可能会产生大量的碎片，碎片化的索引可能会以无序的方式存储在磁盘上，除了索引，表也会产生碎片，我们需要定期对表进行维护（<code>optimize table table_name</code>,需要注意的是使用不当会锁表）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.jobbole.com/100349/">数据库的底层原理</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构和算法原理</a></li><li><a href="https://blog.ouyangsihai.cn/mian-shi-guan-wen-ni-b-shu-he-b-shu-jiu-ba-zhe-pian-wen-zhang-diu-gei-ta.html">B树和B+树</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建高可用 MySQL 架构</title>
      <link href="/2016/07/22/mysql-best-practice/"/>
      <url>/2016/07/22/mysql-best-practice/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-engine.png" alt="mysql存储引擎"></p><p>DBMS的瓶颈在于IO而非CPU。</p><blockquote><p>慎用数据库的一些特性，例如外键（业务量爆炸的时候分库分表将是一个灾难）。虽然不建议使用物理外键，但是相关联的列上一定要建立索引。</p></blockquote><ul><li>在双十一的场景中取消掉计划任务（例如定时备份）。</li></ul><h1 id="在大促中什么影响了数据库性能"><a href="#在大促中什么影响了数据库性能" class="headerlink" title="在大促中什么影响了数据库性能"></a>在大促中什么影响了数据库性能</h1><h2 id="超高的QPS和TPS"><a href="#超高的QPS和TPS" class="headerlink" title="超高的QPS和TPS"></a>超高的QPS和TPS</h2><p>QPS(Query Per Second)<br>风险：效率低下的SQL。数据库中的性能问题80%就是由慢查询造成的。也就是大多数的数据库问题可以通过对SQL进行优化来解决。</p><p>TPS（Transition Per Second）</p><h2 id="大量并发和超过的CPU使用率"><a href="#大量并发和超过的CPU使用率" class="headerlink" title="大量并发和超过的CPU使用率"></a>大量并发和超过的CPU使用率</h2><p>高并发可能导致DB连接被占满；超高CPU使用率可能因为CPU资源耗尽而出现宕机。这里并发量指的是同一时刻需要DB服务器处理请求的数量，而连接量往往比并发量大得多，因为现在的系统中每一个前端服务器（例如nginx,tomcat,apache）都会对数据库建立多个连接，而在众多的连接中往往只有几个是在请求数据库处理的，其他的大多数连接都会处于sleep状态。数据库对于允许建立的连接数目是有限的（max_connections默认为100）</p><h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>磁盘IO性能突然下降（使用更快的磁盘设备，SSD，fashion IO），其他大量消耗磁盘性能的计划任务（调整计划任务，做好磁盘维护）。例如平时在主库上进行备份的，在大促的时候应该切换到从库上备份。</p><h2 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h2><p>大多数网卡是1000mbps (bits) &#x3D; 1000 &#x2F; 8 &#x3D; 100 MB&#x2F;s(byte)</p><p>如何避免无法连接数据库的情况：</p><ol><li>减少从服务器的数量。（从服务器需要从主服务器上进行复制）</li><li>进行分级缓存</li><li>避免使用<code>SELECT *</code></li><li>分离业务网络和服务器网络</li></ol><h2 id="大表带来的问题"><a href="#大表带来的问题" class="headerlink" title="大表带来的问题"></a>大表带来的问题</h2><p>大表可以从2个维度来进行定义：</p><ul><li><p>记录数目巨大，单表超过1000W行</p></li><li><p>表数据文件巨大，超过10G</p></li><li><p>大表往往意味着慢查询（很难在一定时间内过滤出所需要的数据）的产生，大表往往会降低SQL的效率。</p></li><li><p>大表对DDL也会产生影响。例如建立索引需要很长时间。5.5版本以下建立索引会锁表，而&gt;&#x3D;5.5的时候虽然不会锁表，但是会引起主从延迟。</p></li></ul><p>对于大表有2种策略：分库分表和历史数据归档</p><p>分库分表把大表分成多个小表</p><p>难点：</p><ul><li>分表主键的选择</li><li>分表后跨分区数据的查询和统计</li></ul><p>大表的历史数据归档，可以尽量减少业务前后端的影响。难点在于：</p><ul><li>归档时间点的选择</li><li>如何进行归档操作</li></ul><h2 id="大事务带来的问题"><a href="#大事务带来的问题" class="headerlink" title="大事务带来的问题"></a>大事务带来的问题</h2><p>事务的隔离性（ISOLATION），SQL标准中定义了4种隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%iso%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>未提交读（READ UNCOMMITED）</li><li>已提交读 (READ COMMITED)</li><li>可重复读 (REPEATABLE READ)，InnoDB默认级别。</li><li>可串行化（SERIALIZABLE）,最高</li></ul><p>验证事务的隔离级别我们可以分别连接到两个mysql shell，在一个shell中进行插入操作</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-isolation-pepeatable-read.png" alt="MySQL默认隔离级别-可重复读"></p><p>大事务的运行时间比较长，操作的数据比较多的事务。可能造成锁定太多数据，造成大量的阻塞和锁超时。回滚的时间较长，并且在回滚的过程中数据也是被锁定的。执行时间长可能造成主从延迟。</p><p>处理大事务一般有以下的策略：</p><ol><li>避免一次性处理太多数据，可以进行分批处理；</li><li>查询操作（SELECT）可以从事务中移除，事务中只保留必要的写操作。</li></ol><h1 id="影响MySQL性能的几个因素"><a href="#影响MySQL性能的几个因素" class="headerlink" title="影响MySQL性能的几个因素"></a>影响MySQL性能的几个因素</h1><h2 id="CPU数量和主频的权衡"><a href="#CPU数量和主频的权衡" class="headerlink" title="CPU数量和主频的权衡"></a>CPU数量和主频的权衡</h2><p>如果我们的应用是计算密集型的就应该选择更高主频的U，因为现在的MySQL不支持对同一SQL进行并发处理，但是对于高并发的应用，CPU的数量越多越好。</p><p>在MyISAM中会将索引缓存在内存中，而数据通过OS进行缓存；InnoDB会同时在内存中缓存数据和索引。</p><p>缓存系统不但对读操作影响深远，对写操作也是有好处的。例如商品浏览次数，如果我们每次浏览都对数据库进行更新操作，必将导致大量IO，我们可以在每次浏览的时候修改缓存中的计数器，当计数器达到某一个值（例如100）的时候进行写库操作，这样就将100次的更新操作合并成了一次更新。缓存能够延缓DB的更新频次。</p><h1 id="CentOS系统参数优化"><a href="#CentOS系统参数优化" class="headerlink" title="CentOS系统参数优化"></a>CentOS系统参数优化</h1><p>对于一个处于监听状态的端口都会有自己的监听队列</p><p>内核相关参数(<code>/etc/sysctl.conf</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 4294967295 <span class="comment"># 单个共享内存段的最大值，应足够大，以便能够在一个内存段中容纳下整个InnoDB缓冲池的大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加资源限制（<code>/etc/security/limits.conf</code>）</p><p>该文件实际上是Linux PAM也就是插入式认证模块的配置文件。打开文件数目的限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535 <span class="comment"># * 表示对所有用户有效，soft，当前系统生效的设置</span></span><br><span class="line">* hard nofile 65535  <span class="comment"># hard 系统所能设置的最大值，nofile 所限制的资源是打开文件的最大数目 65535 限制数量</span></span><br></pre></td></tr></table></figure><p>磁盘调度策略（<code>/sys/block/devname/queue/scheduler</code>），例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/block/sda/queue/scheduler</span><br><span class="line">noop anticipatory deadline [cfq]</span><br></pre></td></tr></table></figure><p>以上的默认磁盘调度策略是cfq，除此之外还存在noop(电梯式调度策略)，deadline（截止时间调度策略，数据库最好选择），anticipatory（预料IO调度策略）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> deadline &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure><h2 id="文件系统对性能的影响"><a href="#文件系统对性能的影响" class="headerlink" title="文件系统对性能的影响"></a>文件系统对性能的影响</h2><p>ext3&#x2F;4系统挂载参数<code>/etc/fstab</code></p><h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p>MySQL的插入式存储引擎将数据的处理和数据存储相分离。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-arch2.png" alt="MySQL体系结构"></p><p>SQL语句如何从文件中获得我们所需要查询的数据，这个的具体实现方式则是下一层存储引擎层进行实现。存储是针对于表而不是针对于库的。在一个库中可以使用不同的存储引擎建立不同的表</p><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-storage-engine.png" alt="MySQL存储引擎"></p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>5.5版本之前的默认存储引擎，也是系统表和临时表（在排序、分组等操作中，当数量超过一定大小之后，由查询优化器建立的临时表）使用的存储引擎。。由MYD和MYI组成。该引擎使用表级锁，对表中的数据进行修改时会锁表，在对表中的数据进行读取时需要加共享锁。表损坏修复可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; check table t_username; </span><br><span class="line">mysql&gt; repair table t_username;</span><br></pre></td></tr></table></figure><p>还可以使用<code>myisamchk</code>命令行工具</p><p>测试MyISAM存储引擎</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t_test(<span class="built_in">id</span> INT,name VARCHAR(20)) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>查看mysql数据文件的位置可以使用<code>show variables where Variable_name =&#39;datadir&#39;;</code>命令，我们进入数据库数据文件所在目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# <span class="built_in">pwd</span>                                  </span><br><span class="line">/data/mysqld/data/db_test                                                 </span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll                                   </span><br><span class="line">total 10                                                                  </span><br><span class="line">-rw-r----- 1 mysql mysql   65 Jul 23 11:25 db.opt                         </span><br><span class="line">-rw-r----- 1 mysql mysql 8586 Jul 23 11:25 t_test.frm  <span class="comment"># 表结构信息</span></span><br><span class="line">-rw-r----- 1 mysql mysql    20 Jul 23 11:25 t_test.MYD <span class="comment"># 表数据            </span></span><br><span class="line">-rw-r----- 1 mysql mysql 1024 Jul 23 11:25 t_test.MYI  <span class="comment"># 索引信息              </span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# myisampack -b -f t_test.MYI  <span class="comment"># 压缩表</span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll                                   </span><br><span class="line">total 11                                                                  </span><br><span class="line">-rw-r----- 1 mysql mysql   65 Jul 23 11:25 db.opt                         </span><br><span class="line">-rw-r----- 1 mysql mysql 8586 Jul 23 11:25 t_test.frm                     </span><br><span class="line">-rw-rw-rw- 1 mysql mysql   54 Jul 23 11:32 t_test.MYD <span class="comment"># 由于数据较小，压缩后的尺寸更大了                    </span></span><br><span class="line">-rw-r----- 1 mysql mysql 1024 Jul 23 11:36 t_test.MYI                     </span><br><span class="line">-rw-rw-rw- 1 mysql mysql   20 Jul 23 11:32 t_test.OLD <span class="comment"># 压缩前文件的备份</span></span><br></pre></td></tr></table></figure><p>支持全文索引，支持压缩（<code>myisampack</code>)，压缩之后进行插入操作报错，提示该表是只读的。</p><p><em>限制：</em></p><p>&lt;5.0版本默认表大小为4G，如果需要存储大表需要修改<code>MAX_Rows</code>和<code>AVG_ROW_LENGTH</code>,5.0版本之后默认支持256TB。</p><p><em>使用场景：</em></p><ul><li>非事务型应用</li><li>只读类应用（例如报表类）</li><li>空间类应用</li></ul><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>MySQL5.5之后的默认存储引擎。使用表空间进行数据存储。具有由<code>innodb_file_per_table</code>这个参数决定，如果该参数为ON,则表示独立的表空间<code>tablename.idb</code>，如果该参数为OFF则表示系统表空间：<code>ibdataX</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br><span class="line">mysql&gt; CREATE TABLE t_innodb(<span class="built_in">id</span> int,name varchar(20)) ENGINE=<span class="string">&#x27;innodb&#x27;</span>;</span><br></pre></td></tr></table></figure><p>接下来我们进入数据文件目录查看下该种存储引擎对应的数据文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# <span class="built_in">pwd</span>                                  </span><br><span class="line">/data/mysqld/data/db_test                                                 </span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll t_innodb*                         </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 12:54 t_innodb.frm                  </span><br><span class="line">-rw-r----- 1 mysql mysql 98304 Jul 23 12:54 t_innodb.ibd  <span class="comment"># 每一个表一个单独的表空间              </span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# </span><br></pre></td></tr></table></figure><p>接下来通过mysql shell修改<code>innodb_file_per_table</code>全局变量为OFF</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET global innodb_file_per_table=off; </span><br><span class="line">mysql&gt; CREATE TABLE t_innodb_g(<span class="built_in">id</span> int,name varchar(20)) ENGINE=<span class="string">&#x27;innodb&#x27;</span>; <span class="comment"># 创建新表</span></span><br></pre></td></tr></table></figure><p>再次查看数据库的数据目录发现只存在frm文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# ll t_innodb*                         </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 12:54 t_innodb.frm                  </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 13:01 t_innodb_g.frm <span class="comment"># 存储在共享表空间，即上一级目录的ibdata1中                </span></span><br><span class="line">-rw-r----- 1 mysql mysql 98304 Jul 23 12:54 t_innodb.ibd </span><br></pre></td></tr></table></figure><h4 id="系统表空间和独立表空间之间如何选择"><a href="#系统表空间和独立表空间之间如何选择" class="headerlink" title="系统表空间和独立表空间之间如何选择"></a>系统表空间和独立表空间之间如何选择</h4><ul><li>系统表空间无法简单收缩文件的大小，删除数据后表空间的大小并不会缩小；会产生IO瓶颈</li><li>独立表空间可以通过optimize table命令收缩系统文件；独立表空间可以同时向多个文件刷新数据。</li></ul><p>强烈建议使用独立表空间。</p><h4 id="InnoDB是如何做到事务的ACID特性的？"><a href="#InnoDB是如何做到事务的ACID特性的？" class="headerlink" title="InnoDB是如何做到事务的ACID特性的？"></a>InnoDB是如何做到事务的ACID特性的？</h4><ul><li>Redo Log，重做日志，实现持久性，重做日志缓冲区（<code>show variables like &#39;innodb_log_buffer_size&#39;;</code>），和重做日志文件(数据目录下的<code>ib_logfile0</code>和<code>ib_logfile1</code>，这里有两个log file文件和<code>show variables like &#39;innodb_log_files_in_group&#39;;</code>相对应) </li><li>Undo Log，回滚日志，未提交的事务进行回滚和实现MVC（多版本并发控制）。</li></ul><p>Redo Log是顺序写入的，而Undo Log则是随机读写的。</p><p>InnoDB支持行级锁，可以最大程度支持并发。锁的主要作用是实现并发控制和事务的隔离性。我们可以在一个mysql shell中执行<code>lock table t_innodb write;</code>,然后在另一个shell中对该表进行读或者写操作都被阻塞，因为我们对t_innodb这张表加了表级排它锁。直到我们在第一个shell中执行<code>unlock tables;</code>，第二个shell才会有数据返回。</p><p>锁的粒度和资源的开销是负相关的。锁的粒度越小（行锁），资源占用越多，并发越大。</p><p>InnoDB状态检查可以使用<code>show engine innodb status</code></p><h1 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h1><p>查看支持的存储引擎可以使用<code>show engines;</code>命令</p><p>CSV存储引擎直接将表中的数据保存成CSV文件（因此每一列都不允许为空），我们可以使用vim直接查看或者编辑表中的数据（记得<code>flush tables;</code>），不支持索引，每次查询都会进行全表扫描，不适合大表和在线处理。该引擎可以作为数据交换的中间表（可以直接将excel导出为csv复制到mysql数据目录下）。</p><p>Archive存储引擎会使用zlib对表数据进行塔索，节省磁盘IO，数据文件的后缀为arz。只支持insert和select操作，只支持在自增id列上增加索引。使用场景是日志或者数据采集类的应用。</p><blockquote><p>tips:等值查找使用hash索引，而范围查找使用Btree索引。</p></blockquote><p>Memory存储引擎，也称为HEAP存储引擎，将数据保存在内存中。支持hash索引（默认）和Btree索引，索引字段都为固定长度，例如：<code>varchar(20) = char(20)</code>。不支持BLOB和TEXT等大字段。使用表级锁，所以尽管数据保存在内存中，并发性不见得比InnoDB高，表的大小由<code>max_heap_table_size</code>决定（默认16M）。该种存储引擎的应用场景是：用于查找或者映射表，例如邮编和地区的对应表和保存数据分析过程中的临时表。用于周期性聚合数据的结果表。由于Memory存储引擎的数据易丢失，所以要求数据是可以再生的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_c1 on t_memory(c1);  <span class="comment"># 在c1列上建立hash索引</span></span><br><span class="line">mysql&gt; create index idx_c2 using btree on t_memory(c2); <span class="comment"># 在c2列上建立BTree索引</span></span><br><span class="line">mysql&gt; show index from t_memory; <span class="comment"># 查看索引</span></span><br></pre></td></tr></table></figure><p>Federated存储引擎提供了访问远程MySQL服务器上表的方法，本地不存储数据，数据全部放在远程服务器上。本地需要保存表的结构和远程服务器的信息。默认禁止，我们可以在启动时增加federated参数,适合偶尔的统计分析或者手工查询。</p><p>不要在同一个数据库中使用多个存储引擎，这样可能导致潜在的bug,例如：事务失败回滚之后只有InnoDB上进行了回滚而myisam表的中的数据并没有进行回滚，出现的数据不一致的问题。</p><h1 id="MySQL服务器参数"><a href="#MySQL服务器参数" class="headerlink" title="MySQL服务器参数"></a>MySQL服务器参数</h1><p>mysql配置文件的加载顺序可以使用<code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code>命令进行查看</p><p>全局参数：<code>set global 参数名=参数值</code><br>会话参数：<code>set session 参数名=参数值</code></p><h2 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h2><p>要配置内存参数首先要弄清楚下面的几个问题：</p><ol><li>确定可以使用的内存上限</li><li>确定每个连接使用的内存（我们很容易犯的错误就是给每个连接分配的内存过大），主要有以下的几个参数：sort_buffer_size,join_buffer_size,read_buffer_size,read_rnd_buffer_size</li></ol><h2 id="IO配置参数"><a href="#IO配置参数" class="headerlink" title="IO配置参数"></a>IO配置参数</h2><h3 id="InnoDB-1"><a href="#InnoDB-1" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>innodb_log_file_size（单个事务日志的大小）和innodb_log_files_in_group（事务日志文件的个数）决定了InnoDB事务日志（Redo log的大小和数量），事务日志的总大小等于前两者的积。为了减少提交事务时产生的IO开销，InnoDB采用了预写日志的方式——也就是说在事务提交的时候会先写入到事务日志中，而不是每次都将修改后的数据文件刷新到磁盘中，因为事务的修改通常会将数据和索引映射到表空间的随机位置，所以刷新数据到文件将产生大量的随机IO，而记录日志所需要的则是顺序IO。所以相比于刷新脏数据到数据文件，记录日志的方式要快得多，一旦事务日志安全写入到磁盘中，事务就算是持久化了，因为即使是变更还没有写入到数据文件，如果这时候发生了服务器宕机，我们还是可以通过事务日志来恢复数据。</p><p>Innodb_flush_log_at_trx_commit:</p><p>0：每秒进行一次log写入到cache，并flush log到磁盘；<br>1：默认，每次事务提交的时候执行log写入cache并flush log到磁盘；<br>2：推荐，每次事务提交执行log写入cache，每秒执行一次flush log到磁盘。</p><p>Innodb_flush_method&#x3D;O_DIRECT<br>Innodb_file_per_table&#x3D;1<br>Innodb_doublewrite&#x3D;1,启用双写缓存，增加安全性</p><h4 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>delay_key_write，有3个值：<br>OFF：每次写操作后刷新键缓冲中的脏块到磁盘<br>ON：只对建表时制定了delay_key_write选项的表使用延迟刷新<br>ALL：对所有MyISAM表都使用延迟键写入。</p><h2 id="安全配置参数"><a href="#安全配置参数" class="headerlink" title="安全配置参数"></a>安全配置参数</h2><p>expire_logs_days，自用清理binlog的天数<br>max_allowed_packet，控制MySQL可以接收的包的大小<br>skip_name_resolve,禁用dns查找<br>sysdate_is_now,确保sysdate()返回正确的日期，主从复制相关<br>read_only,禁止非super选线的用户的写权限，建议在从复制中启用，可以保证主从复制的一致性。<br>skip_slave_start,禁用slave自动恢复</p><h1 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h1><p><em>基准测试</em>是一种测量和评估软件性能指标的活动，用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新基准测试以评估变化对性能的影响。是一种针对系统设置的压力测试，应该尽量直接、简单、易于比较，用于评估服务器的处理能力（压力测试是对真实的业务数据进行测试，获得真实系统所承受的压力，基准测试可能并不关心业务逻辑，所使用的查询和业务的真实性可以和业务环境没关系）</p><p>mysql 5.7自带了基准测试工具mysqlslap，可以模拟服务器负载并输出相关的统计信息。我们可以使用它的–help来查看参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlslap --concurrency=1,50,100,200 --iterations=3 --number-int-cols=5 --number-char-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement --engine=myisam,innodb --number-of-queries=10 --create-schema=benchmark_test</span><br></pre></td></tr></table></figure><p>我们可以使用<code>--print-only</code>参数来查看生成的sql脚本，如果出现快速滚屏的问题可以用管道：<code>cat bidfile.txt | less</code>。</p><p><a href="https://github.com/akopytov/sysbench">sysbench</a>是一款非常常用的测试工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=10000 run <span class="comment"># 测试CPU</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=fileio --file-total-size=10G prepare <span class="comment"># 文件IO测试，生成测试文件</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=fileio --number-thread=8 --init-rng=on --file-total-size=1G --file-test-mode=rndrw --report-interval=1 run <span class="comment"># 文件IO测试</span></span><br><span class="line">$ <span class="comment"># 使用该工具对数据库进行基准测试的时候需要建立对应的数据库</span></span><br><span class="line">mysql&gt; create database db_benchmark_test;</span><br><span class="line">mysql&gt; grant all privileges on *.* to benchmark_test@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>以上的准备工作已经做好，接下来进入到sysbench源码的<code>sysbench/tests/db</code>目录下（该目录下有现成的lua脚本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench --<span class="built_in">test</span>=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=db_benchmark_test --mysql-user=benchmark_test --mysql-password=123456 --oltp-tables-count=10 --mysql-socket=/tmp/mysql.sock prepare <span class="comment"># 生成测试数据</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=db_benchmark_test --mysql-user=benchmark_test --mysql-password=123456 --oltp-tables-count=10 --mysql-socket=/tmp/mysql.sock run <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><p>点击<a href="http://consoles.github.io/2016/07/22/mysql-best-practice/code/select-course.sql">这里</a>下载建表语句。数据库结构优化一方面是减少数据冗余，另一方面是尽量减少数据维护中出现的更新、插入和删除异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+                                                              </span><br><span class="line">| Field        | Type        | Null | Key | Default           | Extra                       |                                                              </span><br><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+                                                              </span><br><span class="line">| stu_no       | int(11)     | NO   | PRI | NULL              |                             |                                                              </span><br><span class="line">| stu_name     | varchar(10) | NO   |     | NULL              |                             |                                                              </span><br><span class="line">| birthday     | timestamp   | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |                                                              </span><br><span class="line">| course_name  | varchar(10) | NO   | PRI | NULL              |                             |                                                              </span><br><span class="line">| score        | int(11)     | YES  |     | NULL              |                             |                                                              </span><br><span class="line">| course_point | int(11)     | YES  |     | NULL              |                             |                                                              </span><br><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+   </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+                                                                           </span><br><span class="line">| stu_no | stu_name | birthday            | course_name | score | course_point |                                                                           </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+                                                                           </span><br><span class="line">|      1 | a        | 1993-07-07 00:00:00 | englisg     |  NULL |            9 |                                                                           </span><br><span class="line">|      1 | a        | 1993-07-07 00:00:00 | math        |  NULL |           10 |                                                                           </span><br><span class="line">|      2 | b        | 1983-07-17 00:00:00 | englisg     |  NULL |            9 |                                                                           </span><br><span class="line">|      2 | b        | 1983-07-17 00:00:00 | math        |  NULL |           10 |                                                                           </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+ </span><br></pre></td></tr></table></figure><p>首先以上的表中多次出现了冗余信息，姓名、课程、生日、学分都是冗余的</p><ul><li>插入异常：表中的某个实体随着另一个实体的存在而存在，如果缺少了某个实体就无法表示另一个实体。如果我们想要新加入一门语文课，学分是10分，但是没有任何学生选择这门课程。我们此时无法插入（因为学号是主键，但是没有默认值）</li><li>更新异常：更改表中某个实体的单独属性，需要对多行进行更新。如果我们将数学学分更新为15个学分，需要更新2行数据。——选课的学生越多，需要更新的数据越多</li><li>删除异常：删除表中的某个实体会导致其他实体消失。如果我们删除了所有选择数学的这门课的选课记录，数学这门课就不存在了。</li></ul><p>解决以上的三个异常的解决之道就是对数据库进行<a href="https://www.zhihu.com/question/24696366">范式化设计</a>。</p><p>1NF:列不可拆分<br>2NF：其他列完全依赖于主键列<br>3NF：消除传递依赖</p><blockquote><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。</p></blockquote><blockquote><p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>简单的解释，比如你和一个女生约会建立一张表，不用每条约会记录都记录她的身高、体重，将身高体重单独的存在一张表中供查询即可。</p></blockquote><blockquote><p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p></blockquote><p>范式化设计能够有效降低数据冗余，但是有时候一个简单的查询可能需要关联多张表，影响SQL的性能，我们可以通过<em>反范式化</em>设计以空间换时间。</p><p>范式化设计有较少的数据冗余，更行快速，但是缺点也是显而易见的：需要对多张表进行关联，很难进行索引优化。</p><blockquote><p>反范式化设计将所要查询的数据集中存储在一张表中，拥有较高的查询性能，因为在InnoDB存储引擎中，进行全表扫描的效率高于表之间的关联操作，因为全表扫描是顺序IO，而表关联是随机IO。如果我们需要查询的数据都在一张表中就可以使用覆盖索引进行性能优化。</p></blockquote><p>所以在实际的应用中，我们要结合范式化设计和反范式化设计。</p><h2 id="数据库物理设计"><a href="#数据库物理设计" class="headerlink" title="数据库物理设计"></a>数据库物理设计</h2><blockquote><p><em>为表中的字段选择合适的数据类型</em>：当一个列可以有选择多种数据类型的时候，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型，因为在数据库中数据处理是以页为单位的，每个页能够存储的数据是有限的（InnoDB中为16K）,越小代表每个页中能够容纳的数据越多，加载同样的数据时，使用宽度较小的数据类型比宽度大的数据类型加载的数据页少，减少磁盘IO。</p></blockquote><p><strong>有2点需要纠正<code>int</code>和<code>int(10)</code>之间没有任何区别。和大多数编程语言一样MySQL中的<code>float</code>和<code>double</code>数据类型通常是精确的，如果需要精确表示数字可以使用<code>decimal</code>类型</strong></p><p>decimal类型每4字节存储9个数字，小数点占用1个字节。<code>DECIMAL(18,9)</code>需要9个字节来存储，整数和小数部分各4个字节，小数部分1个字节。</p><p>VARCHAR和CHAR类型的存储与存储引擎有很大关系，其占用的空间是以字符计数，根据编码的不同占用不同的存储空间。前者是变长字符串，只占用必要的存储空间，例如：UTF8编码的字符串长度为10，则定义为<code>VARCHAR(10)</code>即可，列最大长度小于255则只占用一个额外的字节存储字符串长度，否则占用2个字节存储字符串长度。</p><p>VARCHAR的使用场景：字符串列的最大长度比平均长度大得多；字符串列很少被更新（字符串长度发生变化导致存储页的分页从而导致存储碎片）；使用了多字节字符集存储字符串（例如utf8字符串）。</p><p>字符串存储在<code>CHAR</code>类型的列中会删除末尾的空格，最大宽度为255.使用场景为：字符串长度近似（例如MD5,身份账号）；短字符串（例如：性别<code>CHAR(1)</code>和<code>VARCHAR(1)</code>后者将占用额外的1个字节存储字符串长度）；经常被更新的字符串（一次分配足够的内存空间，不会导致分页）</p><p><code>DATETIME</code>类型和时区无关，占用8byte存储空间，时间范围<code>1000-01-01 00:00:00</code>到<code>9999-12-31 23:59:59</code>,多数场景<br><code>TIMESTAMP</code>unix时间戳(格林尼治)，占用4byte，<code>1970-01-01</code>到<code>2038-01-19</code>，在行的数据修改的时候可以自动修改<code>TIMESTAMP</code>列的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(d1 DATETIME,d2 TIMESTAMP);</span><br><span class="line">mysql&gt; INSERT t VALUES(NOW(),NOW());</span><br><span class="line">mysql&gt; SET TIME_ZONE=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line">mysql&gt; SELECT * FROM t;</span><br></pre></td></tr></table></figure><h2 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h2><p>主键应该尽量小（索引占用空间），顺序增长（顺序IO），业务主键和数据库主键可以不同。数据库主键可以使用自增id，业务主键在数据库中可以使用唯一索引。</p><h1 id="表的拆分"><a href="#表的拆分" class="headerlink" title="表的拆分"></a>表的拆分</h1><ul><li>垂直拆分是将列拆分到不同的表。有2个原则：1.经常一起查询的列放在一起；2. text、blob等大字段拆分到附加表中。</li><li>水平拆分可以采用主键hash的方式，例如对uid对100进行mod操作。</li></ul><h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><p>给 MySQL 大表加字段的思路如下：</p><ol><li>创建一个临时的新表，首先复制旧表的结构（包含索引）<code>create table new_table like old_table</code>;</li><li>给新表加上新增的字段</li><li>把旧表的数据复制过来 <code>insert into new_table(filed1,filed2…) select filed1,filed2,… from old_table</code></li><li>删除旧表，重命名新表的名字为旧表的名字</li></ol><p>需要注意下，执行第三步的时候，可能这个过程也需要时间，这个时候有新的数据进来，所以原来的表如果有字段记录了数据的写入时间就最好了，可以找到执行这一步操作之后的数据，并重复导入到新表，直到数据差异很小。不过还是会可能损失极少量的数据。所以，如果表的数据特别大，同时又要保证数据完整，最好停机操作。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纳兰容若词传</title>
      <link href="/2016/07/07/nalanrongruo/"/>
      <url>/2016/07/07/nalanrongruo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>西方人通过精密仪器测量出人死后体重会减少21g，于是认为这21g是灵魂的重量。</p></blockquote><blockquote><p>拼来的才是人生，等来的只能是命运。</p></blockquote><blockquote><p>洋葱，萝卜和西红柿，不相信世界上有南瓜这种东西。他们认为那是一种空想，南瓜不说话，默默地生长着。</p></blockquote><blockquote><p>得不到人们认同的想法不能称之为想法，不为人知的结果也毫无价值。因为这些都不能对他人产生影响。</p></blockquote><blockquote><p>思考要单纯直接，实现要严密细致。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纳兰容若 </tag>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 初探</title>
      <link href="/2016/06/21/learn-mysql/"/>
      <url>/2016/06/21/learn-mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>信息的价值会随时间锐减，尤其在事故处理过程中。</p></blockquote><h1 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h1><ul><li>父表和子表（有外键的表称为子表）必须使用相同的存储引擎，且存储引擎必须为InnoDB.外键列和被参照列的数据类型要相同，外键约束将自动创建索引。</li><li>查看建表语句可以使用<code>SHOW CREATE TABLE t_users;</code></li><li>查看索引<code>SHOW INDEXES FROM t_users\G;</code></li></ul><blockquote><p>在实际的开发中我们很少使用物理的外键约束，因为只有InnoDB这种引擎支持。所谓逻辑上的外键约束是在定义表的时候按照某种结构进行定义而不去使用foreign key这个关键字。业务爆炸的时候DB外键的约束可能对分库分表不友好。</p></blockquote><p>mysql中的索引默认是BTree索引。</p><p>参见<a href="https://coding.net/u/consoles/p/learn-mysql/git/blob/master/foreign-key.sql">外键约束</a></p><h2 id="表结构的修改"><a href="#表结构的修改" class="headerlink" title="表结构的修改"></a>表结构的修改</h2><p>参见<a href="https://coding.net/u/consoles/p/learn-mysql/git/blob/master/modify-table.sql">修改表</a></p><h2 id="无限分类的表的设计"><a href="#无限分类的表的设计" class="headerlink" title="无限分类的表的设计"></a>无限分类的表的设计</h2><p>例如：天猫的商品：图书下面有小说、文学，在文学下面有四大名著、戏曲等。无限分类的表一般采用如下形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> tdb_goods_types(</span><br><span class="line">type_id <span class="type">SMALLINT</span> UNSIGNED <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">type_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">parent_id <span class="type">SMALLINT</span> UNSIGNED <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查询的时候要根据自身连接。</p><h2 id="MySQL常用脚本"><a href="#MySQL常用脚本" class="headerlink" title="MySQL常用脚本"></a>MySQL常用脚本</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_users <span class="keyword">ORDER</span> <span class="keyword">BY</span> rand(); <span class="comment">-- mysql输出的行随机排列</span></span><br></pre></td></tr></table></figure><h2 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h2><p>在终端输入SQL语句后MySQL引擎做了下面的事情：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-procedure.png" alt="MySQL引擎解析SQL的过程"></p><p>如果我们省略了SQL语句的语法解析和编译的过程，数据库的效率将会提高。</p><blockquote><p><em>存储过程</em>是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。在首次执行的时候和SQL语句耗时相同，但是以后执行的时候直接从内存中读取；减少了http流量（只需要传递存储过程的名字和必要的参数）。</p></blockquote><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><ul><li>MyISAM</li><li>InnoDB</li><li>Memory</li><li>CSV</li><li>Archive</li></ul><blockquote><p>读锁具有共享性，而写锁具有排他性。<br>BlackHole存储引擎（黑洞引擎）写入的数据都会丢失，一帮用于数据复制的中继。</p></blockquote><p>Q1：为什么表锁比行锁开销小？<br>A1：表锁整张表只需要一个锁，而行锁对于一张表来说可能需要多个。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-store-engine.png" alt="MySQL存储引擎"></p><h2 id="备份和还原MySQL"><a href="#备份和还原MySQL" class="headerlink" title="备份和还原MySQL"></a>备份和还原MySQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldump -uniuniu -pniuniu@123 --all-databases &gt; data.sql <span class="comment"># 备份</span></span><br><span class="line">$ <span class="built_in">source</span> ~/Downloads/data.sql <span class="comment"># 还原数据库</span></span><br></pre></td></tr></table></figure><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对用户进行密码的授权</span></span><br><span class="line">$ grant all on *.* to niuniu@<span class="string">&#x27;%.%.%.%&#x27;</span> identified by <span class="string">&#x27;niuniu@123&#x27;</span>;</span><br><span class="line">$ flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>外键将表分开，而连接将表中的数据归并显示。</p></blockquote><p>注：本项目所有源码参见<a href="https://coding.net/u/consoles/p/learn-mysql/git">coding.net</a>。</p><p><a href="https://www.zhihu.com/question/24495736">查看多张表中相同字段的最大值</a></p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tagid bookid tagname</span><br><span class="line">1      10    php</span><br><span class="line">2      10    web</span><br><span class="line">3      8     php</span><br><span class="line">4      9     ruby </span><br></pre></td></tr></table></figure><p>找出tagname同时包含web和php的书：需要用到同一张表的连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tags <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tags t <span class="keyword">ON</span> tags.bookid <span class="operator">=</span> t.bookid <span class="keyword">WHERE</span> tags.tagname <span class="operator">=</span> <span class="string">&#x27;php&#x27;</span> <span class="keyword">AND</span> t.tagname <span class="operator">=</span> <span class="string">&#x27;web&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D2前端</title>
      <link href="/2016/06/20/D2-frontend/"/>
      <url>/2016/06/20/D2-frontend/</url>
      
        <content type="html"><![CDATA[<h1 id="使用node构建海量页面渲染服务"><a href="#使用node构建海量页面渲染服务" class="headerlink" title="使用node构建海量页面渲染服务"></a>使用node构建海量页面渲染服务</h1><p>手机天猫的所有页面都是,大约在3年前天猫的大量页面是基于php渲染的，数据模板打包后推送到CDN，每次请求都渲染页面。用户请求CDN上的资源。但是这样的方式存在以下的弊端：</p><ul><li>大量文件在网络情况不一的CDN节点上同步非常困难</li><li>每次请求渲染导致大量的机器资源浪费</li><li>php太灵活，多业务共享难以升级，性能低</li></ul><p>node.js具有以下的优势：</p><ul><li>js模板可以前后端共享</li><li>轻量级、高性能</li></ul><p>2014年的天猫双十一从php迁移到了node</p><p>koajs中的基于装饰器的中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">responseTime</span>(<span class="params">next</span>)&#123;</span><br><span class="line">    <span class="comment">// 所有后续中间件之前执行</span></span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">yield</span> next;</span><br><span class="line">    <span class="comment">// 所有后续中间件之后执行</span></span><br><span class="line">    <span class="keyword">const</span> used = <span class="title class_">Date</span>.<span class="title function_">now</span>() - start</span><br><span class="line">    <span class="comment">// 将响应时间设置到http header</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>,<span class="string">`<span class="subst">$&#123;used&#125;</span> ms`</span>)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">errorHandler</span>(<span class="params">next</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        logger.<span class="title function_">error</span>(err)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="number">500</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">body</span> = err.<span class="property">message</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPA最常见的问题就是页面中充满了大量的ajax请求，一个解决办法就是合并ajax请求，例如：<a href="http://netflix.github.io/falcor/">falcor</a></p><h1 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/react-native.png" alt="React Native原理图"></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass与compass实战</title>
      <link href="/2016/06/18/sass-compass/"/>
      <url>/2016/06/18/sass-compass/</url>
      
        <content type="html"><![CDATA[<h1 id="Sass，Compass与CSS3者的关系"><a href="#Sass，Compass与CSS3者的关系" class="headerlink" title="Sass，Compass与CSS3者的关系"></a>Sass，Compass与CSS3者的关系</h1><blockquote><p>曾经有一位古人说过：“如果你有一把锤子，那么所有的东西都会看起来像钉子。”；还有一位今人说过：“如果你有一颗钉子，那么你就会满大街找锤子。”。无论锤子亦或是钉子都是工具，而Compass和SASS恰恰扮演的就是锤子和钉子的角色，CSS则对应使用锤子和钉子最后完成的作品。——慕课网讲师·刘炬光</p></blockquote><blockquote><p>人们走进喧闹中去，是为了忘记孤寂。</p></blockquote><blockquote><p>人生不止眼前的苟且，还有诗和远方。——高晓松</p></blockquote><h1 id="compass初窥"><a href="#compass初窥" class="headerlink" title="compass初窥"></a>compass初窥</h1><p>安装好sass和compass后创建compass项目<code>compass create compass-in-action</code>(更多命令可以使用<code>compass --help</code>查看)</p><p>接下来我们在项目根目录下可以使用<code>compass watch</code>命令监听sass文件的变化</p><h1 id="compass核心模块概述"><a href="#compass核心模块概述" class="headerlink" title="compass核心模块概述"></a>compass核心模块概述</h1><p>我们只要执行了<code>@import &quot;compass&quot;</code>就会引入核心的5个模块，依次是：CSS3，Helpers（多是函数），Typography，Utilities（多事mixin）和Browser（配置默认支持哪些浏览器）。但是以下的2歌模块需要明确引入：</p><ul><li>reset:<code>@import &quot;compass/reset&quot;</code></li><li>layout:<code>@import &quot;compass/layout&quot;</code></li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/compass-core-module.png" alt="compass核心模块"></p><p><a href="http://compass-style.org/reference">compass</a>的周边生态非常丰富，我们可以使用<code>gem install compass-normalize</code>来安装normalize插件来替代默认的reset。然后修改<code>config.rb</code>即可。</p><h2 id="layout模块"><a href="#layout模块" class="headerlink" title="layout模块"></a>layout模块</h2><p>该模块又引入了3个子模块：</p><ul><li>grid-background：根据指定的颜色生成背景填充。</li><li>sticky-footer:footer自动位于底部。</li><li>stretching:绝对定位并且可以设定上右下左的值。</li></ul><h2 id="css3模块和browser-support模块"><a href="#css3模块和browser-support模块" class="headerlink" title="css3模块和browser support模块"></a>css3模块和browser support模块</h2><p>该模块提供了跨浏览器的CSS3的支持，compass为我们封装了针对浏览器差异的mixin，只需要调用即可，不必关心具体差异。</p><p>有时候我们只需要兼容webkit内核（例如webapp），不需要兼容moz和opera，这时我们可以配置brower support模块，让它针对某个浏览器的特定版本生成代码。</p><h2 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h2><p>该模块主要用于修饰文本样式、垂直韵律等。</p><h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><ul><li>sass中通过<code>@include</code>指令调用mixin。</li><li>sass两种语法的转换可以使用<code>sass-convert</code>命令。</li><li>css要注意语义化。例如对于一个错误消息红色字体，我们一般的做法是定义一个<code>.red</code>类，但是更推荐的做法是定义一个<code>.error</code>类。</li><li>可以使用<code>@debug</code>指令生成日志。</li><li>可以使用<code>compass interactive</code>进入compass的REPL模式进行交互。</li><li>隐藏文字，可以将text-indent设置为无穷，overflow:hidden；还可以将字体设置为0，颜色设置为透明。</li><li>表格的第一行和表格的第一列都要使用<code>&lt;th&gt;</code>标签，都是表头。</li><li>图标字体可以在<a href="https://icomoon.io/">icomoon</a>上找到。</li><li>注意：<code>::after</code>和<code>::before</code>这样的伪元素必须指明<code>content</code>这个属性,<code>content</code>中的换行可以使用<code>\A</code>并设置<code>white-space: pre;</code>。</li><li>滚动条大部分是位于html上的，而对于像chrome这样的浏览器，它是位于body上的。</li><li>快速填充文本产生滚动条，可以巧用emmenet语法：<code>p&#123;text&#125;*100</code>。</li></ul><p>本节代码可以到：<a href="https://coding.net/u/consoles/p/compass-sass/git/tree/master">coding.net</a>找到。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>Q1:css中原生的<code>@import</code>指令有什么弊端？<br>A1:该指令必须放在最前面；最性能不利，浏览器解析到高指令的时候将会被阻塞去下载被引入的css。</p><p>Q2:为什么CSS选择符越长，渲染性能越低下？<br>A2:因为浏览器渲染样式的时候总是从最内侧的样式渲染到最外面，直到遇到html这个标记。所以CSS选择符不应该过多嵌套，最佳实践是取较长的CSS类名代替嵌套，但是这样代码的结构又变得不太清晰，sass的<code>@at-root</code>指令很好解决了这个问题。虽然我们嵌套书写了，但是最终生成的CSS却是不包含嵌套的。</p><p>Q3:<a href="http://requirejs.org/">require.js</a>存在的意义是什么？<br>A3：①将代码封装在模块内部，可以避免命名冲突（项目的后期新加入一些童鞋可能变量命名和前面的重复了）；②声明不同js文件之间的依赖；③可以让我们写出模块化的JavaScript代码，方便以后的复用，也便于职责分工。</p><p><em>我们可以使用<a href="http://koala-app.com/index-zh.html">koala图形化工具</a>来实时编译less、sass和coffee</em></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> sass </tag>
            
            <tag> compass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift 学习</title>
      <link href="/2016/06/17/learn-swift-basic/"/>
      <url>/2016/06/17/learn-swift-basic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果学习的硬件和软件资源已经具备，那么接下来的事情就是保持一颗永远向上的心，如果学习累了，遇到困难了，遇到挫折了，那么就想想那些精美的、绝妙的app，想想这些app将来也会出自你的手中，相信每一位同学都可以成为IOS开发大师的。 ————慕课网讲师·刘宇波</p></blockquote><p>学习swift最简单的方法是使用Xcode的playground。</p><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><h3 id="常量let"><a href="#常量let" class="headerlink" title="常量let"></a>常量let</h3><p>swift特意将常量的优先级提高到和变量相同实际上是在鼓励我们使用常量，思考程序什么时候使用常量。这样程序可以进行更好的优化。</p><h3 id="变量var"><a href="#变量var" class="headerlink" title="变量var"></a>变量var</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">2</span>,b <span class="operator">=</span> <span class="number">3</span>,c <span class="operator">=</span> <span class="string">&quot;hello swift&quot;</span>,d <span class="operator">=</span> <span class="number">3.2</span></span><br><span class="line"><span class="comment">// a = &quot;abc&quot; cannot assign a value of type &#x27;String&#x27; to a value of type &#x27;Int&#x27;</span></span><br></pre></td></tr></table></figure><p>以上的代码中我们并没有显式指定变量的类型，那么是否swift就和js一样是弱类型的语言呢？答案是否定的。swift是<em>强类型</em>的语言。我们可以按住option键然后点击变量名称查看变量类型。我们还可以显式声明变量的类型，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, c:<span class="type">Double</span></span><br><span class="line"><span class="keyword">var</span> imInt:<span class="type">Int</span> <span class="operator">=</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>swift语言有一种Type inference机制能够自动确定变量的类型。<br>整型的存储是有范围的，具机器芯片架构而定。我们可以使用<code>Int.max</code>和<code>Int.min</code>来查看，当整型溢出的时候在编译时刻即可察觉。所以它宣称自己是一门安全的语言。除了整型外，还有<code>UInt</code>，<code>Int8</code>,<code>Int16</code>等等。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">9999999999999999999</span> <span class="comment">// integer literal &#x27;9999999999999999999&#x27; overflows when stored into &#x27;Int&#x27;</span></span><br></pre></td></tr></table></figure><p>swift提供了一个很酷的特定，可以使用下划线分隔数字，从而更方便表示位数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">UInt</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">100_0000</span> <span class="comment">// 1000000</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">100_000_000</span> <span class="comment">// 10000000</span></span><br></pre></td></tr></table></figure><p>和很多的编程语言不一样，swift并不提供<em>隐式类型转换</em>（因为很多的错误根源在此处）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x:<span class="type">UInt16</span> <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> y:<span class="type">UInt8</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">x <span class="operator">+</span> y <span class="comment">// overloads for &#x27;+&#x27; exist with these partially matching parameter lists: (UInt8, UInt8), (UInt16, UInt16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是正确的代码</span></span><br><span class="line"><span class="keyword">let</span> m <span class="operator">=</span> x <span class="operator">+</span> <span class="type">UInt16</span>(y)</span><br><span class="line"><span class="keyword">let</span> n <span class="operator">=</span> <span class="type">UInt8</span>(x) <span class="operator">+</span> y</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>将多个不同的值集合到一个数据中。可以有任意多个值，不同的值可以是不同的类型。适合轻量级的数据聚合。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tuple</span></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> (<span class="number">5</span>,<span class="number">2</span>) <span class="comment">// 使用元组表示二维平面中的点</span></span><br><span class="line"><span class="keyword">var</span> httpResponse <span class="operator">=</span> (<span class="number">404</span>,<span class="string">&quot;Not Found&quot;</span>) <span class="comment">// 使用元组保存http状态码</span></span><br></pre></td></tr></table></figure><p>我们也可以显示指定元组中各个字段类型，可以使用<code>.序号</code>的方式拿到它的分量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> httpResponse:(<span class="type">Int</span>,<span class="type">String</span>) <span class="operator">=</span> (<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">httpResponse.<span class="number">0</span></span><br><span class="line">httpResponse.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> (x:<span class="number">1</span>,y:<span class="number">2</span>)</span><br><span class="line">point.x</span><br><span class="line">point.y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名元组分量</span></span><br><span class="line"><span class="keyword">let</span> p:(x:<span class="type">Int</span>,y:<span class="type">Int</span>) <span class="operator">=</span> (<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">p.x</span><br><span class="line">p.y</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loginRes <span class="operator">=</span> (<span class="literal">true</span> ,<span class="string">&quot;consoles&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> ( isLoginSuccess ,<span class="keyword">_</span> ) <span class="operator">=</span> loginRes <span class="comment">// 我们仅关心第一个元素解包的值</span></span><br><span class="line"><span class="keyword">if</span> isLoginSuccess &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;login success&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;login failure&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元组解包"><a href="#元组解包" class="headerlink" title="元组解包"></a>元组解包</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> httpResponse:(<span class="type">Int</span>,<span class="type">String</span>) <span class="operator">=</span> (<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> (code,msg) <span class="operator">=</span> httpResponse</span><br><span class="line">code <span class="comment">// 200</span></span><br><span class="line">msg <span class="comment">// &quot;OK&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>在Swift中多行注释非常智能，我们可以在多行注释中插入任何内容（包括多行注释）不会带来解析问题。</p></blockquote><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h2><ul><li>闭区间运算符：<code>a...b</code></li><li>前闭后开区间运算符：<code>a..&lt;b</code></li></ul><blockquote><p><code>for in</code>循环要求我们必须将范围里面的值跑一遍不可跳过。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span>&#123;</span><br><span class="line">    index <span class="comment">// 1,2,3,4 ... 10</span></span><br><span class="line">    <span class="comment">// index = 5 此处的index是let类型，尝试修改会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">..&lt;</span><span class="number">10</span>&#123;</span><br><span class="line">  index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们不需要知道循环中每个元素的具体值，仅仅知道它们执行的次数就行了，这时我们可以就像<em>元组解包那样使用<code>_</code>来忽略值</em>,例如以下的程序计算2^10:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> base <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> pow <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>pow&#123;</span><br><span class="line">    result <span class="operator">*=</span> base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><ul><li>和其他语言类似，只不过swift中的<code>do-while</code>循环被改变成了<code>repeat-while</code>循环。</li><li>swift中case语句默认有<code>break</code>，防止case穿透。对于其他语言中的多个case执行同一个语句的时候只需要在case中使用都逗号分隔。</li></ul><h2 id="swift的高级用法"><a href="#swift的高级用法" class="headerlink" title="swift的高级用法"></a>swift的高级用法</h2><h2 id="swift的注意事项"><a href="#swift的注意事项" class="headerlink" title="swift的注意事项"></a>swift的注意事项</h2><p>我们要枚举出switch中所有的情况，如果我们的case无法匹配所有的情况，就需要添加<code>default</code>语句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="operator">-</span><span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//default:() 这里不能注释，因为我们要枚举所有的Int值或者我们也可以使用default:break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句扩充了对元组的支持</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> (<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> vector&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">1</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x轴正方向上的单位向量&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="operator">-</span><span class="number">1</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x轴负方向上的单位向量&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y轴正方向上的单位向量&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="operator">-</span><span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y轴负方向上的单位向量&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;仅仅是一个普通向量&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用下划线来忽略元组中某一维度的值，从而一定程度上做到了<em>模式匹配</em>。我们也可以对元组中的某个分量进行区间运算例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector <span class="operator">=</span> (x:<span class="number">1</span>,y:<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> vector&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">_</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(vector.x)</span>,<span class="subst">\(vector.y)</span>)向量在x轴上&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(vector.x)</span>,<span class="subst">\(vector.y)</span>)向量在y轴上&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>,<span class="operator">-</span><span class="number">2</span><span class="operator">...</span><span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(vector.x)</span>,<span class="subst">\(vector.y)</span>)向量在原点附近&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;仅仅是一个普通向量&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元组的解包也可以融入到case语句中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point:(<span class="type">Int</span>,<span class="type">Int</span>) <span class="operator">=</span> (<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">switch</span> point&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在x轴上，x = <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在y轴上，y = <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x,<span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;普通向量:(<span class="subst">\(x)</span>,<span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上的语句不需要default，因为已经涵盖了所有的可能</span></span><br></pre></td></tr></table></figure><p>对于常用的case贯穿的情况，swift提供了<code>fallthrough</code>关键字，能够在执行完一个case之后跳转到下一个case。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point:(<span class="type">Int</span>,<span class="type">Int</span>) <span class="operator">=</span> (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> point&#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原点&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">_</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在x轴上&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="keyword">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在y轴上&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;普通向量&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个实际问题：找出方程x^4 - y^2 &#x3D; 15 * x * y在300以内的第一个整数解,使用swift，我们可以这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给最外层的循环设置一个label</span></span><br><span class="line">findAnswer:</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">300</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">300</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> m <span class="operator">*</span> m <span class="operator">*</span> m <span class="operator">*</span> m <span class="operator">-</span> n <span class="operator">*</span> n <span class="operator">==</span> <span class="number">15</span> <span class="operator">*</span> m <span class="operator">*</span> n&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;找到一组解，m = <span class="subst">\(m)</span>,y = <span class="subst">\(n)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span> findAnswer</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就给swift加上了goto语句的特性。</p><h3 id="switch中的where"><a href="#switch中的where" class="headerlink" title="switch中的where"></a>switch中的where</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> (<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">switch</span> p &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x,y) <span class="keyword">where</span> x <span class="operator">==</span> y: <span class="comment">// 先解包然后执行判断逻辑</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点在y=x这条正比例函数上&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x,<span class="keyword">let</span> y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点在y=-x这条正比例函数上&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x,y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;普通点&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-case"><a href="#if-case" class="headerlink" title="if case"></a>if case</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age <span class="operator">=</span> <span class="number">19</span></span><br><span class="line"><span class="keyword">switch</span> age &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span><span class="operator">...</span><span class="number">19</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;青少年&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成年&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="number">10</span><span class="operator">...</span><span class="number">19</span> <span class="operator">=</span> age&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;青少年&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="number">10</span><span class="operator">...</span><span class="number">19</span> <span class="operator">=</span> age <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;青少年，大学生&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">100</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> i <span class="operator">%</span> <span class="number">3</span> <span class="operator">==</span> <span class="number">0</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">100</span> <span class="keyword">where</span> i <span class="operator">%</span> <span class="number">3</span> <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>guard关键字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">buy</span>(<span class="params">money</span>:<span class="type">Int</span>,<span class="params">price</span>:<span class="type">Int</span>,<span class="params">capacity</span>:<span class="type">Int</span>,<span class="params">volume</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> money <span class="operator">&gt;</span> price &#123;</span><br><span class="line">        <span class="keyword">if</span> capacity <span class="operator">&gt;</span> volume &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;买买买,剩余的钱：<span class="subst">\(money <span class="operator">-</span> price)</span>,背包容量：<span class="subst">\(capacity <span class="operator">-</span> volume)</span>&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;背包容量不够&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;钱不够&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">buy2</span>(<span class="params">money</span>:<span class="type">Int</span>,<span class="params">price</span>:<span class="type">Int</span>,<span class="params">capacity</span>:<span class="type">Int</span>,<span class="params">volume</span>:<span class="type">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">guard</span> money <span class="operator">&gt;=</span> price <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not engugh money&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> capacity <span class="operator">&gt;=</span> volume <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Not engugh capacity&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数主体</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;买买买,剩余的钱：<span class="subst">\(money <span class="operator">-</span> price)</span>,背包容量：<span class="subst">\(capacity <span class="operator">-</span> volume)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的逻辑很容易使用if-else实现，但是苹果为什么会推崇使用guard关键字呢，它就是提倡将于业务无关边界判断剥离开来，踏踏实实集中于程序的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 移动开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学之美</title>
      <link href="/2016/06/17/beauty-of-mathematics/"/>
      <url>/2016/06/17/beauty-of-mathematics/</url>
      
        <content type="html"><![CDATA[<blockquote><p>教育的本质不是将篮子填满，而是将灯点亮。</p></blockquote><blockquote><p>简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。 —— 蒂姆·博纳斯·李</p></blockquote><blockquote><p>Virture is like a rich stone,best plain set.(美德如同宝石，在朴素的映衬下最显华丽) —— 培根</p></blockquote><blockquote><p>爱是一念之差，最幸福的不过是，你曾经的呼唤，而我恰有过应答。 —— 朝小诚《黑白》</p></blockquote><blockquote><p>技术分为术和道2种。具体的做事方法是术，做事的原理和原则是道。很多具体的技术很快就会从独门绝技到普及，再到落伍，追求术的人一辈子很辛苦，只有掌握了道才能够做到游刃有余。追求“术”的人多半抱有侥幸心理，想走捷径，但真正做好一件事没有捷径，需要一万小时的专业训练和努力，也就是“一万小时定律”。</p></blockquote><blockquote><p>中国古代的阴阳学说可以看做是二进制的雏形。</p></blockquote><blockquote><p>数据库索引和布尔代数息息相关。</p></blockquote><blockquote><p>网络爬虫一般的步骤是“下载-索引-排序”，其中广度优先遍历用得比较多。</p></blockquote><blockquote><p>完全随机的高斯白噪声是很难消除的。</p></blockquote><h2 id="文字语言-VS-数字和信息"><a href="#文字语言-VS-数字和信息" class="headerlink" title="文字语言 VS 数字和信息"></a>文字语言 VS 数字和信息</h2><blockquote><p>信息的冗余是信息安全的保障。信息的作用在于消除不确定度。</p></blockquote><blockquote><p>阿拉伯数字的发明人其实是古印度人，阿拉伯人其实是二道贩子。</p></blockquote><blockquote><p>从象形文字到拼音文字是一个飞跃，因为人们在描述物体的外表到抽象的概念，同时不自觉采用了对信息的<em>编码</em>。常用字笔画少，生僻字笔画多，完全符合信息论中的<strong>最短编码原理</strong>,省材料省时间。</p></blockquote><blockquote><p>在通信时如果信道较宽，就可以直接传输；如果信道较窄就需要在通信前尽可能压缩，在接收端进行解压。将日常白话写成精简的文言文本质上是压缩。</p></blockquote><blockquote><p>犹太学者在抄写《圣经》的时候采用了校验码机制。将每一个字母映射为一个数字。将每一行的数字加起来得到一个奇怪的数字，就是这一行的校验码，同理可以得出每一列的校验码。如果某一行的校验码有差别就知道该行有错，再次判断每一列的校验码，即可快速定位。</p></blockquote><h2 id="自然语言处理——从规则到统计"><a href="#自然语言处理——从规则到统计" class="headerlink" title="自然语言处理——从规则到统计"></a>自然语言处理——从规则到统计</h2><p>图灵测试：让人和机器进行交流，如果人无法判断自己交流的对象是人还是计算机，就说明机器具有了智能。</p><p>莱特兄弟发明飞机依靠的是空气动力学而不是仿生学。今天的机器翻译和语音识别并不是计算机理解了自然语言，他们全部依靠的是统计学。</p><p>程序设计语言是上下文无关文法，而自然语言是上下文有关文法。</p><h2 id="隐含马尔科夫模型"><a href="#隐含马尔科夫模型" class="headerlink" title="隐含马尔科夫模型"></a>隐含马尔科夫模型</h2><p>雅格布森通信6要素：信源、信道、信息、接受者、上下文和编码。</p><p>马尔马夫模型指的是随机过程中的每个状态都只和它前面的一个状态有关。例如：明天的天气只和今天的天气有关而和昨天的无关。这种假设未必正确，但是在不少的棘手的问题上都得到了近似解。该模型首先应用于通信领域，继而推广到语音和语言处理，也是机器学习的主要工具。机器学习依靠一个训练算法（鲍姆-卡尔其算法）和使用时的解码算法（维特比算法）。</p><h2 id="通信的度量和所用"><a href="#通信的度量和所用" class="headerlink" title="通信的度量和所用"></a>通信的度量和所用</h2><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>主要用来评价信息量。一条信息的信息量和它的<em>不确定性</em>有着直接的关系。例如如果我们对某件事一无所知就需要了解大量的信息。变量的不确定性越大，熵越大。同样字数的书，所含信息量可能相差很多。如果一本书重复内容多，它的信息量就小，冗余度就大。汉语的冗余度相对较小，这也暗示了“汉语是最简单的语言”。几乎所有的自然语言处理信息和信号处理的应用都是一个消除不确定性的过程。</p><h2 id="Google-PageRank算法"><a href="#Google-PageRank算法" class="headerlink" title="Google PageRank算法"></a>Google PageRank算法</h2><p>如果一个网页被其他许多网页所链接，说明它受到承认和信赖，那么它的排名就高。类似于明主表决，网页排名高的网站共享的链接权重大。该算法的核心是矩阵相乘，利用稀疏矩阵进行化简，使用MapReduce（本质上是分治）并行计算工具进行计算。</p><h2 id="信息指纹和网络爬虫"><a href="#信息指纹和网络爬虫" class="headerlink" title="信息指纹和网络爬虫"></a>信息指纹和网络爬虫</h2><p>在网络爬虫中为了防止重复下载同一url需要将其放到hash表中。但是以字符串的形式存储浪费空间（哈希表的存储效率一般只有50%），查找也耗时（网址一般很长）。我们可以将这些url映射为128比特的二进制，我们只需要16个字节存储一个网址，同时这个整数的查找效率远远高于字符串。</p><h2 id="从判定集合相等问题到YouTube视频反盗版"><a href="#从判定集合相等问题到YouTube视频反盗版" class="headerlink" title="从判定集合相等问题到YouTube视频反盗版"></a>从判定集合相等问题到YouTube视频反盗版</h2><p>判定集合相同一般有以下的几种做法：</p><ol><li>一一比较,O(N^2)</li><li>排序比较，O(NlgN)</li><li>哈希表，O(N),但需要额外存储空间</li><li>分别计算每个元素的指纹并相加（我们可以联想到java中的hashCode方法）</li></ol><p>将以上的算法4稍加改动就可以用来判断文章是否抄袭——将文章切分成小段，找出关键词集合，计算指纹，根据时间先后就可以找出原创和抄袭的文章。YouTube的视频反盗版也是提取关键帧（视频中绝大多数是过渡帧），对关键帧进行指纹。</p><h2 id="图论和欧拉七桥"><a href="#图论和欧拉七桥" class="headerlink" title="图论和欧拉七桥"></a>图论和欧拉七桥</h2><blockquote><p>每个顶点和它连接的边称为<em>度</em>。如果一个图能够从一个顶点出发，每条边不重复走一遍然后回到这个顶点，那么这一顶点的度必为偶数。</p></blockquote><p>我们可以这样证明以上结论：如果能够遍历图的每条边各一次。那么对于每个顶点进入和离开顶点的次数是相同的，因此对于每个顶点有多少条进入的边就有多少条出去的边。每个顶点相连边的数量成对出现，即：每个顶点的度都是偶数。</p><h2 id="新闻分离和余弦定理"><a href="#新闻分离和余弦定理" class="headerlink" title="新闻分离和余弦定理"></a>新闻分离和余弦定理</h2><p>金融类的新闻中股票、利息、债券、银行等词出现的几率较高；而二氧化碳、宇宙、诗歌、木匠、诺贝尔等词出现的较少。如果两个新闻属于同一类，他们的特征向量在某几个维度的值比较大，而其他维度的值比较小。</p><p>余弦定理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a^<span class="number">2</span> = b^<span class="number">2</span> + c^<span class="number">2</span> - 2bcCosA</span><br></pre></td></tr></table></figure><p>证明可以使用向量法。勾股定理其实是夹角为π&#x2F;2时的余弦定理。向量的夹角为0表示两条新闻完全相同。余弦定理也可以用来处理<strong>聚类问题</strong>。</p><h2 id="VCD分解"><a href="#VCD分解" class="headerlink" title="VCD分解"></a>VCD分解</h2><ul><li>View，视觉</li><li>Controller，控制</li><li>Data，数据</li></ul><blockquote><p>解决问题的两大必要条件：首先要有好的思路，如果方向不对，再怎么努力也无法到达目的地；同时，扎实的基础、毅力、效率也非常重要，否则只能是空中楼阁、纸上谈兵。– 金出武雄《像外行一样思考，像专家一样实践》</p></blockquote><p>跳出现有的成功往往是最困难的。像外行一样自由发散地想出创意、以专业人士的方法去付诸实现，这种思路是非常必要的。</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>是现代密码学RSA算法的基础。</p></blockquote><blockquote><p>编辑器中常见的撤销和重试可以使用使用stack这种数据结构来保存。</p></blockquote><blockquote><p>白名单应用是众多二分查找算法的用例之一。</p></blockquote><h2 id="怪诞心理学"><a href="#怪诞心理学" class="headerlink" title="怪诞心理学"></a>怪诞心理学</h2><blockquote><p>1.女性的征友广告如果让男性来写往往会带来更多的回应，但是男性的征友广告如果换成女性来写就不会有这种效果。<br>2.蒙娜丽莎的微笑之所以那么什么是达芬奇出色的画法所致。如果你看着她的眼睛，她的笑容就会非常明显，而且非常迷人。如果看她的嘴唇，微笑就消失了。<br>3.有些看起来很诡异的体验，例如感觉到有神秘的东西存在，事实上都是风吹过打开的窗户时产生的低频声波所致。<br>4.夏季出生的人比冬季出生的人更幸运一些，出生时的温度差异让夏季出生的人更乐观积极，而且更容易把握身边的机会。<br>5.鉴别谎言的最佳方法是取聆听而不是去观看。说谎者通常说的话不多，不会给出太多的细节，而且使用表示“我”的单词I的频率远远低于说真话的人。<br>6.真心的笑容和虚假的笑容之间的差异都写在了人的眼睛上；当人们露出真心的笑容时，眼睛周围的皮肤会形成皱纹；当人们假笑时，眼睛周围的皮肤就依然是平平的。</p></blockquote><h2 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">等价关系</a>是一种二元关系，满足自反性(x等价x自身)、对称性(若x等价y,则y等价x)和传递性（x等价y，y等价z，则x等价z）。</p><h2 id="仅仅用一个整数实现存储年月日"><a href="#仅仅用一个整数实现存储年月日" class="headerlink" title="仅仅用一个整数实现存储年月日"></a>仅仅用一个整数实现存储年月日</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这种实现的正确性基于日的范围位于0~31，月的值位于0~15，年的值为正</span></span><br><span class="line"><span class="comment">   * 512 / 32 = 16</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">year,month,day</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = year * <span class="number">512</span> + month * <span class="number">32</span> + day</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">year</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> / <span class="number">512</span> | <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">month</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">value</span> / <span class="number">32</span> | <span class="number">0</span>) % <span class="number">16</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">day</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> % <span class="number">32</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">this</span>.<span class="property">year</span>,<span class="variable language_">this</span>.<span class="property">month</span>,<span class="variable language_">this</span>.<span class="property">day</span>].<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断回环变位"><a href="#判断回环变位" class="headerlink" title="判断回环变位"></a>判断回环变位</h2><p>如果字符串s中的字符循环移动位置之后可以得到另一个字符串t，那么s就被称为t的回环变位(sircular rotation)，例如：ACTGACG就是TGACGAC的回环变位，反之亦然。判断这个条件在基因组序列的研究中非常重要。下面的实现仅仅用了一行代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isCircularRotation = <span class="keyword">function</span>(<span class="params">str1,str2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="property">length</span> === str2.<span class="property">length</span> &amp;&amp; str1.<span class="title function_">repeat</span>(<span class="number">2</span>).<span class="title function_">indexOf</span>(str2) != -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<em>循环等价于2倍</em>的思想非常重要，一个典型的应用就是前端开发中的无缝滚动通常将需要循环播放的图片实体设置为2倍大小，外边使用1倍大小的容器包裹，多余的部分隐藏。</p><h2 id="递归的应用"><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h2><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自底向上反转字符串</span></span><br><span class="line"><span class="keyword">var</span> mystery = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> N = str.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> str</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mid = N &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> a = str.<span class="title function_">slice</span>(<span class="number">0</span>,mid)</span><br><span class="line">  <span class="keyword">var</span> b = str.<span class="title function_">slice</span>(mid,N)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mystery</span>(b) + <span class="title function_">mystery</span>(a) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是分治法的简单应用。将一个长的字符串分为2个部分，后边的字符加上前面的字符组成新的字符串。如果将最后的return条件改为<code>mystery(a) + mystery(b)</code>则返回的是字符串本身。</p><h3 id="Mac电脑中的数学"><a href="#Mac电脑中的数学" class="headerlink" title="Mac电脑中的数学"></a>Mac电脑中的数学</h3><p>Mac的桌面窗口一开始就被乔布斯要求设计成圆角，而计算机画圆形图案涉及到平方根计算，当时的 CPU（摩托罗拉68000微处理器）并不支持平方根计算。为此，阿特金森研究出一个加法运算来代替平方根运算的算法：一组奇数序列相加可以得到一组完全平方数序列（如，1+3&#x3D;4，1+3+5&#x3D;9，等等）。等差数列求和。1 + 3 + 5 + … + 2*n - 1 &#x3D; n^2。</p><h3 id="微波炉与ISM频段"><a href="#微波炉与ISM频段" class="headerlink" title="微波炉与ISM频段"></a>微波炉与ISM频段</h3><p>1945年，美国雷神公司一位工程师在研究微波雷达的时候，无意中发现 2.4GHz 频段的电磁波会使得口袋中的巧克力融化，从而发现了微波的热效应，发明了微波炉。</p><p>大量实验测量表明，2.450GHz 频率电磁波能很好的使得水分子等极性分子跟随电磁波发生振荡，从而在宏观上表现为食物被加热。</p><p>之后 2.4GHz 逐渐成为了各国通用的「ISM频段」之一，大量的工业、科研、医学、家用无线设备的工作频率都在这一频段，包括我们常见的蓝牙设备（2.402GHz - 2.480GHz）。</p><p>由此可见：</p><ol><li>在雨天等潮湿环境下，Wi-Fi 信号会因为被水分子吸收而变差；</li><li>很多无线设备在 2.4GHz 频段下工作，导致 Wi-Fi 信号很容易被干扰。</li></ol><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>斐波那契数列和我们的物理世界有着千丝万缕的联系。</p><ul><li>爬楼梯</li></ul><h1 id="抗锯齿原理"><a href="#抗锯齿原理" class="headerlink" title="抗锯齿原理"></a>抗锯齿原理</h1><p>anti-aliasing</p><p>图像显示的锯齿是每一个像素非黑即白渲染，显示器中的一个个像素可以看成是一个个的小正方形，小正方形的边缘是无法表现出平滑的效果的，响应的就会产生锯齿感。抗锯齿就是在边缘的位置使用不同深度的颜色或者利用透明度这样的概念，使得边缘的渲染效果不是“非黑即白”的，而是存在灰度的，人眼在视觉上看上去在边缘的地方相对平滑。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/anti-aliasing.png" alt="抗锯齿原理.png"></p><h1 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h1><p>画布上物体的运动需要这样表现：计算出物体新出现的位置-&gt;清空画布-&gt;重新渲染画布。这个过程中画布会被清空，从而造成屏幕闪烁。双缓存是对应显示屏幕的画布有2块，第一块画布的物体显示在屏幕上的时候，我们的计算以及绘制发生在第二块画布上，第二块画布绘制好之后将第二块画布投影到屏幕上，从而可以放心大胆地清空第一块画布，采用这种方式我们不会在屏幕上看到画布清空的瞬间。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/double-buffer.png" alt="双缓冲.png"></p><h1 id="蒙特卡洛算法"><a href="#蒙特卡洛算法" class="headerlink" title="蒙特卡洛算法"></a>蒙特卡洛算法</h1><p>统计学中的一种方法，是一种模拟。是二战期间为了解决原子弹研制过程中裂变物质中子随机扩散问题，美国数学家冯诺依曼和乌拉姆等提出的一种统计方法，代号：蒙特卡洛。之所以取这个代号，是因为蒙特卡洛位于摩纳哥，是当时非常著名的一个赌城，而随机模拟的方法和赌博的关系非常大。</p><blockquote><p>种一棵树最好的时间是十年前，其次是现在。<br>东隅已逝，桑榆非晚。 ——王勃《滕王阁序》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS7中的js binding技术</title>
      <link href="/2016/06/16/js-binging/"/>
      <url>/2016/06/16/js-binging/</url>
      
        <content type="html"><![CDATA[<p>cocos2Dx中提出了<a href="https://github.com/zynga/jsbindings">js binding</a>，而IOS 7原生提供了js binding的支持（通过JavaScript Core这个引擎）。所谓的binding就是建立了本地到native的桥梁。如图所示：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/js_binding.png" alt="js binding架构图"></p><h1 id="jsbinding与hibrid-app的区别"><a href="#jsbinding与hibrid-app的区别" class="headerlink" title="jsbinding与hibrid app的区别"></a>jsbinding与hibrid app的区别</h1><p>如下图所示：jsbinding通过一个中间层（JSBinding Layer）与native进行通信，而hibrid本质上还是web，运行在webview中。通过webview与native进行通信。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/jsbinding_vs_hibrid.png" alt="jsbinding与hibrid app的区别"></p><h2 id="JavaScriptCore的4个核心API"><a href="#JavaScriptCore的4个核心API" class="headerlink" title="JavaScriptCore的4个核心API"></a>JavaScriptCore的4个核心API</h2><ul><li>JavaScriptCore.h</li><li>JSContext</li><li>JSValue</li><li>JSExport</li></ul><h2 id="一行js代码实现逆天效果"><a href="#一行js代码实现逆天效果" class="headerlink" title="一行js代码实现逆天效果"></a>一行js代码实现逆天效果</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[].<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;*&quot;</span>),<span class="keyword">function</span>(<span class="params">a</span>)&#123;a.<span class="property">style</span>.<span class="property">outline</span>=<span class="string">&quot;1px solid #&quot;</span>+(~~(<span class="title class_">Math</span>.<span class="title function_">random</span>()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).<span class="title function_">toString</span>(<span class="number">16</span>)&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码可以实现显示页面上的所有元素。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac 中的一些常用操作</title>
      <link href="/2016/06/14/mac-operation/"/>
      <url>/2016/06/14/mac-operation/</url>
      
        <content type="html"><![CDATA[<h1 id="编辑器方向键"><a href="#编辑器方向键" class="headerlink" title="编辑器方向键"></a>编辑器方向键</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">文本最开始:fn + ←</span><br><span class="line">文本最结尾:fn + →</span><br><span class="line">行首:cmd + ←</span><br><span class="line">行尾:cmd + →</span><br><span class="line"></span><br><span class="line">PageUp:fn + ↑️️</span><br><span class="line">PageDown:fn + ↓️</span><br><span class="line"></span><br><span class="line">向前删除(backspace)：delete</span><br><span class="line">向后删除(delete)：fn + delete</span><br><span class="line"></span><br><span class="line">后退:ctrl + -</span><br><span class="line">前进:ctrl + <span class="built_in">shift</span> + -</span><br><span class="line">移动当前行：option + 上/下</span><br></pre></td></tr></table></figure><p>chrome dev tools 中也可以使用 cmd + p 打开文件（和 vscode 一样）</p><h1 id="输入表情符号"><a href="#输入表情符号" class="headerlink" title="输入表情符号"></a>输入表情符号</h1><p>control + command + space</p><h1 id="触摸板操作"><a href="#触摸板操作" class="headerlink" title="触摸板操作"></a>触摸板操作</h1><h2 id="右键菜单"><a href="#右键菜单" class="headerlink" title="右键菜单"></a>右键菜单</h2><p>两个手指单击触摸板</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="选择不连续的多个文件"><a href="#选择不连续的多个文件" class="headerlink" title="选择不连续的多个文件"></a>选择不连续的多个文件</h2><p>command + 单击</p><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>command + c(复制)<br>command + option + v(粘贴)</p><h2 id="显示隐藏文件"><a href="#显示隐藏文件" class="headerlink" title="显示隐藏文件"></a>显示隐藏文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults write com.apple.finder AppleShowAllFiles -bool <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>接下来重启 Finder。具体方法是单击屏幕左上角苹果图标，强制退出，在下拉列表中选中 Finder。</p><h1 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h1><p>command + control + F 最大化&#x2F;还原窗口<br>fn + F 在 Chrome 下是可以的，但是在 vscode 下就不行，所以还是前者通用。</p><h1 id="QQ-截图"><a href="#QQ-截图" class="headerlink" title="QQ 截图"></a>QQ 截图</h1><p>control + command + A</p><h1 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h1><p>command + option + I</p><h1 id="切换输入法"><a href="#切换输入法" class="headerlink" title="切换输入法"></a>切换输入法</h1><p>control + space，最近发现直接单按 fn 键也可以。</p><h1 id="开发工具相关"><a href="#开发工具相关" class="headerlink" title="开发工具相关"></a>开发工具相关</h1><p>现在用 docker-compose 部署需要的软件就行了，简单方便还不容易出错。</p><h2 id="iterm-终端"><a href="#iterm-终端" class="headerlink" title="iterm 终端"></a>iterm 终端</h2><p>command + T：新建选项卡<br>command + ←&#x2F;→：切换选项卡</p><p>在 iterm 中，使用 <code>cmd + /</code> 可以快速定位当前光标。</p><h2 id="webstorm"><a href="#webstorm" class="headerlink" title="webstorm"></a>webstorm</h2><p>整理代码：command + option + L<br>删除一行：command + delete<br>跳转行：command + L<br>快速修正错误：option + Enter</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>跳转到指定行号，在命令模式下输入行号即可，例如：<code>:25</code>表示跳转到25行。</li><li>行首<code>^</code>，行尾<code>$</code></li></ul><p>~&#x2F;.vimrc 配置：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span></span><br></pre></td></tr></table></figure><h2 id="搭建终极bash：zsh-iterm2-tmux"><a href="#搭建终极bash：zsh-iterm2-tmux" class="headerlink" title="搭建终极bash：zsh,iterm2,tmux"></a>搭建终极bash：zsh,iterm2,tmux</h2><p>参见<a href="http://www.tuicool.com/articles/FFN7Vbq">推酷</a></p><p>oh-my-zsh 需要搭配 zsh-autosuggestions 插件。</p><h2 id="open-命令"><a href="#open-命令" class="headerlink" title="open 命令"></a>open 命令</h2><p>用于打开文件、目录或执行程序。就等同于在命令行模式下，重复图形界面“双击”的动作。常用的选项是<code>-a</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用vscode编辑器打开test.js</span></span><br><span class="line">open -a code ./test.js</span><br></pre></td></tr></table></figure><h2 id="百度云资源下载"><a href="#百度云资源下载" class="headerlink" title="百度云资源下载"></a>百度云资源下载</h2><p>mac下的百度云同步盘完全是鸡肋，推荐<a href="https://github.com/yangshun1029/aria2gui">aria2</a>进行资源下载，注意：BaiduExporter拓展在chrome应用商店中被删除，需要开启开发者模式载入，详见：<a href="http://open.chrome.360.cn/extension_dev/getstarted.html">360开发文档</a></p><h2 id="远程服务器文件上传和下载"><a href="#远程服务器文件上传和下载" class="headerlink" title="远程服务器文件上传和下载"></a>远程服务器文件上传和下载</h2><p>推荐使用<a href="https://github.com/mmastrac/iterm2-zmodem">lrzsz</a>,注意：需要在服务器上也安装这个程序。</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h2><p>推荐<a href="https://iina.io/">IINA</a>，播放列表可以使用拖动来进行自定义排序，还能设置全局的播放速度。</p><h2 id="如何下载Google-play上的apk文件"><a href="#如何下载Google-play上的apk文件" class="headerlink" title="如何下载Google play上的apk文件"></a>如何下载Google play上的apk文件</h2><p>推荐使用<a href="http://apk-dl.com/">apk-dl</a></p><blockquote><p>一般的网线有 8 根，但是实际上 4 根线就够用了。</p></blockquote><h2 id="一些常见问题的解决方案"><a href="#一些常见问题的解决方案" class="headerlink" title="一些常见问题的解决方案"></a>一些常见问题的解决方案</h2><ul><li><a href="https://blog.igorw.org/2012/08/01/hdd-clicking-noises-of-mbp/">硬盘异常响</a></li></ul><h1 id="MAC-系统上的一些限制"><a href="#MAC-系统上的一些限制" class="headerlink" title="MAC 系统上的一些限制"></a>MAC 系统上的一些限制</h1><ol><li>一般的移动硬盘文件系统是 NTFS, MAC 只能读取不能写入，非常离谱，第三方软件需要付费</li></ol><p>4K 显示器自带的 type-c 数据线还能反向给 mac 充电，这样子充电器就能放家里，不必要每次都带到公司，再带回去了，公司的桌面上的线少一些还是看着清爽一些。</p>]]></content>
      
      
      <categories>
          
          <category> 常用软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 基础 —— 流程控制</title>
      <link href="/2016/04/29/linux-shell-flow-control/"/>
      <url>/2016/04/29/linux-shell-flow-control/</url>
      
        <content type="html"><![CDATA[<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>假设<code>/tmp/test.js</code>存在,而<code>/tmp/test.jsx</code>文件不存在,则执行以下命令(注意中括号两端的空格):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ [ -e /tmp/test.<span class="property">js</span> ]</span><br><span class="line">$ echo $? # <span class="number">0</span>,表示上一条命令执行成功,即文件存在</span><br><span class="line">$ [ -e /tmp/test.<span class="property">jsx</span> ]</span><br><span class="line">$ echo $? # <span class="number">1</span>,非零值,上一条命令执行失败</span><br><span class="line"># 我们可以执行下面的命令从而得到更加语义化的结果</span><br><span class="line">$ [ -e /tmp/test.<span class="property">js</span> ] &amp;&amp; echo <span class="string">&#x27;exists &#x27;</span> || echo <span class="string">&#x27;not exists&#x27;</span></span><br><span class="line"></span><br><span class="line"># 判断文件权限</span><br><span class="line">$ [ -w /tmp/test.<span class="property">js</span> ] &amp;&amp; echo <span class="string">&#x27;can write&#x27;</span> || echo <span class="string">&#x27;can not write&#x27;</span></span><br><span class="line"></span><br><span class="line">文件<span class="number">1</span> -ef 文件<span class="number">2</span> # 判断两个文件的<span class="title class_">Inode</span>是否一致,可理解为判断<span class="number">2</span>个文件是否是同一个文件,用于判断硬链接是很好的方法</span><br><span class="line"></span><br><span class="line">$ touch t</span><br><span class="line">$ ln t t2</span><br><span class="line">$ [ <span class="regexp">/tmp/</span>t -ef /tmp/t2 ] &amp;&amp; echo yes || echo no # yes</span><br><span class="line"></span><br><span class="line"># 整数比较</span><br><span class="line">$ [ <span class="number">12</span> -ge <span class="number">10</span> ] &amp;&amp; echo more || echo less # more</span><br><span class="line"></span><br><span class="line"># 字符串判断</span><br><span class="line">$ name=canglaoshi</span><br><span class="line">$ [ -z <span class="string">&quot;$name&quot;</span> ] &amp;&amp; echo <span class="string">&quot;empty&quot;</span> || echo <span class="string">&quot;not empty&quot;</span> # not empty</span><br><span class="line">$ a=<span class="number">1</span></span><br><span class="line">$ b=<span class="number">2</span></span><br><span class="line">$ [ <span class="string">&quot;$a&quot;</span> == <span class="string">&quot;$b&quot;</span> ] &amp;&amp; echo equal || echo not # 字符串相等的判断,not</span><br><span class="line"></span><br><span class="line"># 多重条件判断</span><br><span class="line">逻辑与:判断<span class="number">1</span> -a 判断<span class="number">2</span></span><br><span class="line">$ a=<span class="number">20</span></span><br><span class="line">$ [ -n <span class="string">&quot;$a&quot;</span> -a <span class="string">&quot;$a&quot;</span> -gt <span class="number">10</span> ] &amp;&amp; echo <span class="string">&quot;a存在且a不小于10&quot;</span> || echo no # a存在且a不小于<span class="number">10</span></span><br></pre></td></tr></table></figure><p>*注意:*脚本中的变量加双引号.</p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>参见<a href="https://coding.net/u/consoles/p/learn-shell/git/tree/master/if">coding.net</a></p><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>参见<a href="https://coding.net/u/consoles/p/learn-shell/git/blob/master/case/case.sh">coding.net</a></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>参见<a href="https://coding.net/u/consoles/p/learn-shell/git/tree/master/for">coding.net</a></p><h2 id="while和until"><a href="#while和until" class="headerlink" title="while和until"></a>while和until</h2><p>参见<a href="https://coding.net/u/consoles/p/learn-shell/git/tree/master/while">coding.net</a></p><h2 id="Redis报错MISCONF-Redis-is-configured-to-save-RDB-snapshots"><a href="#Redis报错MISCONF-Redis-is-configured-to-save-RDB-snapshots" class="headerlink" title="Redis报错MISCONF Redis is configured to save RDB snapshots"></a>Redis报错MISCONF Redis is configured to save RDB snapshots</h2><p>参见<a href="http://stackoverflow.com/questions/19873048/redis-is-configured-to-save-rdb-snapshots-but-is-currently-not-able-to-persist">stackoverflow</a>,编辑redis配置文件中的logfile目录为一个可写的目录。其实最简单的方法是用root权限启动redis。</p><h2 id="Linux网络监控"><a href="#Linux网络监控" class="headerlink" title="Linux网络监控"></a>Linux网络监控</h2><p>我们常用<code>netstat</code>命令查看网络状况（<code>netstat -tunlp | grep 22</code>，查看端口占用的进程），但是使用<a href="http://www.ttlsa.com/linux-command/ss-replace-netstat/"><code>ss</code>命令</a>更快。<a href="http://www.oschina.net/question/12_50469?fromerr=92L5le02"><code>nc</code>命令</a>可以模拟客户端和服务器。</p><blockquote><p>使用<code>time</code>命令可以为命令计时。例如<code>time sleep 5</code>将计算出<code>sleep 5</code>这条命令的执行时间为5.002s。</p></blockquote><h2 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0 192.168.1.155 netmask 255.255.255.0</span><br><span class="line">$ route add default gw 192.168.1.1</span><br></pre></td></tr></table></figure><p>mac查找特定端口的应用程序<code>lsof -i | grep 8080</code></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 语言精粹</title>
      <link href="/2016/04/25/secret-in-js/"/>
      <url>/2016/04/25/secret-in-js/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>javascript中并<em>没有真正的数组</em>,数组本质上也是<strong>对象</strong></p><p>请看下面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>) <span class="comment">// 6</span></span><br><span class="line">arr.<span class="property">abc</span> = <span class="literal">false</span>         <span class="comment">// 给数组增加属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)        <span class="comment">// [1, 2, 3, 4, 5, 6, abc: false]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>由运行的结果可以看出给数组添加了一个abc属性,尽管字面上的长度有所增加,但是数组的实际长度并没有改变!</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>所以为了区分数组和对象我们应该可以采用以下的函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">isArray</span> = value =&gt; !!value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; value.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>观察以下匹配url的正则表达式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parse_url = <span class="regexp">/^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;http://www.ora.com:80/goods?q=1#fragment&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = parse_url.<span class="title function_">exec</span>(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = [<span class="string">&#x27;url&#x27;</span>,<span class="string">&#x27;schema&#x27;</span>,<span class="string">&#x27;slash&#x27;</span>,<span class="string">&#x27;host&#x27;</span>,<span class="string">&#x27;port&#x27;</span>,<span class="string">&#x27;path&#x27;</span>,<span class="string">&#x27;query&#x27;</span>,<span class="string">&#x27;hash&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; names.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(names[i] + <span class="string">&#x27;:&#x27;</span>,result[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(?:([A-Za-z]+):)?</code>这个因子匹配一个协议名,但仅当它之后跟随一个冒号(:)的时候才匹配<code>(?:...)</code>表示一个非捕获型分组(noncapturing group),通常用非捕获分组来代替少量不优美的捕获型分组是很好的方法,因为捕获会有性能上的缺失.后缀<code>?</code>表示这个分组是可选的.<code>(...)</code>表示一个捕获型分组(capturing group).一个捕获型分组将复制它所匹配的文本,并将其放入到result数组中.<em>每个捕获型分组都将被指定一个编号,第一个捕获分组的编号是1</em>,所以该分组所匹配的文本拷贝将出现在<code>result[1]</code>中;下一个因子<code>(\/&#123;0,3&#125;)</code>是捕获分组2.</p><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><p>匹配数字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern_number = <span class="regexp">/^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式转义"><a href="#正则表达式转义" class="headerlink" title="正则表达式转义"></a>正则表达式转义</h2><p><code>\1</code>指向分组1所捕获到的文本的一个引用,所以它能够再次匹配,例如我们用下面的正则表达式来搜索文本中重复的单词:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doubled_words = <span class="regexp">/[A-Za-z\u00c0-\u1fff\u2800-\ufffd\-]+\s+\1/gi</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式分组"><a href="#正则表达式分组" class="headerlink" title="正则表达式分组"></a>正则表达式分组</h2><h3 id="捕获型"><a href="#捕获型" class="headerlink" title="捕获型"></a>捕获型</h3><p>一个被包围在圆括号中的正则表达式选择.任何匹配这个分组的字符将被捕获.每个捕获分组都被指定了一个数字,第一个捕获(的是分组1,第二个捕获(的是分组2</p><h3 id="非捕获型"><a href="#非捕获型" class="headerlink" title="非捕获型"></a>非捕获型</h3><p>有一个<code>(?:</code>前缀,仅做简单匹配,并不会捕获所匹配文本,会有微弱的性能优势,不会干扰捕获型分组的编号.</p><h1 id="关于语言本身的一些探讨"><a href="#关于语言本身的一些探讨" class="headerlink" title="关于语言本身的一些探讨"></a>关于语言本身的一些探讨</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>由于javascript中所有数字都是浮点型,所以使用<em>位运算会降低程序性能</em>,因为需要将数字转化为整型后执行运算然后转化回去.</p><p>巧妙使用位运算可以创造很多的<em>奇淫技巧</em>。例如以下的转化为整数的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">parseInt</span> = num =&gt; num | <span class="number">0</span></span><br><span class="line"><span class="comment">// 还可以这样</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">parseInt</span> = num =&gt; num &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"><span class="comment">// 甚至，我们可以这样</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">parseInt</span> = num =&gt; ~~num</span><br></pre></td></tr></table></figure><p>以上的<code>parseInt</code>实现可以传入任意的数据类型，如果数据类型不匹配将会被转化为0,避免了原生的<code>parseInt</code>中的<code>NaN</code>的问题，但是局限在于<strong>只能处理32位的整数</strong>。</p><h2 id="生成随机字母数字字符串"><a href="#生成随机字母数字字符串" class="headerlink" title="生成随机字母数字字符串"></a>生成随机字母数字字符串</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">generateRandomAlphaNum</span>(<span class="params">len</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> rdmString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; rdmString.<span class="property">length</span> &lt; len; rdmString  += <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substr</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span>  rdmString.<span class="title function_">substr</span>(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>toString(36)</code>表示10个阿拉伯数字和26个小写英文字母</p></blockquote><h2 id="随机背景色"><a href="#随机背景色" class="headerlink" title="随机背景色"></a>随机背景色</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;#&#x27;</span>+(<span class="number">0x1000000</span>+(<span class="title class_">Math</span>.<span class="title function_">random</span>())*<span class="number">0xffffff</span>).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="实现-sleep"><a href="#实现-sleep" class="headerlink" title="实现 sleep"></a>实现 sleep</h2><p>generator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">cb</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(cb, ms);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span> *() &#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">sleep</span>(<span class="number">2000</span>);</span><br><span class="line">  <span class="title function_">expect</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - now).<span class="property">to</span>.<span class="property">not</span>.<span class="property">be</span>.<span class="title function_">below</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>参见<a href="https://www.zhihu.com/question/31636244">知乎</a></p><h2 id="underscore-js中的-after方法"><a href="#underscore-js中的-after方法" class="headerlink" title="underscore.js中的_.after方法"></a>underscore.js中的_.after方法</h2><p>该方法可以根据传入的times参数的不同生成需要调用多次才执行的实际函数的函数，这是<a href="http://gyf1.com/blog/2015/06/25/partial-application-in-javascript/">偏函数</a>的典型应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;underscore&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> fiveCountCallback = _.<span class="title function_">after</span>(count,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after 5 count and execute this function&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> timer = <span class="number">0</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(timer++)</span><br><span class="line"><span class="title function_">fiveCountCallback</span>() <span class="comment">// 每1s执行一次该函数，但是真正执行该函数却是在5s后</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this will print first&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其内部实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="property">after</span> = <span class="keyword">function</span>(<span class="params">times, func</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (--times &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 基础 —— 正则表达式</title>
      <link href="/2016/04/16/linux-regexp/"/>
      <url>/2016/04/16/linux-regexp/</url>
      
        <content type="html"><![CDATA[<h1 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -n <span class="string">&quot;^$&quot;</span> test.txt <span class="comment"># 空白行</span></span><br><span class="line">[0-9]\&#123;4\&#125;-[0-9]\&#123;2\&#125;-[0-9]\&#123;2\&#125; <span class="comment"># yyyy-mm-dd</span></span><br><span class="line">[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125; <span class="comment"># ip</span></span><br></pre></td></tr></table></figure><blockquote><p>在vi中按Esc键后d G可以清空光标起的所有内容。</p></blockquote><h1 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h1><h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h2><p>例如我们有用户信息文件<code>/etc/passwd</code>,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd user1</span><br><span class="line">$ useradd user2</span><br></pre></td></tr></table></figure><p>假设我们要删除上面创建的用户user1和user2,当然我们可以使用<code>userdel</code>命令,但是有的时候是程序执行的,所以我们需要在<code>/etc/passwd</code>中提取出新创建的2个普通用户,使用<code>grep</code>进行行提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&quot;user&quot;</span> /etc/passwd | grep -v <span class="string">&quot;system&quot;</span> <span class="comment"># -v表示取反</span></span><br><span class="line">user1:x:1001:1001::/home/user1:</span><br><span class="line">user2:x:1002:1002::/home/user2:</span><br></pre></td></tr></table></figure><p>接下来我们看下<code>cut</code>命令进行列提取,假设有以下的csv文件(注意:分隔符号是制表符):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>      name    gender  mark</span><br><span class="line">1       furong  f       85</span><br><span class="line">2       fengj   f       60</span><br><span class="line">3       cang    f       70</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cut</span> -f 2 students.csv <span class="comment"># 截取第二列(name)</span></span><br><span class="line">$ <span class="built_in">cut</span> -f 2,4 students.csv <span class="comment"># 截取name和mark</span></span><br></pre></td></tr></table></figure><p>再回到上一个从<code>/etc/passwd</code>中截取用户名的程序中,我们只需要这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&quot;user&quot;</span> /etc/passwd | grep -v <span class="string">&quot;system&quot;</span> | <span class="built_in">cut</span> -f 1 -d <span class="string">&quot;:&quot;</span> <span class="comment"># -d指明分隔符</span></span><br></pre></td></tr></table></figure><p>提取用户名和uid</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cut</span> -d <span class="string">&quot;:&quot;</span> -f 1,3 /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">&#x27;%s\t%s\t%s\t%s\n&#x27;</span>  $(<span class="built_in">cat</span> student.csv) <span class="comment"># 使用printf输出student.csv中的内容</span></span><br></pre></td></tr></table></figure><h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><p><code>awk &#39;条件1&#123;动作1&#125;条件2&#123;动作2&#125;...&#39; 文件名</code></p><ul><li>条件(Pattern):一般使用关系表达式,例如:x&gt;10,x&gt;&#x3D;10</li><li>动作(Action):格式化输出或者流程控制语句</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&#x27;</span> student.csv <span class="comment"># 输出第2和4列</span></span><br><span class="line">namemark</span><br><span class="line">furong85</span><br><span class="line">fengj60</span><br><span class="line">cang70</span><br><span class="line">$ <span class="built_in">df</span> -h | awk <span class="string">&#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span> <span class="comment"># 输出df -h命令的第一列和第三列</span></span><br><span class="line">文件系统已用</span><br><span class="line">/dev/sda820G</span><br><span class="line">none0</span><br><span class="line">udev4.0K</span><br><span class="line">tmpfs1.2M</span><br><span class="line">none0</span><br><span class="line">none40M</span><br><span class="line">none56K</span><br><span class="line">$ <span class="built_in">df</span> -h | grep <span class="string">&quot;/dev/sda8&quot;</span> | awk <span class="string">&#x27;&#123;print $1 &quot;\t&quot; $5&#125;&#x27;</span></span><br><span class="line">/dev/sda821%</span><br><span class="line">$ <span class="built_in">df</span> -h | grep <span class="string">&quot;/dev/sda8&quot;</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -f 1 -d <span class="string">&quot;%&quot;</span></span><br><span class="line">21</span><br><span class="line"></span><br><span class="line"><span class="comment"># BEGIN和END用于在整个文件的前面或者后面输出某个内容</span></span><br><span class="line">$ awk <span class="string">&#x27;BEGIN&#123;print &quot;---the begin---&quot;&#125;END&#123;print &quot;---the end---&quot;&#125;&#123;printf $2 &quot;\t&quot; $4 &quot;\n&quot;&#125;&#x27;</span> student.csv</span><br><span class="line">---the begin---</span><br><span class="line">namemark</span><br><span class="line">furong85</span><br><span class="line">fengj60</span><br><span class="line">cang70</span><br><span class="line">---the end---</span><br><span class="line"><span class="comment"># 使用awk命令输出用户名和uid</span></span><br><span class="line">$ <span class="built_in">cat</span> /etc/passwd | awk <span class="string">&#x27;&#123;FS=&quot;:&quot;&#125;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 输出student.csv中成绩大于70的学生姓名(中间的grep -v表示去掉表头表示的行)</span></span><br><span class="line">$ <span class="built_in">cat</span> student.csv | grep -v <span class="built_in">id</span> | awk <span class="string">&#x27;$4 &gt;= 70 &#123;printf $2 &quot;\n&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>awk中<code>$0</code>表示的是文件名,awk的执行是按照<em>行</em>进行提取,把每一个数据变换成<code>$1,$2,$3</code>等字段,然后判断Pattern,条件满足则执行Action接下来是第二行,以此类推.</p><h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><p>文本替换和过滤的流式编辑器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed中-n选项的作用,不加-n则不仅打印匹配的行而且打印整篇文档</span></span><br><span class="line">consoles@linux:~$ sed <span class="string">&#x27;2p&#x27;</span> student.csv</span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">1furongf85</span><br><span class="line">1furongf85</span><br><span class="line">2fengjf60</span><br><span class="line">3cangf70</span><br><span class="line">consoles@linux:~$ sed -n <span class="string">&#x27;2p&#x27;</span> student.csv</span><br><span class="line">1furongf85</span><br><span class="line">$ sed  <span class="string">&#x27;2d&#x27;</span> student.csv <span class="comment"># 从原始数据中过滤掉第2行</span></span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">2fengjf60</span><br><span class="line">3cangf70</span><br><span class="line">$ sed  <span class="string">&#x27;2,4d&#x27;</span> student.csv <span class="comment"># 从原始数据中过滤掉第2到4行</span></span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">$ sed  <span class="string">&#x27;2a 漂亮就是任性&#x27;</span> student.csv <span class="comment"># 在第二行后面追加(如果选项是i则表示在前面插入)</span></span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">1furongf85</span><br><span class="line">漂亮就是任性</span><br><span class="line">2fengjf60</span><br><span class="line">3cangf70</span><br><span class="line">$ sed <span class="string">&#x27;4c 苍老师成绩不及格&#x27;</span> student.csv  <span class="comment"># 替换第四行</span></span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">1furongf85</span><br><span class="line">2fengjf60</span><br><span class="line">3cangf70</span><br><span class="line">$ sed <span class="string">&#x27;4s/70/100/g&#x27;</span> student.csv <span class="comment"># 将苍老师的成绩改为满分,我们可以使用`sed -i`将操作保存到硬盘</span></span><br><span class="line"><span class="built_in">id</span>namegendermark</span><br><span class="line">1furongf85</span><br><span class="line">2fengjf60</span><br><span class="line">3cangf100</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/guxch/article/details/7041052">Unix Domain Socket</a>用于IPC（同一台主机间的进程通信），不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。UNIX Domain Socket有SOCK_DGRAM或SOCK_STREAM两种工作模式，类似于UDP和TCP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p><p>UNIX Domain Socket可用于两个没有亲缘关系的进程，是全双工的，是目前使用最广泛的IPC机制，比如X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的。使用node可以创建<a href="https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_net_createserver_options_connectionlistener">Unix Domain Server</a></p><h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /usr -name <span class="string">&quot;redis.conf&quot;</span></span><br></pre></td></tr></table></figure><h3 id="buffer和cache"><a href="#buffer和cache" class="headerlink" title="buffer和cache"></a>buffer和cache</h3><p>这两个术语经常被混用，原因在于他们都在内存中可以提高IO性能。但是严格来说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式web设计</title>
      <link href="/2016/04/07/response-web-design/"/>
      <url>/2016/04/07/response-web-design/</url>
      
        <content type="html"><![CDATA[<h1 id="固定宽度布局的缺点"><a href="#固定宽度布局的缺点" class="headerlink" title="固定宽度布局的缺点"></a>固定宽度布局的缺点</h1><p>我们经常可以看到固定宽度的布局.例如960px的页面在笔记本上可能显示刚刚好,但是在高分辨率的显示器上两侧就会出现留白,可是我们现在有了智能手机.手机浏览器会将一个标准页面缩放到与视口(即:设备可视区域)恰好匹配.然后用户可以选择在自己感兴趣的内容上放大浏览,这样就导致了用户体验非常糟糕!(想象一下不停的点击放大滑动然后缩小,更可恶的是如果误点击了一个链接).响应式web设计的核心是<strong>移动优先</strong>.</p><blockquote><p>在使用CSS3属性的时候需要注意浏览器前缀,并且将不带有前缀的添加到最后,这样如果该属性可用就会覆盖之前的声明.</p></blockquote><h1 id="百分比宽度的计算"><a href="#百分比宽度的计算" class="headerlink" title="百分比宽度的计算"></a>百分比宽度的计算</h1><p>百分比宽度 &#x3D; 目标元素宽度 &#x2F; 上下文元素宽度,例如我们有以下的固定宽度的布局:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is aside<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#wrapper</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-left</span>: auto;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-right</span>: auto;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">960px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">nav</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">940px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">26px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">aside</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">border-right</span>: <span class="number">#e8e8e8</span> solid <span class="number">2px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">58px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">220px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">article</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">58px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">698px</span>;    </span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">footer</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">940px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据经验,我们将最外层的#wrapper的宽度设置为96%,那么nav的宽度应该设置多少?我们用940&#x2F;960 &#x3D; 97.91666666666666%,所谓的上下文元素就是被参照的元素,我们也可以简单理解为<strong>具有特定宽度</strong>的父元素或者祖宗元素.</p><h1 id="使用em替代像素"><a href="#使用em替代像素" class="headerlink" title="使用em替代像素"></a>使用em替代像素</h1><p>几年前,使用em替代px主要是为了实现文字缩放.em的实际大小是相对于上下文字体而言的.如果给body的font-size设置为100%,其他文字单位都使用相对单位em,那些文字都将受到body上初始声明的影响.现代浏览器中默认文字大小是16px,因此在body中声明以下的3条css等效:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="弹性图片"><a href="#弹性图片" class="headerlink" title="弹性图片"></a>弹性图片</h1><p>在IE7+实现图片随流式布局自动缩放非常简单:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理,该css属性还可以拓展到<code>&lt;object&gt;</code>,<code>&lt;video&gt;</code>,<code>&lt;embed&gt;</code>等其他多媒体元素</p><h1 id="CSS3实用技巧"><a href="#CSS3实用技巧" class="headerlink" title="CSS3实用技巧"></a>CSS3实用技巧</h1><ul><li>类似报纸排版的多栏布局<code>column-count</code></li><li>文字换行<code>word-wrap:break-word</code>,需要给外层容器添加此属性,中间内容将自动换行(不会生成水平滚动条)</li></ul><p>水平导航的最佳实践:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>link 5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">nav</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">nav</span> <span class="selector-tag">ul</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table-row;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: left;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: right;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>首字下沉效果.得益于伪元素选择器.<code>::first-letter</code>,同理<code>::first-line</code>用于选择首行。</li></ul><p>盒子模型可以分为 <code>inline</code> 和 <code>block</code> 两种类型。<code>display</code> 为 <code>inline</code> 的元素<strong>不能设置宽度和高度，只能被内容撑开</strong>。所以 <code>inline-block</code> 模型的出现是即希望盒子的显示可以是一排显示而又可以设置宽高。</p><h1 id="元素的透明度"><a href="#元素的透明度" class="headerlink" title="元素的透明度"></a>元素的透明度</h1><p>说道透明度我们一般会想到<code>opacity</code>这个属性.但是给一个容器设置了透明度后,它的内容也就变得透明了,因此我们可以使用透明的背景色:<code>rgba</code>或者<code>hsla</code></p><h1 id="使用CSS3创作绚丽的效果"><a href="#使用CSS3创作绚丽的效果" class="headerlink" title="使用CSS3创作绚丽的效果"></a>使用CSS3创作绚丽的效果</h1><h2 id="模拟书籍页边距的光晕效果"><a href="#模拟书籍页边距的光晕效果" class="headerlink" title="模拟书籍页边距的光晕效果"></a>模拟书籍页边距的光晕效果</h2><p>使用多重内阴影:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>:inset <span class="number">0</span> <span class="number">0</span> <span class="number">30px</span> <span class="built_in">hsl</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">0%</span>),</span><br><span class="line">          inset <span class="number">0</span> <span class="number">0</span> <span class="number">70px</span> <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">97%</span>,<span class="number">53%</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="文字浮雕"><a href="#文字浮雕" class="headerlink" title="文字浮雕"></a>文字浮雕</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>:<span class="number">0px</span> <span class="number">1px</span> <span class="number">#fff</span>,</span><br><span class="line">            <span class="number">4px</span> <span class="number">4px</span> <span class="number">0px</span> <span class="number">#dad7d7</span>;</span><br></pre></td></tr></table></figure><h2 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h2><p>除了常见的<code>transition:all 1s ease 0s</code>外我们也可以为不同的属性指定不同的过渡(也就是说步调可以任意),例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">  <span class="attribute">transition-property</span>: border,color,text-shadow;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">2s</span>,<span class="number">3s</span>,<span class="number">8s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的效果是2s完成border,3s完成color,8s完成text-shadow.</p><h2 id="CSS3针对表单的伪类选择器"><a href="#CSS3针对表单的伪类选择器" class="headerlink" title="CSS3针对表单的伪类选择器"></a>CSS3针对表单的伪类选择器</h2><ul><li><code>input:required</code>,必填表单域</li><li><code>input:focus:invalid</code>,处于焦点并输入了非法值的表单域,同理,有<code>input:focus:valid</code></li></ul><p>使用上面的3个选择器可以制作响应式的表单:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:required</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">253</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:invalid</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;error.png&#x27;</span>) no-repeat right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:valid</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;ok.png&#x27;</span>) no-repeat right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="html5新特性"><a href="#html5新特性" class="headerlink" title="html5新特性"></a>html5新特性</h1><h2 id="自动联想词"><a href="#自动联想词" class="headerlink" title="自动联想词"></a>自动联想词</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">list</span>=<span class="string">&quot;usernames&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;usernames&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;aa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;bb&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上的代码当我们输入字符的时候会自动从下面的<code>datalist</code>标签中进行筛选.</p><h2 id="不支持html的浏览器的渐进增强"><a href="#不支持html的浏览器的渐进增强" class="headerlink" title="不支持html的浏览器的渐进增强"></a>不支持html的浏览器的渐进增强</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.7.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js-webshim/minified/extras/modernizr-custom.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js-webshim/minified/polyfiller.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//加载补丁</span></span></span><br><span class="line"><span class="language-javascript">$.webshims.<span class="title function_">polyfill</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一些常见的DOM方法"><a href="#一些常见的DOM方法" class="headerlink" title="一些常见的DOM方法"></a>一些常见的DOM方法</h2><ul><li>document.images: 页面上所有的图片元素</li><li>document.links : 所有a标签元素</li><li>document.forms : 所有表单</li><li>document.forms[0].elements : 页面上第一个表单中的所有域</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.andthewinnerisnt.com/">响应式web设计</a><br><a href="http://webdesignerwall.com/trends/47-amazing-css3-animation-demos">47个迷人的CSS3动画</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 基础 —— 运算符</title>
      <link href="/2016/04/04/linux-shell-operator/"/>
      <url>/2016/04/04/linux-shell-operator/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux查看在线用户使用<code>w</code>命令。</p></blockquote><h1 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h1><p>在上一篇文章<a href="http://consoles.github.io/2016/03/26/linux-shell-varible/">Shell基础-变量</a>中我们说道Linux中默认的变量类型是字符串.</p><p>我们使用该命令结合<code>+</code>或者<code>-</code>设定或者取消变量类型:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> [+|-] [options] 变量名</span><br></pre></td></tr></table></figure><p>其中<code>-</code>是设置类型,<code>+</code>是取消设置类型.</p><p>常见的数据类型:</p><ul><li>-a:数组型</li><li>-i:整型</li><li>-x:环境变量(其实export命令就是调用的<code>declare -x</code>命令)</li><li>-r:只读变量(不能改变,不能修改,不能删除,甚至不能取消只读属性)</li><li>-p:显式声明变量被声明的类型</li></ul><p>请看下面的例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ a=1</span><br><span class="line">$ b=2</span><br><span class="line">$ c=<span class="variable">$a</span>+<span class="variable">$b</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$c</span> <span class="comment"># &#x27;1+2&#x27;,because default is string</span></span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">declare</span> -i c=<span class="variable">$a</span>+<span class="variable">$b</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$c</span> <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数组</span></span><br><span class="line">$ sutdents[0] = <span class="string">&#x27;Kissy&#x27;</span></span><br><span class="line">$ sutdents[1] = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">$ <span class="built_in">declare</span> -a sutdents[2] = <span class="string">&#x27;Kenvin&#x27;</span></span><br><span class="line"><span class="comment"># 查看数组</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;students&#125;</span> <span class="comment"># 输出数组手元素</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;students[2]&#125;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;students[*]&#125;</span> <span class="comment"># 所有元素</span></span><br></pre></td></tr></table></figure><h1 id="数值运算方法"><a href="#数值运算方法" class="headerlink" title="数值运算方法"></a>数值运算方法</h1><p>在上面的例子中我们为了实现<code>a</code>和<code>b</code>相加为数值类型,使用<code>declare</code>命令声明了c,其实我们还有更优雅的方法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ a=1</span><br><span class="line">$ b=2</span><br><span class="line">$ c=$(<span class="built_in">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span>) <span class="comment"># 注意:+号的左右两侧必须有空格</span></span><br></pre></td></tr></table></figure><p>除此之外还有一种比较优雅的方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ a=1</span><br><span class="line">$ b=2</span><br><span class="line">$ c=$((<span class="variable">$a</span>+<span class="variable">$b</span>)) <span class="comment"># 推荐使用</span></span><br><span class="line">$ d=$[<span class="variable">$a</span>+<span class="variable">$b</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 最佳实践</title>
      <link href="/2016/03/29/nodejs-best-practice/"/>
      <url>/2016/03/29/nodejs-best-practice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>与善人居，如入芝兰之室，久而不闻其香，即与之化矣。与不善人居，如入鲍鱼之肆，久而不闻其臭，亦与之化矣。丹之所藏者赤，漆之所藏者黑，是以君子必慎其所处者焉。 —— 《孔子家语》</p></blockquote><h1 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全局安装的node模块的位置</span></span><br><span class="line">npm root -g</span><br><span class="line"><span class="comment"># 消除 mac 下全局安装模块报错 permission deny</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R $(<span class="built_in">whoami</span>) $(npm config get prefix)/&#123;lib/node_modules,bin,share&#125;</span><br></pre></td></tr></table></figure><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><blockquote><p>cluster模块,可以把任务分配给子进程,就是说Node把当前程序复制了一份给另一个进程每个子进程有些特殊的能力,比如能够与<strong>其他子进程共享socket连接</strong>(多个进程共享socket连接,那么端口不就冲突了么?)。这样我们就可以写一个Node程序,让它创建许多其他Node程序,并把任务分配给它们。需要重点理解的是,你用cluster把工作共享到一组复制的Node程序时,主进程不会参与到每个具体的事务中。主进程管理所有的子进程,但当子进程与I&#x2F;O操作交互时,它们是直接进行操作的,不需要通过主进程。这意味着,如果你用cluster来创建一个Web服务器,请求将不会通过你的主进程,而是直接连接到子进程。而且,调度这些请求并不会导致系统出现瓶颈。以下是一个示例:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> numCPUs = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>().<span class="property">length</span>;  <span class="comment">// 获取CPU内核数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是则根据CPU内核数创建worker进程</span></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">    <span class="comment">// Fork workers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">        cluster.<span class="title function_">fork</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(cluster.<span class="property">workers</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am worker running with ID : &#x27;</span> + cluster.<span class="property">workers</span>[id].<span class="property">process</span>.<span class="property">pid</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    cluster.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span>(<span class="params">worker, code, signal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;worker &#x27;</span> + worker.<span class="property">process</span>.<span class="property">pid</span> + <span class="string">&#x27; died&#x27;</span>);</span><br><span class="line">        <span class="comment">// restart a worker</span></span><br><span class="line">        cluster.<span class="title function_">fork</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count++); <span class="comment">// 每次打印都是0</span></span><br><span class="line">    <span class="comment">// 那么此worker进程就启动一个http服务</span></span><br><span class="line">    http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">        res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;).<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>cluster</code>提供了跨平台时让多个进程共享<code>socket</code>的方法。即使多个子进程在共享一个端口上的连接,其中一个堵塞了,也不会影响其他工作进程的新连接。(PS:这到底是如何做到的?)<br><code>process.strerr</code>是阻塞的可写流,编码永远是<strong>UTF8</strong>.生产环境中应该避免向其写入过多内容.</p></blockquote><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><h2 id="如何实现EventEmitter"><a href="#如何实现EventEmitter" class="headerlink" title="如何实现EventEmitter"></a>如何实现EventEmitter</h2><p>我们来分析下<code>EventEmitter</code>的简略实现代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span>(<span class="params">type</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> handler = <span class="variable language_">this</span>.<span class="property">_events</span>[type]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">isArray</span>(handler))&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> listeners = handler.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,l = listeners.<span class="property">length</span>;i &lt; l;i++)&#123;</span><br><span class="line">      listeners[i].<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在事件触发后,运行时处理程序中的一项检查是看看是否存在事件监听器的数组。如果有几个监听器,运行执行器会按数组顺序把里面的监听器一一调用。意思是说,第一个绑定的监听器会首先用<code>apply()</code>方法调用,然后是第二个,以此类推。这里需要重点注意的是,一个事件的所有监听器是在同一个代码路径上的。所以如果其中一个回调函数出现了异常未被捕获,将导致该事件的其他回调函数终止执行。</p></blockquote><h2 id="使用EventEmitter监听HTTP会话"><a href="#使用EventEmitter监听HTTP会话" class="headerlink" title="使用EventEmitter监听HTTP会话"></a>使用<code>EventEmitter</code>监听HTTP会话</h2><p>httpsniffer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sniffOn</span> = <span class="function"><span class="params">server</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">_reqToString</span> = req =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> ret = <span class="string">`[request:]<span class="subst">$&#123;req.method&#125;</span> <span class="subst">$&#123;req.httpVersion&#125;</span> <span class="subst">$&#123;req.url&#125;</span>\n<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(url.parse(req.url,<span class="literal">true</span>))&#125;</span>\n`</span></span><br><span class="line">        <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(req.<span class="property">headers</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; keys.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> key = keys[i]</span><br><span class="line">            ret += <span class="string">`<span class="subst">$&#123;i&#125;</span> <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;req.headers[key]&#125;</span>\n`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(req.<span class="property">trailers</span>)&#123;</span><br><span class="line">            ret += <span class="string">`<span class="subst">$&#123;req.trailers&#125;</span>\n`</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="string">&#x27;========= e_request =========&#x27;</span>)</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="title function_">_reqToString</span>(req))</span><br><span class="line">    &#125;)</span><br><span class="line">    server.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="params">errno</span> =&gt;</span> &#123;</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="string">&#x27;[e_close] errno = &#x27;</span>,errno)</span><br><span class="line">    &#125;)</span><br><span class="line">    server.<span class="title function_">on</span>(<span class="string">&#x27;checkContinue&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="string">&#x27;e_checkContinue&#x27;</span>)</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="title function_">_reqToString</span>(req))</span><br><span class="line">        res.<span class="title function_">writeContinue</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    server.<span class="title function_">on</span>(<span class="string">&#x27;upgrade&#x27;</span>,<span class="function">(<span class="params">req,socket,head</span>) =&gt;</span> &#123;</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="string">&#x27;e_upgrade&#x27;</span>)</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="title function_">_reqToString</span>(req))</span><br><span class="line">    &#125;)</span><br><span class="line">    server.<span class="title function_">on</span>(<span class="string">&#x27;clientError&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        util.<span class="title function_">log</span>(<span class="string">&#x27;e_clientError&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test_httpsniffer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> sniffer = <span class="built_in">require</span>(<span class="string">&#x27;./httpsniffer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>,&#123;<span class="string">&#x27;Content-Type&#x27;</span>:<span class="string">&#x27;text/plain&#x27;</span>&#125;)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello world\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sniffer.<span class="title function_">sniffOn</span>(server)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h2 id="EventEmitter中newListenser事件的妙用"><a href="#EventEmitter中newListenser事件的妙用" class="headerlink" title="EventEmitter中newListenser事件的妙用"></a>EventEmitter中newListenser事件的妙用</h2><p>newListener可以用来做事件机制的反射，特殊应用，事件管理等。当任何on事件添加到EventEmitter时，就会触发newListener事件，基于这种模式，我们可以做很多自定义处理.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEmitter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> <span class="title class_">MyEmitter</span>();</span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;newListener&#x27;</span>, <span class="keyword">function</span> (<span class="params">name, listener</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;添加事件:&quot;</span>, name);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;新事件的处理函数:&quot;</span>, listener);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是自定义延时处理机制&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;world&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">添加事件: hello</span><br><span class="line">新事件的处理函数: function hello() &#123;</span><br><span class="line">  console.log(&#x27;hello&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">添加事件: world</span><br><span class="line">新事件的处理函数: function world() &#123;</span><br><span class="line">  console.log(&#x27;world&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">我是自定义延时处理机制</span><br><span class="line">我是自定义延时处理机制</span><br></pre></td></tr></table></figure><h1 id="异步流程控制"><a href="#异步流程控制" class="headerlink" title="异步流程控制"></a>异步流程控制</h1><h2 id="模仿async库的waterfall"><a href="#模仿async库的waterfall" class="headerlink" title="模仿async库的waterfall"></a>模仿async库的waterfall</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * sync_exec.js</span><br><span class="line"> * 使函数队列顺序执行，参考async.js@waterfall</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;[Array]&#125; fnQ  [函数队列]</span><br><span class="line"> * @param  &#123;[type]&#125; args [每个函数的共同参数] [optional]</span><br><span class="line"> * @return &#123;[Undefined]&#125;      [Undefined]</span><br><span class="line"> */</span><br><span class="line">let syncExec = module.exports = function(fnQ,args)&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归函数，依次执行函数队列中的函数</span><br><span class="line"> * @param  &#123;[Array]&#125; fnQ   [函数队列]</span><br><span class="line"> * @param  &#123;[Number]&#125; count [函数执行计数器]</span><br><span class="line"> * @param  &#123;[Number]&#125; total [队列长度]</span><br><span class="line"> * @param  &#123;[Array]&#125; argv  [每个函数的共有参数]</span><br><span class="line"> * @param  &#123;[object]&#125; self  [函数绑定的this指向]</span><br><span class="line"> * @return &#123;[Undefined]&#125;       [undefined]</span><br><span class="line"> */</span><br><span class="line">let _exec = function(fnQ,count,total,argv,self)&#123;</span><br><span class="line">if(count === total) return</span><br><span class="line">fnQ[count].call(self,</span><br><span class="line">function()&#123;</span><br><span class="line">_exec(fnQ,++count,total,argv,self)</span><br><span class="line">&#125;,</span><br><span class="line">argv</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let self = this</span><br><span class="line">let fLen = fnQ.length</span><br><span class="line">let argv = [].slice.call(arguments,1) // 0是next函数，从1开始是函数真正的参数</span><br><span class="line">return _exec(fnQ,0,fLen,argv,self,void 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模仿async-parallel"><a href="#模仿async-parallel" class="headerlink" title="模仿async.parallel"></a>模仿async.parallel</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parallel</span>(<span class="params">arr, cb</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    <span class="keyword">var</span> error   = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> parr = arr[i].<span class="property">params</span>.<span class="title function_">concat</span>();</span><br><span class="line">        parr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; !error) &#123;</span><br><span class="line">                error = <span class="literal">true</span>;</span><br><span class="line">                <span class="title function_">cb</span>(err, results);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                results.<span class="title function_">push</span>(data);</span><br><span class="line">                <span class="keyword">if</span> (results.<span class="property">length</span> === len) &#123;</span><br><span class="line">                    <span class="title function_">cb</span>(<span class="literal">null</span>, results);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        arr[i].<span class="property">func</span>.<span class="title function_">apply</span>(arr[i].<span class="property">thisObj</span>, parr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">sec, cb</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">log</span>(<span class="string">&#x27;delay sec &#x27;</span> + sec);</span><br><span class="line">        <span class="keyword">var</span> err = <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">.5</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span> + sec);</span><br><span class="line">        <span class="title function_">cb</span>(err, sec);</span><br><span class="line">    &#125;, sec * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> (&#123;<span class="attr">func</span>: sleep, <span class="attr">params</span>: [x]&#125;));</span><br><span class="line"></span><br><span class="line"><span class="title function_">parallel</span>(funcs, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;parallel end&#x27;</span>, err, <span class="string">&#x27;data&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10 Sep 16:48:33 - delay sec 1</span><br><span class="line">parallel end Error: error1</span><br><span class="line">    at Timeout._onTimeout (/Users/yiihua-013/WebstormProjects/hiyundong/test.js:65:43)</span><br><span class="line">    at listOnTimeout (internal/timers.js:531:17)</span><br><span class="line">    at processTimers (internal/timers.js:475:7) data []</span><br><span class="line">10 Sep 16:48:34 - delay sec 2</span><br><span class="line">10 Sep 16:48:35 - delay sec 3</span><br></pre></td></tr></table></figure><h2 id="实现co-js-效果同bluebirdde-coroutine"><a href="#实现co-js-效果同bluebirdde-coroutine" class="headerlink" title="实现co.js,效果同bluebirdde#coroutine"></a>实现<a href="https://github.com/tj/co">co.js</a>,效果同bluebirdde#coroutine</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hander_error_ = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">flow</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> iter_ = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> <span class="title function_">next_</span> = data =&gt; &#123;</span><br><span class="line">            <span class="comment">// http://es6.ruanyifeng.com/#docs/generator#next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0</span></span><br><span class="line">            <span class="comment">// 将结果作为参数传递给next，yield左侧的变量就能被正确赋值，同时执行下一个异步操作。采用这种方式从上到下直到这个Generator对象中被yield分割的每一部分都执行完毕</span></span><br><span class="line">            <span class="keyword">var</span> result = iter_.<span class="title function_">next</span>(data);</span><br><span class="line">            <span class="keyword">if</span> (!result.<span class="property">done</span>) &#123;</span><br><span class="line">                result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">next_</span>(data);</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">                    hander_error_.<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                            <span class="title function_">handler</span>(err);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="title function_">next_</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                hander_error_.<span class="title function_">forEach</span>(<span class="function"><span class="params">handler</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                        <span class="title function_">handler</span>(err);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(flow, <span class="string">&#x27;catch&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        value     : <span class="keyword">function</span> (<span class="params">handler</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                hander_error_.<span class="title function_">push</span>(handler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">readFileAsync</span> = path =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> err ? <span class="title function_">reject</span>(err) : <span class="title function_">resolve</span>(data)));</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">delayAsync</span>    = sec =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, sec * <span class="number">1000</span>));</span><br><span class="line"><span class="keyword">const</span> log           = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="property">log</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hco = <span class="title function_">co</span>(<span class="keyword">function</span> *() &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;co begin&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">delayAsync</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">yield</span> <span class="title function_">readFileAsync</span>(__filename);</span><br><span class="line">    <span class="title function_">log</span>(ret);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;there is an error!&#x27;</span>);</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;co end&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">hco</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err:&#x27;</span>, err));</span><br></pre></td></tr></table></figure><p>co解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">readFileAsync</span> = path =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span> err ? <span class="title function_">reject</span>(err) : <span class="title function_">resolve</span>(data)));</span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">    <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileAsync</span>(<span class="string">&#x27;/etc/hosts&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;f1&#x27;</span>,f1.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileAsync</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;f2&#x27;</span>,f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">const</span> step1 = g.<span class="title function_">next</span>();</span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;step1&#x27;</span>,step1); <span class="comment">// step1 &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span></span><br><span class="line">step1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;data1&#x27;</span>,data); <span class="comment">// data1 &lt;Buffer 23 23 ... &gt;</span></span><br><span class="line">    <span class="comment">// 当promise#onFullfield的时候向next传递参数，yield得到的值就是next传递的参数</span></span><br><span class="line">    <span class="keyword">let</span> step2 = g.<span class="title function_">next</span>(data); <span class="comment">// 此处的参数影响 gen函数中的第一个console</span></span><br><span class="line">    <span class="title function_">log</span>(<span class="string">&#x27;step2&#x27;</span>,step2); <span class="comment">// step2 &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span></span><br><span class="line">    step2.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">log</span>(<span class="string">&#x27;data2&#x27;</span>,data); <span class="comment">// data2 &lt;Buffer 23 20 ... &gt;</span></span><br><span class="line">        g.<span class="title function_">next</span>(data); <span class="comment">// 指定gen中的第二个console</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_async_exec.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">App</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">syncExec</span> = <span class="built_in">require</span>(<span class="string">&#x27;./sync_exec&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">App</span>()</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">syncExec</span>([<span class="keyword">function</span>(<span class="params">next,args</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args:&#x27;</span>,args)</span><br><span class="line"><span class="title function_">next</span>() <span class="comment">// 必须调用next</span></span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">next,args</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args:&#x27;</span>,args)</span><br><span class="line"><span class="title function_">next</span>(<span class="number">22</span>)</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">next,args</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args:&#x27;</span>, args)</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;],&#123;<span class="attr">a</span>:-<span class="number">1</span>,<span class="attr">b</span>:-<span class="number">2</span>&#125;,-<span class="number">3</span>,-<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// args: [ &#123; a: -1, b: -2 &#125;, -3, -4 ]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// args: [ &#123; a: -1, b: -2 &#125;, -3, -4 ]</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// args: [ &#123; a: -1, b: -2 &#125;, -3, -4 ]</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h1 id="lodash中部分API的简单实现"><a href="#lodash中部分API的简单实现" class="headerlink" title="lodash中部分API的简单实现"></a>lodash中部分API的简单实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _ = <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">extend</span>:<span class="keyword">function</span>(<span class="params">origin,add</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!add || !<span class="variable language_">this</span>.<span class="title function_">isObject</span>(add)) <span class="keyword">return</span> origin</span><br><span class="line">        <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(add)</span><br><span class="line">        <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">        <span class="keyword">while</span>(i--) origin[keys[i]] = add[keys[i]]</span><br><span class="line">        <span class="keyword">return</span> origin    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isObject</span>:<span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">isString</span>:<span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toStirng</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object String]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见：<a href="https://coding.net/u/consoles/p/nodejs-start/git/blob/master/lodash/lodash.js">coding.net</a></p><h2 id="为console-log前面增加时间戳信息"><a href="#为console-log前面增加时间戳信息" class="headerlink" title="为console.log前面增加时间戳信息"></a>为<code>console.log</code>前面增加时间戳信息</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">log</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> _log = <span class="variable language_">console</span>.<span class="property">log</span></span><br><span class="line"><span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"><span class="keyword">let</span> dateTimeStr = <span class="string">`[ <span class="subst">$&#123;<span class="built_in">Date</span>()&#125;</span> ]`</span><span class="comment">// 日期字符串可采用必要的格式化，可参见moment.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;string&#x27;</span> === <span class="keyword">typeof</span> args[<span class="number">0</span>]) dateTimeStr += args.<span class="title function_">shift</span>(args)</span><br><span class="line"><span class="keyword">return</span> _log.<span class="title function_">apply</span>(<span class="variable language_">console</span>,[dateTimeStr].<span class="title function_">concat</span>(args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见<a href="https://coding.net/u/consoles/p/nodejs-start/git/blob/master/console/console.js">coding.net</a></p><h1 id="只能被调用一次的函数"><a href="#只能被调用一次的函数" class="headerlink" title="只能被调用一次的函数"></a>只能被调用一次的函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">only_once</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Callback was already called.&quot;</span>);</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        fn.<span class="title function_">apply</span>(root, <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debug</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;debug&#x27;</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">only_once</span>(debug)</span><br><span class="line"><span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// 第2次调用将会出错</span></span><br></pre></td></tr></table></figure><p>是闭包的经典应用，出自 async.js 源码。</p><h1 id="深入理解异步IO"><a href="#深入理解异步IO" class="headerlink" title="深入理解异步IO"></a>深入理解异步IO</h1><blockquote><p>在os中，程序的运行空间分为内核空间和用户空间。我们常常提到的异步IO实际上是<em>用户空间中的程序不用依赖内核空间中的IO操作实际完成，即可进行后续的任务</em>。</p></blockquote><h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>两个文件互相require并不会造成依赖死循环。第一次被require的对象将是不完整的对象。</p><p><a href="http://www.ruanyifeng.com/blog/2015/05/require.html">require源码解读</a><br><a href="https://segmentfault.com/a/1190000004151411">循环依赖</a></p><h1 id="一些技巧和优化"><a href="#一些技巧和优化" class="headerlink" title="一些技巧和优化"></a>一些技巧和优化</h1><ul><li>在一个函数的内部可以使用<code>console.trace()</code>打印出该函数的调用堆栈，注意：最先调用的方法在底。</li><li>少于 600 个字符的函数v8会进行优化，详见:<a href="https://juejin.im/post/584e74b5128fe10058b2aa6b">node优化的小小黑科技</a></li><li>由于utf-8编码是变长编码,长度可能在1~4个字节,所以最佳实践是定义缓冲区的大小为4的整数倍。</li></ul><h2 id="ES5和ES6中的实现class"><a href="#ES5和ES6中的实现class" class="headerlink" title="ES5和ES6中的实现class"></a>ES5和ES6中的实现class</h2><p>ES5中通常这样实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Agent</span>(<span class="params">options</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Agent</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Agent</span>(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Agent</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>ES5中为什么要做<code>instance of</code>的判断呢？这是因为ES5中类都是函数模拟的，所以调用Agent可以不用new关键字，直接像普通函数（或者使用call,apply）一样调用<code>Agent(options)</code>，此时的this就是函数调用时的this，但是这并不是我们希望的this，这样在this上的赋值就会污染外部的作用域（这是一个极度危险的操作）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Agent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Agent2</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Agent2</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Agent2</span>(options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = &#123;<span class="attr">options</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = <span class="title class_">Agent</span>.<span class="title function_">call</span>(ctx, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ctx, ret); <span class="comment">// 不使用new得到的实例为undefined，并且ctx中的值被改变了</span></span><br><span class="line">ret = <span class="title class_">Agent2</span>.<span class="title function_">call</span>(ctx, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ctx, ret); <span class="comment">// 同样的不合法的操作可以保证得到正确的实例，并且不会污染外边的作用域中的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; options: -1 &#125; undefined</span></span><br><span class="line"><span class="comment">// &#123; options: -1 &#125; Agent2 &#123; options: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>ES6中的class因为必须使用new关键字，因而简化了代码，无需使用上面的判断。</p><p>Socket IO,是完全异步的，没有涉及到线程；而文件IO是用多线程模拟的，具有不同的特点：</p><ul><li>本地磁盘读写比网络请求快得多</li><li>磁盘文件按块访问，OS的缓存机制使得顺序读写文件的效率极高</li></ul><p>Linux下node在启动时会维护一个线程池，libuv的默认线程池大小为4，可以使用<a href="https://nodejs.org/api/cli.html#cli_uv_threadpool_size_size">UV_THREADPOOL_SIZE</a>,命令行参数启动时指定。线程池使用的地方：</p><ul><li>fs api</li><li>异步加密方法,例如：crypto.pbkdf2(), crypto.scrypt(), crypto.randomBytes()</li><li>dns.lookup()</li><li>zlib api</li></ul><p>因为libuv的线程池是固定大小的，因此如果上述api花费了太长时间，必然会导致后续的上述api调用的性能出现问题。所以增大线程池大小是一个可能会提高程序性能。详见<a href="https://github.com/nodejs/node/issues/8436">dns.lookup阻塞了fs io</a></p><h2 id="js代码的编译和优化"><a href="#js代码的编译和优化" class="headerlink" title="js代码的编译和优化"></a>js代码的编译和优化</h2><h3 id="隐藏类"><a href="#隐藏类" class="headerlink" title="隐藏类"></a>隐藏类</h3><p>在静态语言中，开发者定义的类，每一个成员变量都有一个确定的类型。因为有了类型信息，一个对象包含哪些成员和这些成员在对象中的偏移量等信息编译阶段就可以确定，执行时CPU只需要用对象首地址加上成员在对象内部的偏移量就可以访问内部成员，这些访问指令在编译阶段就生成了。但对于js这种动态语言，变量在运行时可以随时由不同的类型赋值，并且对象本身可以随时添加删除成员。访问对象属性需要的信息完全由运行时决定。为了按照索引的方式访问成员，V8“悄悄滴”对运行中的对象分了类，这个过程中产生了一种V8内部的数据结构称为隐藏类，其本身是一个对象。</p><p>当定义一个构造函数，使用这个函数生成第一个对象的时候V8会为他初始化一个隐藏类。以后使用这个构造器生成的对象指向同一个隐藏类。但是如果程序中某个对象添加或者删除了某个属性，V8立即创建一个新的隐藏类，改变之后的对象指向新创建的隐藏类。隐藏类起到了分组对象的作用。同一组的对象具有相同的成员名称。隐藏类记录了成员的名称和偏移量，根据这些信息，V8能够按照对象首地址+偏移量访问成员变量。因此创建对象的时候最好一次性指定好对象的成员，动态增添属性会造成隐藏类的派生。</p><h3 id="优化回退"><a href="#优化回退" class="headerlink" title="优化回退"></a>优化回退</h3><p>程序在运行时，V8会采集js的运行数据，当发现某些函数执行比较频繁，就将其标记为热点函数。针对热点函数，V8会认为此函数比较稳定，类型已经确定，会调用编译器生成更高效的字节码，万一遇到类型变化(例如函数的入参由number变为string)，v8会将函数回退到优化前一般的情况。因此针对不同类型的参数尽量多写个函数而不是在同一个函数中进行类型区分。</p><h1 id="模板引擎Nunjucks中的坑"><a href="#模板引擎Nunjucks中的坑" class="headerlink" title="模板引擎Nunjucks中的坑"></a>模板引擎Nunjucks中的坑</h1><p>后端采用eggjs渲染模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123;<span class="string">&quot;lng&quot;</span>:<span class="number">114.0512961</span>,<span class="string">&quot;lat&quot;</span>:<span class="number">22.1333079</span>,<span class="string">&quot;count&quot;</span>:<span class="number">17</span>&#125;,&#123;<span class="string">&quot;lng&quot;</span>:<span class="number">114.0522961</span>,<span class="string">&quot;lat&quot;</span>:<span class="number">22.2333079</span>,<span class="string">&quot;count&quot;</span>:<span class="number">15</span>&#125;,&#123;<span class="string">&quot;lng&quot;</span>:<span class="number">114.0532961</span>,<span class="string">&quot;lat&quot;</span>:<span class="number">22.3333079</span>,<span class="string">&quot;count&quot;</span>:<span class="number">12</span>&#125;];</span><br><span class="line"><span class="keyword">await</span> ctx.<span class="title function_">render</span>(<span class="string">&#x27;map&#x27;</span>, &#123; data &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map.nj</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">  var points = </span><span class="template-variable">&#123;&#123; <span class="name">data</span> &#125;&#125;</span><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>渲染到页面全部成了<code>[[object Object],[object Object],[object Object]]</code>,原来默认会调用toString方法,JSON中的双引号被转义了，所以还需要使用<code>safe</code>防止其转义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var points = &#123;&#123; data | dump &#125;&#125;  // 这个是错误的，要写成下面的</span></span><br><span class="line"><span class="keyword">var</span> points = &#123;&#123; data | dump | safe &#125;&#125;;</span><br></pre></td></tr></table></figure><p>参见:(<a href="https://github.com/mozilla/nunjucks/issues/94">https://github.com/mozilla/nunjucks/issues/94</a>)</p><h1 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h1><h2 id="生成器函数和Iterator接口"><a href="#生成器函数和Iterator接口" class="headerlink" title="生成器函数和Iterator接口"></a>生成器函数和Iterator接口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) <span class="keyword">yield</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br></pre></td></tr></table></figure><h2 id="实现状态机"><a href="#实现状态机" class="headerlink" title="实现状态机"></a>实现状态机</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state_machine = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;state:A&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;state:B&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;state:C&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">state_machine</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++) <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>是一个函数用来修饰类的行为。第三方库code-decorator。日志系统可以用这种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = type =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target,name,descriptor</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> src_method = descriptor.<span class="property">value</span>;</span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      src_method.<span class="title function_">apply</span>(target,args);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`log <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中只写业务，不埋点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AD</span>&#123;</span><br><span class="line">  @<span class="title function_">log</span>(<span class="string">&#x27;show&#x27;</span>)</span><br><span class="line">  <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ad is show&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  @<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">  <span class="title function_">click</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ad is click&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ad = <span class="keyword">new</span> <span class="title function_">AD</span>();</span><br><span class="line">ad.<span class="title function_">show</span>();</span><br><span class="line">ad.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure><blockquote><p>在没有重复使用3次以上的场景下避免使用抽象。过早优化是万恶之源。</p></blockquote><h1 id="async-await-和内存泄漏"><a href="#async-await-和内存泄漏" class="headerlink" title="async &amp; await 和内存泄漏"></a>async &amp; await 和内存泄漏</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;start&#x27;);</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(_.<span class="title function_">random</span>(<span class="number">10</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="comment">// console.log(&#x27;done&#x27;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">doTask</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">start</span>(); <span class="comment">// await 这里存在内存泄漏(将前面的await去掉/改成循环 则不会有这个问题)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="title function_">memoryUsage</span>());</span><br><span class="line">&#125;,<span class="number">10e3</span>);</span><br></pre></td></tr></table></figure><p>上面的代码存在内存泄漏问题：</p><p>进程启动的时候占用内存是22M</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">30211 devel     20   0 1229m 381m  10m S  1.0  9.6   1:36.63 node test.js</span><br><span class="line"><span class="comment"># 在start函数的递归调用中取消await</span></span><br><span class="line">21729 devel     20   0  867m  23m  10m S  1.0  0.6   1:22.73 node test.js</span><br><span class="line"><span class="comment"># 改成循环</span></span><br><span class="line">14498 devel     20   0  867m  24m  10m S  1.0  0.6   1:11.04 node test.js</span><br></pre></td></tr></table></figure><p>上面的内存泄漏的原因在于promise不断堆积来不及销毁，参见：<a href="https://segmentfault.com/q/1010000017498684?_ea=5678155">https://segmentfault.com/q/1010000017498684?_ea=5678155</a></p><p>Node 的 Buffer 模块性能相关部分有 C++ 实现，所以 Buffer 对象的内存分配不是在 V8 的堆内存中，而是在 Node 的 C++ 层面实现内存申请的（<strong>Buffer的内存虽然由Node的C&#x2F;C++层面实现内存申请，但是变量的回收的还是由V8的GC管理的</strong>）。</p><p>Buffer 中采用了零拷贝的优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 零拷贝文件传输，使用了 sendfile 系统调用，数据不经过用户空间</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;input.txt&#x27;</span>)</span><br><span class="line">  .<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> socket = net.<span class="title function_">connect</span>(<span class="number">80</span>, <span class="string">&#x27;example.com&#x27;</span>);</span><br><span class="line"><span class="comment">// 直接发送Buffer无需序列化</span></span><br><span class="line">socket.<span class="title function_">write</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;GET / HTTP/1.1\r\n\r\n&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf1 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">512</span>); <span class="comment">// 共享内存，slice 操作不复制数据，共享底层内存数据</span></span><br></pre></td></tr></table></figure><p>关于 Buffer 有以下的最佳实践：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优于fs.readFile()的完全加载</span></span><br><span class="line">fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;large.file&#x27;</span>, &#123; <span class="attr">highWaterMark</span>: <span class="number">64</span> * <span class="number">1024</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的做法（导致拷贝）</span></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(originalBuffer);</span><br><span class="line"><span class="comment">// 好的做法（共享内存）</span></span><br><span class="line"><span class="keyword">const</span> view = originalBuffer.<span class="title function_">subarray</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><blockquote><p>人这一生，风雨兼程，就是为了遇见更好的自己。不论顺风还是逆风，用心生活，用力向上，就是对生命最好的回馈。—— 《人民日报》</p></blockquote><h1 id="实现文件锁"><a href="#实现文件锁" class="headerlink" title="实现文件锁"></a>实现文件锁</h1><p><code>fs.writeFile(lockFile, process.pid, &#123; flag: &#39;wx&#39; &#125;, err =&gt; &#123;&#125;);</code> 以独占方式写入文件，但是在网络磁盘下，一些操作系统并不能很好识别 <code>0_EXCL</code> 标记。绕开这个策略的更好方式是将锁文件变为目录。<code>fs.mkdir</code> 是一个原子操作，能很好支持跨平台，网络磁盘上也能很好运行。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>使用 <code>process.on(&#39;uncaughtException&#39;)</code> *捕获程序的异常让其继续执行并不是一个好主意。*因为可能导致内存泄露，系统可能变得非常不稳定，得不偿失！例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 将错误掩盖了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当客户端请求的时候会抛出异常被 <code>uncaughtException</code> 捕获，但是客户端的请求会一直保持，直到客户端超时（我们也没有办法去提供一个返回信息）。在大多数时候可能是打开的 socket 或者文件无法正确关闭。未捕获的异常通常在代码中埋得很深，这会让确定资源泄露的问题变得非常困难。所在的背景情况也会受到影响因为未捕获的异常会跳出当前上下文（uncaughtException 处理方法），让你丢失了错误相关对象的引用信息。在我们的意思中，我们没有办法访问到 res 对象来给客户端响应。</p><p>使用 <code>uncaughtException</code> 的好处是可以让应用适时打印日志以及重启。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    server.<span class="title function_">close</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(process.<span class="property">exit</span>, <span class="number">5000</span>, <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>uncaughtException</code> 的处理函数是最后一道防线，理想情况下，异常应在在更加接近发生的时候进行处理，以防止泄露和不稳定来源。</p><h1 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h1><p>调试 cpu 挂起问题的时候，跟踪工具将是强大的武器。例如当进程的 ulimit 溢出的时候，通常是 cpu 挂起，然后 open 系统调用会一直失败，运行 strace 监控进程就可以发现很多 ENFILE 错误。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell 基础 —— 变量和配置文件</title>
      <link href="/2016/03/26/linux-shell-varible/"/>
      <url>/2016/03/26/linux-shell-varible/</url>
      
        <content type="html"><![CDATA[<p>一直以为Unix时间戳和JavaScript中的<code>Date.now()</code>的结果一致，但是最近才发现，<code>Date.now()</code>是精确到毫秒级的，去掉末尾的3位就可以和时间戳完美匹配。</p><h1 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure><p>注意等号的前后不能有空格,如果value是字符串且有空格必须使用引号.例如以下的定义都是非法的!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x= 1</span><br><span class="line">x =1</span><br><span class="line">x = 1</span><br><span class="line">x=hello world</span><br></pre></td></tr></table></figure><p>因为如果有空格的话,前面的单词会被解析为系统命令,而后面的参数会被解析为选项.</p><p>使用变量只需要在变量前面加上<code>$</code>即可,例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span> <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>*注意:*双引号和单引号的区别:单引号中的变量相当于ES6中的模板字符串,而单引号中的内容完全就是字符串,丧失了原有的变量替换.<br>*注意:*shell中的变量默认都是字符串,例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line">y=2</span><br><span class="line">z=<span class="variable">$x</span>+<span class="variable">$y</span> <span class="comment"># 1+2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$z</span></span><br></pre></td></tr></table></figure><h2 id="变量叠加"><a href="#变量叠加" class="headerlink" title="变量叠加"></a>变量叠加</h2><p>相当于拼接字符串,例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=123</span><br><span class="line">x=<span class="string">&quot;<span class="variable">$x</span>&quot;</span>456</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x</span> <span class="comment"># 123456</span></span><br><span class="line"><span class="comment"># 我们也可以使用下面的方式</span></span><br><span class="line">x=<span class="variable">$&#123;x&#125;</span>789</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$x</span> <span class="comment"># 123456789</span></span><br></pre></td></tr></table></figure><p>Tips:使用<code>set -u</code>命令后,如果我们使用未定义的变量将会得到明确的错误信息(默认显示为空),可以帮助我们排错.</p><h2 id="变量删除"><a href="#变量删除" class="headerlink" title="变量删除"></a>变量删除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">unset</span> a <span class="comment"># 删除变量</span></span><br></pre></td></tr></table></figure><h1 id="Bash环境变量"><a href="#Bash环境变量" class="headerlink" title="Bash环境变量"></a>Bash环境变量</h1><p>首先我们要明确一点:<em>环境变量是全局变量(当前shell和子shell),而用户自定义变量是局部变量(当前shell)</em>,在shell中我们输入<code>bash</code>或者<code>sh</code>即可进入到子shell.我们可以使用<code>pstree</code>显示进程树得到通过ssh连接上的shell.</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> 变量名=变量值</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">变量名=变量值</span><br><span class="line"><span class="built_in">export</span> 变量名</span><br></pre></td></tr></table></figure><p>我们<code>unset</code>子shell中的环境变量,父shell中的环境变量仍然存在.可以使用<code>set</code>或者<code>env</code>得到系统环境变量.</p><h2 id="PS1环境变量"><a href="#PS1环境变量" class="headerlink" title="PS1环境变量"></a>PS1环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PS1</span> <span class="comment"># \u@\h:\w\$</span></span><br></pre></td></tr></table></figure><p>分别表示:用户名@主机名:当期路径 提示符,我们完全可以更改成自己的,例如:</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/linux-ps1-env.png" alt="Linux PS1环境变量"></p><h2 id="语系变量"><a href="#语系变量" class="headerlink" title="语系变量"></a>语系变量</h2><p>语系变量决定了命令的显示语言</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locale <span class="comment"># 查看当前语系,也可以使用echo $LANG命令查看当前语系</span></span><br></pre></td></tr></table></figure><h1 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h1><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/linux-position-varible.png" alt="linux位置参数变量"></p><p>例如有以下的add.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">num1=<span class="variable">$1</span></span><br><span class="line">num2=<span class="variable">$2</span></span><br><span class="line"><span class="built_in">sum</span>=$((<span class="variable">$num1</span>+<span class="variable">$num2</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure><p>在命令行中我们之一这样运行脚本:<code>sh add.sh 10 20</code></p><p><code>$*</code>和<code>$@</code>都可以取得命令的所有参数,不同的是<code>$*</code>将参数看做了一个整体,例如有以下的<code>test.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test $*&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;The parameter is: <span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;test $@&#x27;</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Parameter:<span class="variable">$y</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The length of the parameters is <span class="variable">$#</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@iZ28pw6rq5sZ:~# ./test.sh 1 2 3 4 5</span><br><span class="line"><span class="built_in">test</span> $*</span><br><span class="line">The parameter is: 1 2 3 4 5</span><br><span class="line"><span class="built_in">test</span> <span class="variable">$@</span></span><br><span class="line">Parameter:1</span><br><span class="line">Parameter:2</span><br><span class="line">Parameter:3</span><br><span class="line">Parameter:4</span><br><span class="line">Parameter:5</span><br><span class="line">The length of the parameters is 5</span><br></pre></td></tr></table></figure><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/linux-sys-define-varible.png" alt="linux预定义变量"></p><h2 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h2><p>该命令用于接收标准输入,并将输入保存到变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you name: &quot;</span> -t 10 name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your name is:<span class="variable">$name</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input you password:&quot;</span> -s password</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your password is:<span class="variable">$password</span>&quot;</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input your sex [M/F]&quot;</span> -n 1 sex</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;your sex is <span class="variable">$sex</span>&quot;</span></span><br></pre></td></tr></table></figure><p>*注意:*执行脚本的时候使用<code>chmod 755 read.sh</code>然后<code>./read.sh</code>的方式执行,否则会出现参数错误.</p><h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><blockquote><p><code>source</code>命令让配置文件立即生效,可以简写为<code>.</code></p></blockquote><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/linux-config-file-load-sequence.png" alt="环境变量配置文件的加载顺序"></p><p><code>umask</code>查看系统的默认权限.注意:文件的最高权限是666(即创建一个文件默认是没有执行权限的,安全性的考虑),目录的最高权限是777(目录的执行权限表示能否进入这个目录).定义了默认的<em>需要排除的权限</em>,请看下面的例子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">umask</span></span><br><span class="line">$ 002 <span class="comment"># -------w-,准备丢弃的权限是 u-w</span></span><br><span class="line">$ <span class="built_in">touch</span> a;ll a <span class="comment"># 创建文件</span></span><br><span class="line">$ -rw-rw-r-- 1 consoles consoles 0  4月 16 09:14 b <span class="comment"># 即从 -rw-rw-rw-中取消的用户的w权限,不能简单理解为数字的减法</span></span><br><span class="line">$ <span class="built_in">mkdir</span> b;ll <span class="comment"># 创建目录</span></span><br><span class="line">$ drwxrwxr-x   2 consoles consoles   4096  4月 16 09:18 b/ <span class="comment"># 即从 drwxrwxrwx中取消用户的w权限</span></span><br></pre></td></tr></table></figure><ul><li>历史命令保存在<code>~/.bash_history</code>,注意:本次登陆的历史命令保存在内存,下一次登陆的时候才会同步到此文件.</li><li><em>本地</em>终端前欢迎信息<code>/etc/issue</code>,详见<a href="http://blog.csdn.net/gao5528/article/details/17217737">自定义登陆欢迎信息</a>.</li><li><em>远程</em>终端前欢迎信息<code>/etc/issue.net</code>,但是不支持转义符号,是否显示此欢迎信息由ssh配置(<code>/etc/ssh/ssh_config</code>)决定,在此文件的最后追加<code>Banner /etc/issue.net</code>才可生效</li><li>登陆后欢迎信息<code>/etc/motd</code></li></ul><h1 id="Shell中输出多行文本可以使用here-document（cat-EOF）"><a href="#Shell中输出多行文本可以使用here-document（cat-EOF）" class="headerlink" title="Shell中输出多行文本可以使用here document（cat EOF）"></a>Shell中输出多行文本可以使用here document（cat EOF）</h1><p>例如<a href="https://github.com/tj/n/blob/master/bin/n#L149">n模块</a>中的这行代码，使用说明详见<a href="https://my.oschina.net/u/1032146/blog/146941">git osc</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的新api</title>
      <link href="/2016/03/26/new-api-in-js/"/>
      <url>/2016/03/26/new-api-in-js/</url>
      
        <content type="html"><![CDATA[<blockquote><p>梦想还是要有的，万一见鬼了呢。</p></blockquote><h1 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h1><h2 id="早期动画循环"><a href="#早期动画循环" class="headerlink" title="早期动画循环"></a>早期动画循环</h2><p>在js中创建动画最简单的方式是使用<code>setInterval()</code>,如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateAnimations</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">doAnimation1</span>()</span><br><span class="line">    <span class="title function_">doAnimation2</span>()</span><br><span class="line">    <span class="comment">// other animations</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setInterval</span>(updateAnimations,delta)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>编写这种动画的关键是知道delta多长合适.一方面delta越短,动画越平滑;另一方面考虑到性能的问题,delta要足够长.多数显示器的刷新频率是60Hz,因此最平滑的delta &#x3D; 1000 &#x2F; 60 &#x3D; 17ms,但是问题来了<code>setInterval()</code>函数的间隔是不确定的,只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务,那动画代码就要等前面的任务完成后再执行。简言之,以毫秒表示的延迟时间并不代表到时候一定会执行动画代码,而仅代表到时候会把代码添加到任务队列中。如果UI线程繁忙,比如忙于处理用户操作,那么即使把代码加入队列也不会立即执行。</p><p>另一方面,计时器的精度是不同的,IE8为15.625ms,现代浏览器的计时精度一般是4ms,更为严重的问题是浏览器会限制后台的非活动标签页,即使做了间隔时间的优化也不可能得到我们想要的结果.</p><h2 id="为什么使用requestAnimationFrame渲染动画更好"><a href="#为什么使用requestAnimationFrame渲染动画更好" class="headerlink" title="为什么使用requestAnimationFrame渲染动画更好"></a>为什么使用requestAnimationFrame渲染动画更好</h2><p>首先思考这样一个问题:CSS动画相比与javascript动画的优势在哪?CSS变换和动画的优势在于浏览器知道动画什么时候开始,因此会计算出正确的时间间隔,在恰当的事件刷新UI,而对于javascript动画,无知晓什么时候开始.因此<code>requestAnimationFrame()</code>这个API就告诉浏览器某些js代码会执行动画,这样浏览器就会对其进行优化.该方法就收的参数是重绘前调用的一个函数,用于改变下一次重绘时的DOM样式.我们可以像<code>setTimeout()</code>一样使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;status&#x27;</span>)</span><br><span class="line">  div.<span class="property">style</span>.<span class="property">width</span> = (<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>) + <span class="number">5</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  <span class="keyword">if</span>(div.<span class="property">style</span>.<span class="property">left</span> != <span class="string">&#x27;100%&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(updateProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(updateProgress)</span><br></pre></td></tr></table></figure><blockquote><p>目前来看,mozRequestAnimationFrame()解决了浏览器不知道JavaScript动画什么时候开始、不知道最佳循环间隔时间的问题,但不知道代码到底什么时候执行的问题呢?同样的方案也可以解决这个问题。我们传递的mozRequestAnimationFrame()函数也会接收一个参数,它是一个时间码(从1970年1月1日起至今的毫秒数),表示下一次重绘的实际发生时间。注意,这一点很重要:mozRequestAnimationFrame()会根据这个时间码设定将来的某个时刻进行重绘,而根据这个时间码,你也能知道那个时刻是什么时间。然后,再优化动画效果就有了依据。要知道距离上一次重绘已经过去了多长时间,可以查询mozAnimationStartTime,其中包含上一次重绘的时间码。用传入回调函数的时间码减去这个时间码,就能计算出在屏幕上重绘下一组变化之前要经过多长时间。使用这个值的典型方式如下:</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">timestamp</span>)&#123;</span><br><span class="line">    <span class="comment">// 两次绘制的时间间隔</span></span><br><span class="line">    <span class="keyword">var</span> drawStart = timestamp || <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">        diff = drawStart - startTime</span><br><span class="line"></span><br><span class="line">    startTime = drawStart</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(draw)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> requestAnimationFrame = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">mozRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> || <span class="variable language_">window</span>.<span class="property">msRequestAnimationFrame</span>,</span><br><span class="line">      startTime = <span class="variable language_">window</span>.<span class="property">mozAnimationStartTime</span> || <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(draw)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h1><p>如果页面不是处于活动状态,有些功能是可以停下来的,例如(轮询Server或者动画效果).可见性API就是针对这个而设计的.该API有3部分组成:</p><ul><li>document.hidden:页面处于隐藏(后台标签页或者浏览器最小化)</li><li>document.visibilityState有以下4个状态:<ul><li>后台标签页中或浏览器最小化</li><li>在前台标签页中</li><li>实际的页面已经隐藏,但用户可以看到页面的预览(例如win7任务栏预览)</li><li>页面在屏幕外执行渲染</li></ul></li></ul><p>visibilitychange事件,当文档从可见变为不可见或从不可见变为可见时,触发该事件,检测页面是否隐藏:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span> || <span class="variable language_">document</span>.<span class="property">msHidden</span> || <span class="variable language_">document</span>.<span class="property">webKitHidden</span>)&#123;</span><br><span class="line">  <span class="comment">//页面隐藏了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//页面未隐藏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在不支持该API的浏览器中会提示页面未隐藏。这是Page Visibility API有意设计的结果,目的是为了向后兼容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleVisibilityChange</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;output&quot;</span>),</span><br><span class="line">  msg;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span> || <span class="variable language_">document</span>.<span class="property">msHidden</span> || <span class="variable language_">document</span>.<span class="property">webkitHidden</span>)&#123;</span><br><span class="line">    msg = <span class="string">&quot;Page is now hidden. &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    msg = <span class="string">&quot;Page is now visible. &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  output.<span class="property">innerHTML</span> += msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要为两个事件都指定事件处理程序</span></span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(<span class="variable language_">document</span>, <span class="string">&quot;msvisibilitychange&quot;</span>, handleVisibilityChange);</span><br><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(<span class="variable language_">document</span>, <span class="string">&quot;webkitvisibilitychange&quot;</span>, handleVisibilityChange);</span><br></pre></td></tr></table></figure><h1 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h1><p>地理定位(geolocation)是最令人兴奋,而且得到了广泛支持的一个新API。以下代码将在地图上绘制用户的位置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(<span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">  <span class="title function_">drawMapCenteredAt</span>(position.<span class="property">coords</span>.<span class="property">latitude</span>, positions.<span class="property">coords</span>.<span class="property">longitude</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error code: &quot;</span> + error.<span class="property">code</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error message: &quot;</span> + error.<span class="property">message</span>);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">enableHighAccuracy</span>: <span class="literal">true</span>, <span class="comment">// 高精度,将消耗更多电量</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">maximumAge</span>: <span class="number">25000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你希望跟踪用户的位置,那么可以使用另一个方法watchPosition()。这个方法接收的参数与getCurrentPosition()方法完全相同。实际上,watchPosition()与定时调用getCurrentPosition()的效果相同。在第一次调用watchPosition()方法后,会取得当前位置,执行成功回调或者错误回调。然后,watchPosition()就地等待系统发出位置已改变的信号(它不会自己轮询位置)。</p><p>调用<code>watchPosition()</code>会返回一个数值标识符,用于跟踪监控的操作。基于这个返回值可以取消监控操作,只要将其传递给<code>clearWatch()</code>方法即可(与使用setTimeout()和clearTimeout()类似)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watchId = navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(<span class="keyword">function</span>(<span class="params">position</span>)&#123;</span><br><span class="line">  <span class="title function_">drawMapCenteredAt</span>(position.<span class="property">coords</span>.<span class="property">latitude</span>, positions.<span class="property">coords</span>.<span class="property">longitude</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error code: &quot;</span> + error.<span class="property">code</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error message: &quot;</span> + error.<span class="property">message</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">clearWatch</span>(watchId);</span><br></pre></td></tr></table></figure><h2 id="原生js模拟用户点击"><a href="#原生js模拟用户点击" class="headerlink" title="原生js模拟用户点击"></a>原生js模拟用户点击</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> <span class="title function_">listener</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">click</span>(); <span class="comment">// 模拟用户点击</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 高级技巧</title>
      <link href="/2016/03/25/high-level-js/"/>
      <url>/2016/03/25/high-level-js/</url>
      
        <content type="html"><![CDATA[<h1 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h1><h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>例如以下的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不是 new 出来的,而是直接将构造函数当做一个普通的函数调用就会将<code>name</code>属性绑定到 window 上面(this 指向 window):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>(<span class="number">123</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>以上的操作<em>为 window 添加了新的属性</em>,导致 window 的属性意外增加或者覆盖!解决方案是创建一个作用域安全的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的函数要么使用现有的实例,要么创建新的实例,this 指向的始终是实例,避免了在全局对象上意外增加属性，这是最佳实践（直接使用 ES6 class 才是最佳实践！）。</p><h2 id="js-中的类和继承"><a href="#js-中的类和继承" class="headerlink" title="js 中的类和继承"></a>js 中的类和继承</h2><h3 id="类定义的方法"><a href="#类定义的方法" class="headerlink" title="类定义的方法"></a>类定义的方法</h3><p>构造函数定义类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;michaelqin&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><p>对象创建方法定义类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;michaelqin&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>);</span><br><span class="line">person.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure><p>ES5推荐使用第二种模式，但是原型法更普遍。</p><h3 id="类继承的方法"><a href="#类继承的方法" class="headerlink" title="类继承的方法"></a>类继承的方法</h3><p>原型链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 人继承自动物</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="string">&#x27;Person&#x27;</span>; <span class="comment">// 更新构造函数为人</span></span><br></pre></td></tr></table></figure><p>属性复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(prop <span class="keyword">in</span> <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>[prop] = <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>[prop];</span><br><span class="line">&#125; <span class="comment">// 复制动物的所有属性到人量边</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="string">&#x27;Person&#x27;</span>; <span class="comment">// 更新构造函数为人</span></span><br></pre></td></tr></table></figure><p>ES5中的继承是通过<em>借用父类的构造方法</em>来实现方法&#x2F;属性的继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">supFather</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]; <span class="comment">// 复杂类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">supFather.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 借用父类的方法：修改它的this指向,赋值父类的构造函数里面方法、属性到子类上</span></span><br><span class="line">    supFather.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写子类的prototype，修正constructor指向</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">sonFn, fatherFn</span>) &#123;</span><br><span class="line">    sonFn.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fatherFn.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 继承父类的属性以及方法</span></span><br><span class="line">    sonFn.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = sonFn; <span class="comment">// 修正constructor指向到继承的那个函数上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(sub, supFather);</span><br><span class="line">sub.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化子类，可以在实例上找到属性、方法</span></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title function_">sub</span>(<span class="string">&quot;OBKoro1&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title function_">sub</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1);</span><br><span class="line"><span class="comment">//&gt;&gt; &#123;&quot;name&quot;:&quot;OBKoro1&quot;,&quot;colors&quot;:[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;],&quot;age&quot;:24&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2);</span><br><span class="line"><span class="comment">//&gt;&gt; &#123;&quot;name&quot;:&quot;小明&quot;,&quot;colors&quot;:[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;],&quot;age&quot;:18&#125;</span></span><br></pre></td></tr></table></figure><p>js中多重继承的实现就是使用属性复制来实现的，因为当父类的<code>prototype</code>属性被复制后，子类自然拥有类似的行为和属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mixinClass</span> = (<span class="params">base, ...mixins</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">mixinProps</span> = (<span class="params">target, source</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(source).<span class="title function_">forEach</span>(<span class="function"><span class="params">prop</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^constructor$/</span>.<span class="title function_">test</span>(prop)) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, prop, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, prop));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Ctor</span>;</span><br><span class="line">  <span class="keyword">if</span> (base &amp;&amp; <span class="keyword">typeof</span> base === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="keyword">class</span> <span class="title class_">extends</span> base &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">...props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(...props);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mixins.<span class="title function_">forEach</span>(<span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">mixinProps</span>(<span class="title class_">Ctor</span>.<span class="property"><span class="keyword">prototype</span></span>, source.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Ctor</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">methodA</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="title function_">methodB</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixinClass</span>(A, B) &#123;</span><br><span class="line">  <span class="title function_">methodA</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;methodA in C&#x27;</span>); &#125;</span><br><span class="line">  <span class="title function_">methodC</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c <span class="keyword">instanceof</span> C  <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> A  <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> B  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>工厂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Person1&#x27;</span>; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Animal1&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Factory</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Factory</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getInstance</span> = <span class="keyword">function</span>(<span class="params">className</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">&#x27;new &#x27;</span> + className + <span class="string">&#x27;()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> factory = <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line"><span class="keyword">var</span> obj1 = factory.<span class="title function_">getInstance</span>(<span class="string">&#x27;Person&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = factory.<span class="title function_">getInstance</span>(<span class="string">&#x27;Animal&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// Person1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// Animal1</span></span><br></pre></td></tr></table></figure><p>代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;michaelqin&#x27;</span>); &#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">30</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PersonProxy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">person</span> = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callMethod</span> = <span class="keyword">function</span>(<span class="params">functionName</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before proxy:&#x27;</span>, functionName);</span><br><span class="line">    that.<span class="property">person</span>[functionName](); <span class="comment">// 代理</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after proxy:&#x27;</span>, functionName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pp = <span class="keyword">new</span> <span class="title class_">PersonProxy</span>();</span><br><span class="line">pp.<span class="title function_">callMethod</span>(<span class="string">&#x27;sayName&#x27;</span>); <span class="comment">// 代理调用Person的方法sayName()</span></span><br><span class="line">pp.<span class="title function_">callMethod</span>(<span class="string">&#x27;sayAge&#x27;</span>); <span class="comment">// 代理调用Person的方法sayAge()</span></span><br></pre></td></tr></table></figure><p>观察者，又称事件模式，例如按钮的onclick</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Publisher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">listeners</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Publisher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="string">&#x27;addListener&#x27;</span>: <span class="keyword">function</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;removeListener&#x27;</span>: <span class="keyword">function</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">listeners</span>[listener];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;notify&#x27;</span>: <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> listener = <span class="variable language_">this</span>.<span class="property">listeners</span>[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        listener.<span class="title function_">process</span>(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// 发布者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Subscriber</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subscriber</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="string">&#x27;process&#x27;</span>: <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;　<span class="comment">// 订阅者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> publisher = <span class="keyword">new</span> <span class="title class_">Publisher</span>();</span><br><span class="line">publisher.<span class="title function_">addListener</span>(<span class="keyword">new</span> <span class="title class_">Subscriber</span>());</span><br><span class="line">publisher.<span class="title function_">addListener</span>(<span class="keyword">new</span> <span class="title class_">Subscriber</span>());</span><br><span class="line">publisher.<span class="title function_">notify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;michaelqin&#x27;</span>, <span class="attr">ageo</span>: <span class="number">30</span>&#125;); <span class="comment">// 发布一个对象到所有订阅者</span></span><br><span class="line">publisher.<span class="title function_">notify</span>(<span class="string">&#x27;2 subscribers will both perform process&#x27;</span>); <span class="comment">// 发布一个字符串到所有订阅者</span></span><br></pre></td></tr></table></figure><h1 id="原型式污染"><a href="#原型式污染" class="headerlink" title="原型式污染"></a>原型式污染</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>:<span class="number">1</span>&#125;</span><br><span class="line">foo.<span class="property">bar</span> <span class="comment">// 1</span></span><br><span class="line">foo.<span class="property">__proto__</span>.<span class="property">bar</span> = <span class="number">233</span></span><br><span class="line">foo.<span class="property">bar</span> <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;&#125;</span><br><span class="line">zoo.<span class="property">bar</span> <span class="comment">// 233</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// &#123; bar: 233 &#125;</span></span><br></pre></td></tr></table></figure><p>而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为233，后来，我们又用Object类创建了一个zoo对象let zoo &#x3D; {}，zoo对象自然也有一个bar属性了。</p><p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p><h1 id="js面试题"><a href="#js面试题" class="headerlink" title="js面试题"></a>js面试题</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ƒ <span class="function"><span class="title">b</span></span>()&#123;</span><br><span class="line">    b = 20;</span><br><span class="line">    console.log(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要考察作用域和var的变量提升，如果把匿名函数中的<code>b = 20</code>改成<code>var b = 20</code>，则会输出20，上面的b其实是个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">func</span>: func &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.<span class="title function_">func</span>(); <span class="comment">//&gt;&gt; 3</span></span><br><span class="line">(p.<span class="property">func</span> = o.<span class="property">func</span>)(); <span class="comment">//&gt;&gt; 2 ，注意：输出不是4</span></span><br><span class="line"><span class="comment">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span></span><br><span class="line"><span class="comment">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></span><br></pre></td></tr></table></figure><h2 id="如何实现一个深拷贝"><a href="#如何实现一个深拷贝" class="headerlink" title="如何实现一个深拷贝"></a>如何实现一个深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    <span class="attr">c</span>: &#123;</span><br><span class="line">        <span class="attr">d</span>: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">obj</span> = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cloneDeep</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> clone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">// 解决循环引用</span></span><br><span class="line">        map.<span class="title function_">set</span>(obj, clone);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">            clone[key] = <span class="title function_">cloneDeep</span>(obj[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">cloneDeep</span>(obj);</span><br><span class="line">copy.<span class="property">obj</span>.<span class="property">b</span>.<span class="title function_">push</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj, copy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; a: 1, b: [ 1, 2, 3, 4, 5 ], c: &#123; d: 12 &#125;, obj: [Circular] &#125; &#123; a: 1, b: [ 1, 2, 3, 4, 5, -1 ], c: &#123; d: 12 &#125;, obj: [Circular] &#125;</span></span><br></pre></td></tr></table></figure><p>注意：我们常用<code>Object.assign(&#123;&#125;,obj)</code>来拷贝对象，但是这其实是浅拷贝，可以参考<code>lodash.cloneDeep</code>。</p><h2 id="ES6-let关键字的坑"><a href="#ES6-let关键字的坑" class="headerlink" title="ES6 let关键字的坑"></a>ES6 let关键字的坑</h2><h3 id="不能被重复声明"><a href="#不能被重复声明" class="headerlink" title="不能被重复声明"></a>不能被重复声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (<span class="params">a</span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;outside&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//Uncaught ReferenceError: Cannot access &#x27;a&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">&quot;inside&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js中的字符串"><a href="#js中的字符串" class="headerlink" title="js中的字符串"></a>js中的字符串</h2><p>字符串是不可变对象，意味着我们不能单独改变某一特定索引的字符，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">str[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span>; <span class="comment">// str仍然是123</span></span><br></pre></td></tr></table></figure><h2 id="解构的妙用"><a href="#解构的妙用" class="headerlink" title="解构的妙用"></a>解构的妙用</h2><p>常用在配置的默认值初始化，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = &#123;<span class="attr">host</span>:<span class="literal">null</span>,<span class="attr">port</span>:<span class="literal">null</span>,...options&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">host</span>:<span class="literal">null</span>,<span class="attr">port</span>:<span class="literal">null</span>&#125;,options)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他跨域解决方案</title>
      <link href="/2016/03/24/other-cors/"/>
      <url>/2016/03/24/other-cors/</url>
      
        <content type="html"><![CDATA[<h1 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h1><p>这种技术的原理就是利用<code>&lt;img&gt;</code>标签.一个网页可以从任何站点加载图片而无需担心跨域问题,这也是在线广告跟踪浏览量的主要方式.我们也可以动态创建图像,使用它们的<code>onload</code>和<code>onerror</code>事件处理程序来确定是否收到了响应.</p><p>动态创建图像经常用于图像<em>Ping</em>.图像Ping是与服务器进行简单的,单向的跨域的一种方式.请求的数据是通过查询字符串的形式发送的,而响应可以是任何内容,但通常是像素图或者204响应.通过图像Ping,浏览器得不到任何具体的数据,但通过侦听<code>load</code>和<code>error</code>事件能知道响应什么时候接收到.例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;http://www.test.com/test?name=Mice&#x27;</span></span><br></pre></td></tr></table></figure><p>以上的请求在设置<code>src</code>属性的那一刻就开始了,图像Ping最常用于跟踪用户点击页面或者动态广告曝光次数.图像Ping有2个缺点:①只能发送GET请求;②无法访问服务器的响应文本.因此图像Ping只能用于浏览器和服务器之间的单向通信.</p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>json with padding(填充式json或者参数式json),jsonp使用一个函数将真实的JSON包围了起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">callback</span>(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Jetty&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的例子展示了JSONP的2个组成部分回调函数和数据,下面是一个典型的JSONP请求:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://freegeoip.net/json/?callback=handleResponse</span><br></pre></td></tr></table></figure><p>这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的,就像上面的URL所示,这里指定的回调函数的名字叫handleResponse()。JSONP是通过动态<code>&lt;script&gt;</code>元素来使用的,使用时可以为<code>src</code>属性指定一个跨域URL。这里的<code>&lt;script&gt;</code>元素与<code>&lt;img&gt;</code>元素类似,都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码,所以在请求完成后,即在JSONP响应加载到页面中以后,就会立即执行。来看一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">response</span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;You’re at IP address &quot;</span> + response.<span class="property">ip</span> + <span class="string">&quot;, which is in &quot;</span> +</span><br><span class="line">  response.<span class="property">city</span> + <span class="string">&quot;, &quot;</span> + response.<span class="property">region_name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;http://freegeoip.net/json/?callback=handleResponse&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br></pre></td></tr></table></figure><p>JSONP能够得到服务器的响应文本,但是加载了来自外域的js,安全性较低.</p><h1 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h1><p>通常叫做服务器推送,实时性非常高.实现Comet有2种方式长轮询和流.</p><p>长轮询是传统轮询(也称为短轮询)的一个翻版,段轮询是浏览器定时向服务器发送请求,看有没有更新的数据。如图所示:</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/short-pull.png" alt="短轮询"></p><p>长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求,然后服务器一直保持连接打开,直到有数据可发送。发送完数据之后,浏览器关闭连接,随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。如图所示:</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/long-pull.png" alt="长轮询"></p><p>无论是短轮询还是长轮询,浏览器都要在接收数据之前,先发起对服务器的连接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应,无论数据是否有效,而长轮询是等待发送响应。轮询的优势是所有浏览器都支持,因为使用XHR对象和&#96;setTimeout()&#96;&#96;就能实现。而你要做的就是决定什么时候发送请求。</p><p>第二种流行的Comet实现是HTTP流。流不同于上述两种轮询,因为它在页面的整个生命周期内只使用一个HTTP连接。具体来说,就是浏览器向服务器发送一个请求,而服务器保持连接打开,然后周期性地向浏览器发送数据。PHP中实现流的方式常见的如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="comment">//输出一些数据,然后立即刷新输出缓存</span></span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;Number is <span class="subst">$i</span>&quot;</span>;</span><br><span class="line">  <span class="title function_ invoke__">flush</span>();</span><br><span class="line">  <span class="comment">//等几秒钟</span></span><br><span class="line">  <span class="title function_ invoke__">sleep</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Firefox、Safari、Opera 和Chrome中,通过侦听<code>readystatechange</code>事件及检测<code>readyState</code>的值是否为3,就可以利用XHR对象实现 HTTP流。在上述这些浏览器中,随着不断从服务器接收数据, readyState的值会周期性地变为3。当readyState值变为3时,responseText属性中就会保存接收到的所有数据。此时,就需要比较此前接收到的数据,决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下所示。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createStreamingClient</span>(<span class="params">url, progress, finished</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(),</span><br><span class="line">        received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">//只取得最新数据并调整计数器</span></span><br><span class="line">            result = xhr.<span class="property">responseText</span>.<span class="title function_">substring</span>(received);</span><br><span class="line">            received += result.<span class="property">length</span>;</span><br><span class="line">            <span class="comment">//调用 progress 回调函数</span></span><br><span class="line">            <span class="title function_">progress</span>(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="title function_">finished</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> client = <span class="title function_">createStreamingClient</span>(<span class="string">&quot;streaming.php&quot;</span>, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Received: &quot;</span> + data);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h1><p>SSE(Server Sent Event),用于创建到服务器的单向连接,服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是<code>text/event-stream</code>,而且是浏览器中的<code>JavaScript API</code>能解析格式输出。SSE支持短轮询、长轮询和HTTP流,而且能在断开连接时自动确定何时重新连接。</p><h2 id="SSE-API"><a href="#SSE-API" class="headerlink" title="SSE API"></a>SSE API</h2><p>要预订新的事件流,首先要创建一个新的<code>EventSource</code>对象,并传进一个入口点.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;myevents.php&quot;</span>); <span class="comment">// 注意同源策略</span></span><br></pre></td></tr></table></figure><p>EventSource的实例有一个readyState属性,值为0表示正连接到服务器,值为1表示打开了连接,值为2表示关闭了连接。另外还提供了3个事件:</p><ul><li>open :在建立连接时触发。</li><li>message :在从服务器接收到新事件时触发。</li><li>error :在无法建立连接时触发。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">//处理数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器发回的数据以<strong>字符串</strong>形式保存在<code>event.data</code>中。默认情况下,EventSource对象会<em>保持与服务器的活动连接</em>。如果连接断开,还会<em>重连</em>。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接,可以调用<code>close()</code>方法。</p><h1 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h1><p>在JavaScript中创建了Web Socket之后,会有一个HTTP请求发送到服务器以发起连接。在取得服务器响应后,建立的连接会使用HTTP升级从HTTP协议交换为WebSocket 协议。需要注意的是:服务端必须支持web socket协议.<code>ws://</code>,<code>wss://</code>(加密).</p><blockquote><p>使用自定义协议而非HTTP协议的好处是,能够在客户端和服务器之间发送非常少量的数据,而不必担心HTTP那样字节级的开销。由于传递的数据包很小,因此Web Sockets非常适合移动应用。</p></blockquote><p>构造websocket必须给其构造函数传递绝对路径(可以是任意的url),不受同源策略影响(因为可通过握手知道信息来自何方).实例化了WebSocket对象后,浏览器就会马上尝试创建连接。和XHR类似,它也有一个<code>readyState</code>属性:</p><ul><li>WebSocket.OPENING (0):正在建立连接。</li><li>WebSocket.OPEN (1):已经建立连接。</li><li>WebSocket.CLOSING (2):正在关闭连接。</li><li>WebSocket.CLOSE (3):已经关闭连接。</li></ul><p>readyState的值永远从0开始。要关闭Web Socket连接,可以在任何时候调用<code>close()</code>方法,调用了close()之后, readyState的值立即变为2(正在关闭),而在关闭连接后就会变成3.</p><p>Web Sockets只能通过连接发送纯文本数据,所以对于复杂的数据结构,在通过连接发送之前,必须进行序列化。</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html5 canvas的基本操作</title>
      <link href="/2016/03/22/canvas/"/>
      <url>/2016/03/22/canvas/</url>
      
        <content type="html"><![CDATA[<h2 id="导出在canvas元素上绘制的图像"><a href="#导出在canvas元素上绘制的图像" class="headerlink" title="导出在canvas元素上绘制的图像"></a>导出在canvas元素上绘制的图像</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;drawing&#x27;</span>)</span><br><span class="line"><span class="comment">// 是否支持canvas</span></span><br><span class="line"><span class="keyword">if</span>(drawing.<span class="property">getContext</span>)&#123;</span><br><span class="line">  <span class="comment">// 取得图像数据URI</span></span><br><span class="line">  <span class="keyword">var</span> imgURI = drawing.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">  <span class="comment">// 显示图像</span></span><br><span class="line">  <span class="keyword">var</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">  img.<span class="property">src</span> = imgURI</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文本的度量"><a href="#文本的度量" class="headerlink" title="文本的度量"></a>文本的度量</h2><p>由于绘制文本比较复杂,特别是需要把文本控制在某一区域内部的时候,canvas提供了<code>measureText()</code>,该方法接收一个参数,即:需要绘制的文本,返回一个<code>TextMetrics</code>对象,该对象有一个<code>width</code>属性.假设我们想要在140像素宽的矩形区域中绘制文本”hello world”,我们可以从100px字体大小开始递减,最终找到合适的字体大小.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fontSize = <span class="number">100</span></span><br><span class="line">context.<span class="property">fontSize</span> = fontSize + <span class="string">&#x27;px Arial&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(context.<span class="title function_">measureText</span>(<span class="string">&#x27;hello world&#x27;</span>).<span class="property">width</span> &gt; <span class="number">140</span>)&#123;</span><br><span class="line">  fontSize--</span><br><span class="line">  context.<span class="property">font</span> = fontSize + <span class="string">&#x27;px Arial&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&#x27;hello world&#x27;</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&#x27;Font size is &#x27;</span> + fontSize + <span class="string">&#x27;px&#x27;</span>,<span class="number">10</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure><h2 id="状态的保存和还原"><a href="#状态的保存和还原" class="headerlink" title="状态的保存和还原"></a>状态的保存和还原</h2><p>我们说<code>canvas</code>是基于状态的,那么如何保存和还原状态呢?我们可以调用<code>save()</code>方法,当时所有的设置都会进入一个栈结构,可以对上下文进行其他的修改,当需要回到之前的设置(绘图上下文和变换)时,可以调用<code>restore()</code>在保存设置的栈结构中向前返回一级,恢复之前的状态.连续调用<code>save()</code>可以把更多的设置项保存到栈结构中,之后连续调用<code>restore()</code>可以逐级返回.</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
            <tag> javascript </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表单的常见操作</title>
      <link href="/2016/03/22/form/"/>
      <url>/2016/03/22/form/</url>
      
        <content type="html"><![CDATA[<h1 id="如何防止重复提交表单"><a href="#如何防止重复提交表单" class="headerlink" title="如何防止重复提交表单"></a>如何防止重复提交表单</h1><p>在金融消费等敏感领域,重复提交表单将会导致费用翻倍.最常见的解决方案就是在提交一次之后禁用提交按钮（当然后端接口也要进行严密判断）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>,<span class="keyword">function</span>(<span class="params">ev</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> target = ev.<span class="property">target</span></span><br><span class="line">  <span class="comment">// 取得提交按钮</span></span><br><span class="line">  <span class="keyword">var</span> submitBtn = target.<span class="property">elements</span>[<span class="string">&#x27;submitBtn&#x27;</span>] <span class="comment">// 通过name属性</span></span><br><span class="line">  <span class="comment">// disable it</span></span><br><span class="line">  submitBtn.<span class="property">disabled</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是:<em>不能通过onclick</em>来实现,因为不同浏览器之间存在”时差”,换言之:<code>onlick</code>和<code>submit</code>的触发顺序是不确定的.</p><blockquote><p>html5为表单新增了<code>autofocus</code>属性,表单字段将自动得到焦点.</p></blockquote><h1 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h1><h2 id="过滤字符"><a href="#过滤字符" class="headerlink" title="过滤字符"></a>过滤字符</h2><p>考虑这样一种需求:电话号码中不能包含非数字字符.因此我们需要监听<code>keypress</code>事件,并阻止其默认行为,极端情况下可以屏蔽所有的按键操作.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keypress&#x27;</span>,<span class="keyword">function</span>(<span class="params">ev</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> target = ev.<span class="property">target</span></span><br><span class="line">    <span class="keyword">var</span> charCode = ev.<span class="property">charCode</span></span><br><span class="line">    <span class="comment">// 字符编码转字符串,保证不阻止基本键</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="regexp">/\d/</span>.<span class="title function_">test</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(charCode)) &amp;&amp; charCode &gt; <span class="number">9</span> &amp;&amp; !ev.<span class="property">ctrlKey</span>)</span><br><span class="line">      ev.<span class="title function_">preventDefault</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="操作剪切板"><a href="#操作剪切板" class="headerlink" title="操作剪切板"></a>操作剪切板</h3><p>提供以下的6个事件:</p><ul><li>beforecopy</li><li>copy</li><li>beforecut</li><li>cut</li><li>beforepaste</li><li>paste</li></ul><p>注意,通过beforeXXX可以在XXX事件之前向剪切板发送或者取得剪切板中的数据之前修改数据,取消beforeXXX方法并不会取消对剪切板的操作,只有取消copy,cut,paste事件才能阻止相应操作发生.</p><p>取得剪切板中的数据可以使用<code>clipboardData</code>对象,在IE中它是window的属性,而其他浏览器中它是对应event对象的属性.该对象有3个方法:<code>setData()</code>,<code>getData()</code>和<code>clearData()</code>.</p><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><p>例如我们常见的软件的激活码,当输入特定字符后光标会自动切换到下一个输入框,极大强化了用户体验.我们可以通过以下的方法来模拟:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel1&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel2&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel3&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">tabForward</span>(<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> target = ev.<span class="property">target</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span>(target.<span class="property">value</span>.<span class="property">length</span> === target.<span class="property">maxLength</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> form = target.<span class="property">form</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,len = form.<span class="property">elements</span>.<span class="property">length</span>;i &lt; len;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(form.<span class="property">elements</span>[i] === target)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 找到下一个表单字段,并获得焦点</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(form.<span class="property">elements</span>[i+<span class="number">1</span>])&#123;</span></span><br><span class="line"><span class="language-javascript">              form.<span class="property">elements</span>[i+<span class="number">1</span>].<span class="title function_">focus</span>()</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> txt1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tel1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> txt2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tel2&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> txt3 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tel3&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    txt1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,tabForward)</span></span><br><span class="line"><span class="language-javascript">    txt2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,tabForward)</span></span><br><span class="line"><span class="language-javascript">    txt3.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,tabForward)</span></span><br><span class="line"><span class="language-javascript">  &#125;())</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h1><p>首先思考这样一个问题:浏览器怎样将数据发送给服务器?</p><ul><li>对表单字段的key和value进行url编码,使用<code>&amp;</code>分隔</li><li>不发送禁用的表单字段</li><li>只发送勾选的的复选框和单选按钮</li><li>不发送type为reset和button的按钮</li><li>多选选择框中的每个选中的值单独一个条目</li><li>在单击提交按钮提交表单的情况下,也会发送提交按钮;否则,不发送提交按钮</li><li><code>&lt;select&gt;</code>元素的值,就是选中的<code>&lt;option&gt;</code>元素的<code>value</code>特性的值。如果<code>&lt;option&gt;</code>元素没有<code>value</code>特性,则是&#96;<option>&#96;&#96;元素的文本值。</li></ul><p>以下是序列化函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">serialize</span>(<span class="params">form</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> parts = [],</span><br><span class="line">      field = <span class="literal">null</span>,</span><br><span class="line">      i,</span><br><span class="line">      len,</span><br><span class="line">      j,</span><br><span class="line">      optLen,</span><br><span class="line">      option,</span><br><span class="line">      optValue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>,len = form.<span class="property">elements</span>.<span class="property">length</span>;i &lt; len;i++)&#123;</span><br><span class="line">        field = form.<span class="property">elements</span>[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(field.<span class="property">type</span>)&#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;select-one&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;select-multiple&#x27;</span>:</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(field.<span class="property">name</span>.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>,optLen = field.<span class="property">options</span>.<span class="property">length</span>;j &lt; optLen;j++)&#123;</span><br><span class="line">              option = field.<span class="property">options</span>[j]</span><br><span class="line">              <span class="keyword">if</span>(option.<span class="property">selected</span>)&#123;</span><br><span class="line">                optValue = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(option.<span class="property">hasAttribute</span>)&#123;</span><br><span class="line">                  optValue = (option.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;value&#x27;</span>) ? option.<span class="property">value</span> : option.<span class="property">text</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  optValue = (option.<span class="property">attributes</span>[<span class="string">&#x27;value&#x27;</span>.<span class="property">specified</span>] ? option.<span class="property">value</span> : option.<span class="property">text</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                parts.<span class="title function_">push</span>(<span class="title function_">encodeURICompenent</span>(field.<span class="property">name</span>) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(optValue))</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="attr">undefined</span>: <span class="comment">// 字段集</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;submit&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;reset&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;button&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;radio&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;checkbox&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(!field.<span class="property">checked</span>)</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          <span class="attr">default</span>:</span><br><span class="line">            <span class="comment">// 不包含没有名字的表单字段</span></span><br><span class="line">            <span class="keyword">if</span>(field.<span class="property">name</span>.<span class="property">length</span>)&#123;</span><br><span class="line">              parts.<span class="title function_">push</span>(<span class="built_in">encodeURIComponent</span>(field.<span class="property">name</span>) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(field.<span class="property">value</span>))</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> parts.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h3><p>WYSIWYG(what you see is what you get),所见即所得.本质是在页面中嵌入一个包含空html页面的<code>iframe</code>,通过设置<code>designMode</code>属性,这个空白html可以被编辑,而编辑对象则是该页面的<code>&lt;body&gt;</code>元素的html代码;另外的一种实现是将元素设置为<code>contenteditable</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 与事件</title>
      <link href="/2016/03/19/event/"/>
      <url>/2016/03/19/event/</url>
      
        <content type="html"><![CDATA[<blockquote><p>js 和 html 之间的交互是通<em>事件</em>实现的。事件就是文档或者浏览器窗口中发生的一些特定的瞬间。我们可以使用<strong>侦听器</strong>来预定事件，以便事件发生时执行相应的代码。传统的软件工程中称为<a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html">观察者模式</a>，使得行为(js)和外观(html 和 css)松散耦合。</p></blockquote><h1 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h1><p>注意：没有 DOM1 事件流的概念。</p><p>“DOM2级事件”规定事件流包括 3 个阶段:</p><ol><li>事件捕获(默认不启用, 需要显式设置 <code>capture: true</code>)</li><li>处于目标</li><li>事件冒泡</li></ol><p>以下面的 DOM 结构为例:</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/event-stream.png" alt="事件流"></p><p>单击 <code>div</code> 元素事件是先是从 Document -&gt; Div 的捕获阶段，然后是 Div -&gt; Document 的冒泡阶段。</p><h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;show();&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Q:上述的时间处理程序有什么缺点?<br>A:缺点有2个。①可能存在时差问题：考虑这样一种情形，show函数定义在按钮的后面,当DOM还没有加载到<code>script</code>标签的时候将会发生错误,此种情形可以通过内部添加<code>try-catch</code>来解决:<code>&lt;button onclick=&quot;try&#123;show();&#125;catch(ex)&#123;&#125;&quot;&gt;</code>;②拓展事件处理程序的作用链将会是浏览器不兼容的。</p><h2 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h2><p>该种方式将一个函数赋值给一个事件处理程序的属性,比较简单,兼容性好,例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>,<span class="variable language_">this</span>.<span class="property">id</span>); <span class="comment">// clicked btn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 DOM0 级方法指定的时间处理程序被认为是<strong>元素的方法</strong>。这个时候的事件处理程序是在元素作用域中运行(this指向当前元素)。以这种方式添加的事件处理程序会在<em>事件流的冒泡阶段</em>被处理，删除事件处理程序只需要将事件处理程序的属性设置为<code>null</code>,例如:<code>btn.onclick = null</code>.</p><h2 id="DOM2-级事件处理程序"><a href="#DOM2-级事件处理程序" class="headerlink" title="DOM2 级事件处理程序"></a>DOM2 级事件处理程序</h2><p>定义了 2 个方法 <code>addEventListener()</code> 和 <code>removeEventListener()</code> 用于指定或者删除事件处理程序。都接收 3 个参数:事件名，事件处理函数和布尔值(true,捕获阶段调用事件处理函数;false,冒泡阶段调用事件处理函数,缺省为 false)。这种方式可以弥补了 DOM0 中不能添加多个事件处理函数的不足。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p>以上为 btn 添加了 2 个事件处理程序，这 2 个程序会按照它们的添加它们顺序触发。</p><h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>IE9之前的版本支持<code>attachEvent()</code>和<code>detachEvent()</code>,接收事件名(注意”on”)和事件处理函数,只支持在冒泡阶段处理,和DOM0级事件的区别在于<code>attachEvent()</code>在<em>全局作用域</em>中运行,因此<code>window === this</code>,<code>attachEvent</code>也可以绑定多个事件,但是触发的顺序是<em>与添加的时候相反的</em>.</p><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p>兼容DOM的对象会将一个<code>event</code>对象传入到事件处理程序中(无论是DOM0还是DOM2),事件处理程序执行完后,<code>event</code>对象将被销毁;IE中的事件对象是<code>window.event</code>.在事件处理程序内部<code>this === currentTarget</code>,而<code>target</code>则表示的是事件的实际目标,我们来看下面的一个例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// body</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">currentTarget</span>); <span class="comment">// body</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>); <span class="comment">// button#btn</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>this</code>和<code>currentTarget</code>都是body元素,因为事件是注册到body上的,而<code>target</code>却是按钮,因为它是事件的真是目标(最具体的元素).由于按钮上并没有注册处理程序,click事件就冒泡到了<code>document.body</code>并在那里得到处理.(在上面的例子中我们可以使用<code>e.stopProgation()</code>从而禁止事件传播)</p></blockquote><blockquote><p>其实,恰当使用能力检测就可以写出兼容代码,详见<a href="https://github.com/consoles/front-end/blob/master/DOMEvent/js/event.js">event.js</a></p></blockquote><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><h2 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h2><p>UI事件指的是那些不一定与用户操作有关的事件.</p><ul><li>load:页面完全加载完成后在window上触发;当所有框架内容加载完毕后在框架集上触发;图像加载完成后在<code>&lt;img&gt;</code>元素上触发;嵌入内容加载完毕后在<code>&lt;object&gt;</code>元素上触发</li><li>abort:用户停止下载过程时;如果嵌入的内容没有加载完,则在<code>&lt;object&gt;</code>元素上触发</li><li>error:js错误时在window上触发;图像无法加载时在<code>&lt;img&gt;</code>上触发;无法加载内容时在<code>&lt;object&gt;</code>上触发;一个或者多个框架无法加载时在框架集上触发</li></ul><blockquote><p>根据“DOM2 级事件”规范,应该在<code>document</code>而非<code>window</code>上面触发<code>load</code>事件。但是,所有浏览器都在<code>window</code>上面实现了该事件,以确保向后兼容,例如我们经常用的<code>window.onload</code>.</p></blockquote><h2 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h2><ul><li>focus,元素获取焦点时触发.但是该事件<em>不会冒泡</em>.</li><li>blur,元素失去焦点触发,不会冒泡</li><li>focusin,元素获取焦点时触发,与html事件focus等价,但冒泡.</li><li>focusout,元素失去焦点时触发,是html事件blur的通用版本.</li></ul><p>当焦点从页面中的一个元素移动到另外一个元素,会依次触发下列事件:</p><ol><li>focusout在失去焦点的元素上触发</li><li>focusin在获得焦点的元素上触发</li><li>blur在失去焦点的元素上触发</li><li>focus在获得焦点的元素上触发</li></ol><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>添加太多的事件处理程序会带来性能问题(函数是对象,对象就要占内存),解决方案就是采用<em>事件委托</em>。事件委托利用了事件冒泡，只指定一个事件处理程序就可以管理某一类型的所有事件。例如 <code>click</code> 事件会一直冒泡到 <code>document</code>，也就是说<strong>我们可以为整个页面添加一个 <code>onclick</code> 事件处理程序而不必为每个元素添加事件处理程序</strong>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li1&quot;</span>&gt;</span>li1 content<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li2&quot;</span>&gt;</span>li2 content<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li3&quot;</span>&gt;</span>li3 content<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li4&quot;</span>&gt;</span>li4 content<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li5&quot;</span>&gt;</span>li5 content<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">ev</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> target = ev.<span class="property">target</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">switch</span> (target.<span class="property">id</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol><li>pointermove 统一了 mousemove（鼠标） 和 touchmove（触摸屏）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 中的元素大小</title>
      <link href="/2016/03/19/elements-size/"/>
      <url>/2016/03/19/elements-size/</url>
      
        <content type="html"><![CDATA[<h1 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h1><p>offset dimension包括元素在屏幕上占用的所见空间的大小．元素的可见大小由宽高，内边距，滚动条和边框确定，注意：<em>不包含外边距．</em></p><p>如图所示：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/offest.png" alt="offset　dimension"></p><p><code>offsetLeft</code>和<code>offsetTop</code>属性与包含元素有关,包含元素的引用保存在<code>offsetParent</code>属性中。<code>offsetParent</code>属性不一定与<code>parentNode</code>的值相等。例如,<code>&lt;td&gt;</code>元素的<code>offsetParent</code>是作为其祖先元素的<code>&lt;table&gt;</code>元素,因为<code>&lt;table&gt;</code>是在DOM层次中距<code>&lt;td&gt;</code>最近的一个<em>具有大小</em>的元素。</p><p>要想取得某个元素在<strong>页面上的偏移量</strong>，就可以将这个元素的<code>offsetLeft</code>和<code>offsetParent.offsetLeft</code>相加，如此循环直到根元素就可以得到一个基本准确的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementLeft</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> actualLeft = element.<span class="property">offsetLeft</span>;</span><br><span class="line">  <span class="keyword">var</span> current = element.<span class="property">offsetParent</span>;</span><br><span class="line">  <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      actualLeft += current.<span class="property">offsetLeft</span>;</span><br><span class="line">      current = current.<span class="property">offsetParent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h1><p>client dimension，指的是元素内容及其内边距所占据的空间大小．它有２个属性<code>clientWidth</code>和<code>clientHeight</code>．如下所示：</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/client-dimension.png" alt="client-dimension"></p><p>从字面意思来讲：客户区大小就是元素内部的空间大小，因此滚动条占用的空间不计算在内．最常用的情况是确定浏览器视口大小．</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getViewport</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// IE 7之前的混杂模式，现代浏览器一般支持的是标准模式</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;BackCompat&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>,</span><br><span class="line">      <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">      <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h1><p>scroll dimension,包含滚动内容的元素的大小．有些元素（例如<code>&lt;html&gt;</code>元素）即使在没有执行任何代码的时候也能自动添加滚动条；另外一些元素，则需要通过CSS的<code>overflow</code>属性进行设置才能滚动．</p><ul><li>scrollHeight:在没有滚动条的情况下，元素内容的总高度</li><li>scrollWidth:在没有滚动条的情况下，元素内容总宽度</li><li>scrollTop:被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</li><li>scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置</li></ul><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/scroll-dimension.png" alt="scroll-dimension"></p><p>由于浏览器的兼容性，在取得页面的总高度时必须取得<code>scrollHeight</code>和<code>clientHeight</code>中的最大值才能保证精确的结果，举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docHeight = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span>,<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>);</span><br></pre></td></tr></table></figure><p>*注意：*以上的代码在IE混杂模式下用<code>document.body</code>代替<code>document.documentElement</code>．</p><p>通过<code>document.body.scrollTop</code>属性我们可以实现＊回到顶部＊效果,将其值设置为０即可．</p><p><em>总结：</em><br>－　每个元素都有关联一个<code>style</code>对象，用来确定和修改行内样式．<br>－　要确定某个元素的计算样式（非内联样式），可以使用<code>getComputedStyle()</code>方法，对于IE可以使用<code>currentStyle</code>属性<br>－　可以通过<code>document.styleSheets</code>集合获取样式表．</p><h1 id="obj-style-width和obj-offsetWidth的区别"><a href="#obj-style-width和obj-offsetWidth的区别" class="headerlink" title="obj.style.width和obj.offsetWidth的区别"></a><code>obj.style.width</code>和<code>obj.offsetWidth</code>的区别</h1><p>style用于取得内联样式,<code>offsetWidth</code>取得渲染出来的宽度(包括边框和内边距),前者可读写,后者只读,前者带有单位<code>px</code>,后者不带单位.</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大话机器学习</title>
      <link href="/2014/09/10/machine-learning/"/>
      <url>/2014/09/10/machine-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>感知器：比较预测值和真实值之间的偏差，逐渐调整参数，使得模型拟合。每次调整的步长称为学习率。<br>支持向量机：二分类问题画一条直线使得两个分类之间的间隔最大。因为点距离直线越远模型的可信度越高。相机中的人脸识别是二分类问题。<br>卷积操作常用于图像特征的提取。将一个小矩阵和图像特征矩阵进行卷积运算可以得到一个新的矩阵，新的矩阵可以看做是一个新的图像，比原图像更清楚表达了某些性质，因此可以看做是图像的一个特征（从这一点看卷积操作有点类似于PCA，主成分分析）</p><h1 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h1><p>利用计算机从历史数据中找出规律，并将这些规律用到对未来的<em>不确定场景</em>的决策（例如预测下个季度公司的业绩销量）。</p><h1 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h1><ul><li>关联规则。<a href="http://blog.renren.com/share/295398799/13844396513">啤酒加尿布</a>,这种就叫做购<strong>物篮分析</strong>（看看哪些商品是被同时购买的），用到的算法是关联规则。</li><li>聚类。用户细分，精准营销。例如中国移动分为全球通（商务人士）、动感地带（学生，信息流量较多）、神州行（普通务工人员，电话较多）。</li><li>朴素贝叶斯和决策树。朴素贝叶斯例如垃圾邮件，决策树例如信用卡欺诈，骗贷.人脸识别用了AdaBoost算法（决策树）。</li><li>CTR和协同过滤。例如百度搜索的百度推广的顺序是进行了预估，最可能被点击的放在第一条。商品推荐系统使用了协同过滤。</li><li>自然语言处理。情感分析和实体识别。</li><li>深度学习。例如图像识别。</li></ul><h1 id="LLM"><a href="#LLM" class="headerlink" title="LLM"></a>LLM</h1><p>AGI 是 AI 的终极形态，几乎已经成为业界共识。构建智能体 Agent 则是 AI 工程应用当下的“终极形态”。大模型出现之后，AI Agent 衍生出了一种全新的架构模式，将最重要的规划、决策部分或者全部交给 LLM 完成。</p><p>智能体式具有自主性和智能的程序或者系统，能感知、规划、决策并执行相关任务。</p><p><img src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ai-agent.png" alt="AI Agent 的执行流程"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>LoRA：插件式微调，用于对 LLM 进行个性化的特殊任务的定制。例如 AI 绘画领域的 SD 微调。通过将模型的权重矩阵分解成低秩的相似矩阵，降低了参数空间的复杂性，从而减少微调的计算成本和模型存储要求。</p><p>向量数据库：存储和管理大量的矢量数据（非结构化），例如：图像、视频、音频、文本等，同时提供高效的检索功能。</p><p>ReAct Agent：是一种结合推理（Reasoning）和行动（Action）的智能体（Agent）框架，旨在让大语言模型（LLM）更高效地完成复杂任务。它通过动态推理和外部工具调用来增强模型的决策能力，适用于问答、工具调用、多步任务规划等场景。</p><h2 id="结合大模型的新一代应用的交互方式"><a href="#结合大模型的新一代应用的交互方式" class="headerlink" title="结合大模型的新一代应用的交互方式"></a>结合大模型的新一代应用的交互方式</h2><ul><li>Embedding：AI 是执行工具，人类是决策者和指挥者。例如创作小说、音乐。</li><li>Copilot：AI 提供建议并协助任务，二者互补，AI 更像知识丰富的伙伴而非工具。例如 Github Copilot。</li><li>Agent：人类设定目标并提供资源，AI 独立完成大部分工作，最后人类监督和评估结果。例如：AutoGPT，Manus。</li></ul><h2 id="在企业中的应用场景"><a href="#在企业中的应用场景" class="headerlink" title="在企业中的应用场景"></a>在企业中的应用场景</h2><ul><li>智能客服（LLM + 企业知识库）</li><li>基于 Agent&#x2F;LLM 的数据分析（非结构化数据，难以用传统方式编程建模）</li></ul><h2 id="Prompt-优化技巧"><a href="#Prompt-优化技巧" class="headerlink" title="Prompt 优化技巧"></a>Prompt 优化技巧</h2><ol><li>明确角色：例如“你是一位 java 程序员”</li><li>提供细节要求：例如“写一篇 200 字的总结，突出专业性”</li><li>任务拆解：例如“先需求分析，再技术选型，最后编码实现，并生成项目总结”</li><li>提供示例：例如“模仿李白的《静夜思》，创作一首表达思乡之情的五言诗歌”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
