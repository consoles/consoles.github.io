<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>有趣的算法 | 雨碎江南</title><meta name="author" content="consoles"><meta name="copyright" content="consoles"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="爬虫底层的算法是广度优先搜索。  二项分布和递归问题来源于算法第四版问题1.1.27。 12345678910111213141516let count &#x3D; 0;const binomial &#x3D; (N, k, p) &#x3D;&gt; &#123;    count++;    if (count % 10000000 &#x3D;&#x3D;&#x3D; 0) console.log(count);    &#x2F;&#x2F; 因为每次递归都是N">
<meta property="og:type" content="article">
<meta property="og:title" content="有趣的算法">
<meta property="og:url" content="https://consoles.fun/2018/12/26/awesome-alg/index.html">
<meta property="og:site_name" content="雨碎江南">
<meta property="og:description" content="爬虫底层的算法是广度优先搜索。  二项分布和递归问题来源于算法第四版问题1.1.27。 12345678910111213141516let count &#x3D; 0;const binomial &#x3D; (N, k, p) &#x3D;&gt; &#123;    count++;    if (count % 10000000 &#x3D;&#x3D;&#x3D; 0) console.log(count);    &#x2F;&#x2F; 因为每次递归都是N">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://consoles.fun/img/butterfly-icon.png">
<meta property="article:published_time" content="2018-12-26T15:15:42.000Z">
<meta property="article:modified_time" content="2025-04-02T16:31:20.000Z">
<meta property="article:author" content="consoles">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数学归纳法">
<meta property="article:tag" content="概率论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://consoles.fun/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "有趣的算法",
  "url": "https://consoles.fun/2018/12/26/awesome-alg/",
  "image": "https://consoles.fun/img/butterfly-icon.png",
  "datePublished": "2018-12-26T15:15:42.000Z",
  "dateModified": "2025-04-02T16:31:20.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "consoles",
      "url": "https://consoles.fun/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://consoles.fun/2018/12/26/awesome-alg/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '有趣的算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">雨碎江南</span></a><a class="nav-page-title" href="/"><span class="site-name">有趣的算法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">有趣的算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-26T15:15:42.000Z" title="发表于 2018-12-26 15:15:42">2018-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-02T16:31:20.000Z" title="更新于 2025-04-02 16:31:20">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<p>爬虫底层的算法是广度优先搜索。</p>
</blockquote>
<h1 id="二项分布和递归"><a href="#二项分布和递归" class="headerlink" title="二项分布和递归"></a>二项分布和递归</h1><p>问题来源于算法第四版问题1.1.27。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binomial</span> = (<span class="params">N, k, p</span>) =&gt; &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count % <span class="number">10000000</span> === <span class="number">0</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    <span class="comment">// 因为每次递归都是N-1，并且k-1，因此这种情况很难出现</span></span><br><span class="line">    <span class="keyword">if</span> (N === <span class="number">0</span> &amp;&amp; k === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最终应该会调用这个if</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - p) * <span class="title function_">binomial</span>(N - <span class="number">1</span>, k, p) + p * <span class="title function_">binomial</span>(N - <span class="number">1</span>, k - <span class="number">1</span>, p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5分钟算不出来，舍弃</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;二项分布-递归&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">binomial</span>(<span class="number">10</span>, <span class="number">50</span>, <span class="number">.25</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;二项分布-递归&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br></pre></td></tr></table></figure>

<p>估计上面函数的调用次数。</p>
<h2 id="伯努利试验（独立重复试验）"><a href="#伯努利试验（独立重复试验）" class="headerlink" title="伯努利试验（独立重复试验）"></a>伯努利试验（独立重复试验）</h2><blockquote>
<p>伯努利试验（Bernoulli experiment）是在同样的条件下重复地、相互独立地进行的一种随机试验，其特点是该随机试验只有两种可能结果：发生或者不发生。我们假设该项试验独立重复地进行了 n 次，那么就称这一系列重复独立的随机试验为 n 重伯努利试验，或称为伯努利概型。单个伯努利试验是没有多大意义的，然而，当我们反复进行伯努利试验，去观察这些试验有多少是成功的，多少是失败的，事情就变得有意义了，这些累计记录包含了很多潜在的非常有用的信息。</p>
</blockquote>
<p>设在一次试验中，事件 A 发生的概率为 p(0 &lt; p &lt; 1)，则在 n 重伯努利试验中，事件 A恰好发生 k 次的概率为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/binomial.png" alt="伯努利试验"></p>
<p>试了一下，直接将 N 传入100，5 分钟算不出来，舍弃。将 n 从 10 开始到大规模开始测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">N k time count</span><br><span class="line">10 5 0.280ms 2467</span><br><span class="line">20 10 25.045ms 2433071</span><br><span class="line">30 15 24871.999ms 2438328997</span><br></pre></td></tr></table></figure>

<p>当 N 到 30 的时候发现速度已经非常慢了，基本上是几何级数增长。</p>
<p>改进的算法，使用容器缓存已经计算过的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binomial2</span> = (<span class="params">N, k, p</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">`<span class="subst">$&#123;N&#125;</span>-<span class="subst">$&#123;k&#125;</span>`</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (cache[key] !== <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> cache[key];</span><br><span class="line">    <span class="keyword">if</span> (N === <span class="number">0</span> &amp;&amp; k === <span class="number">0</span>) <span class="keyword">return</span> cache[key] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> cache[key] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cache[key] = (<span class="number">1</span> - p) * <span class="title function_">binomial2</span>(N - <span class="number">1</span>, k, p) + p * <span class="title function_">binomial2</span>(N - <span class="number">1</span>, k - <span class="number">1</span>, p);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>传入参数 100 和 50，调用次数为 7751，耗时 4.903ms。</p>
<h1 id="欧几里得算法及其证明"><a href="#欧几里得算法及其证明" class="headerlink" title="欧几里得算法及其证明"></a>欧几里得算法及其证明</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gcd</span> = (<span class="params">p, q</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">const</span> r = p % q;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">gcd</span>(q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">gcd2</span> = (<span class="params">p, q</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (q !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = p % q;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>欧几里德的算法关键在于证明等式gcd(a,b)&#x3D;gcd(b,a mod b)的正确性。</p>
<p>定理：a，b为正整数，则gcd(a,b)&#x3D;gcd(b,a mod b)<br>证明：</p>
<p>k,r为整数，设r &#x3D; a mod b,则a可以表示成a&#x3D;kb+r。</p>
<p>假设d是{a,b}的一个公约数，<br>则 </p>
<p>a &#x3D; md<br>b &#x3D; nd</p>
<p>r &#x3D; a - kb &#x3D; md - knd &#x3D; (m - kn)d</p>
<p>则d整除r，即d也是b和r的公约数</p>
<p>同理，假设d是{b,r}的一个公约数，则d整除b,d整除r，因此d整除a, d也是a和b的公约数。</p>
<p>因此{a,b}和{b,r}的公因子集合是一样的。特别地，{a,b}的最大共因子和{b,r}的最大公因子是一样的，即gcd(a,b)&#x3D;gcd(b,a mod b)。</p>
<h1 id="字符串的回环变位"><a href="#字符串的回环变位" class="headerlink" title="字符串的回环变位"></a>字符串的回环变位</h1><p>算法1.2.6。如果字符串 s 中的字符循环移动任意位置之后能够得到另一个字符串 t，那么 s 就被称为 t 的回环变位（circular rotation）。例如，ACTGACG就是TGACGAC的一个回环变位，反之亦然。判定这个条件在基因组序列的研究中是很重要的。编写一个程序检查两个给定的字符串 s 和 t 是否互为回环变位。提示：答案只需要一行用到indexOf() ，length() 和字符串连接的代码。</p>
<p>思路1：将字符串分成左右2部分，检查左右两边字符串互换之后可否得到原来的字符串<br>思路2：模拟回环变位的过程，不断将字符串的首字符移动到字符串末尾<br>思路3：比较巧妙。将原字符串重复2次，相当于字符串首尾相连了，然后判断字符串是否是这个首尾相连的字符串的子串。这个解法简直酷毙了！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">s, t</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> left = s.<span class="title function_">substring</span>(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">const</span> right = s.<span class="title function_">substring</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (right + left === t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">s, t</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s === t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.<span class="title function_">substring</span>(<span class="number">1</span>) + s.<span class="title function_">charAt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn3</span> = (<span class="params">s, t</span>) =&gt; s.<span class="property">length</span> === t.<span class="property">length</span> &amp;&amp; s.<span class="title function_">repeat</span>(<span class="number">2</span>).<span class="title function_">includes</span>(t);</span><br></pre></td></tr></table></figure>

<h1 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h1><p>下面的代码中平均数和方差的计算采用了每向累加器中添加一个数后根据已有的方差和标准差实时计算，而不是要取值的时候，求和、求均值，然后求平方和，求方差，思路比较清奇。这种方式和直接对所有数据平方求和的方式相比较能够很好避免四舍五入带来的误差。记录如下，证明过程参见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59252399">知乎</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">s</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">n</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addDataValue</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = ++<span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">        <span class="keyword">const</span> m = <span class="variable language_">this</span>.<span class="property">m</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">s</span> = <span class="variable language_">this</span>.<span class="property">s</span> + (n - <span class="number">1</span>) / n * (x - m) * (x - m);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = m + (x - m) / n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">mean</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">var</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">s</span> / (<span class="variable language_">this</span>.<span class="property">n</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">stddev</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="variable language_">this</span>.<span class="property">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="洗牌算法的正确性证明"><a href="#洗牌算法的正确性证明" class="headerlink" title="洗牌算法的正确性证明"></a>洗牌算法的正确性证明</h1><p>洗牌也就是排列，把这n张牌任意排列，总共有n!种。为了保证随机，那么我的洗牌策略，不管怎么洗，都应该是1&#x2F;n!。</p>
<p>Fisher–Yates shuffle算法的正确性：</p>
<p>第一张牌抽取的概率为1&#x2F;n,第二张牌是1&#x2F;(n-1),….，第i张牌概率是1&#x2F;(n-i),..。那么这种洗牌策略的概率是1&#x2F;n*1&#x2F;(n-1)<em>1&#x2F;(n-2)</em>…*1&#x2F;1，即1&#x2F;n!</p>
<p>下面这种经常被写错的算法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">worseShuffle</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> r = _.<span class="title function_">random</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        [arr[i], arr[r]] = [arr[r], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">        [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种算法相当于放回取样，概率为 1 &#x2F; n ^ n,并不能保证真正的公平。</p>
<h1 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h1><p>为什么数组缩容的的时候检测条件是是否已经占用了1&#x2F;4的空间将其调整为1&#x2F;2的空间而不是检测1&#x2F;2的空间将其调整为1&#x2F;2的空间。</p>
<p>假设动态数组的size为1&#x2F;2的capacity，当取出一个元素的时候容量变为1&#x2F;2 capacity，再放入一个元素的时候数组满了，接着再放一个元素的时候容量不够会触发扩容，接着取出2个元素会触发缩容。即如果检测条件为1&#x2F;2会频繁触发数组的扩容和缩容，开销太大。检测条件为1&#x2F;2则多了很大一部分缓冲，在这个实现中数组最多有3&#x2F;4的空间浪费。</p>
<h1 id="出栈顺序和卡塔兰数"><a href="#出栈顺序和卡塔兰数" class="headerlink" title="出栈顺序和卡塔兰数"></a>出栈顺序和卡塔兰数</h1><p>算法4习题1.3.3。假设某个用例程序会进行一系列入栈和出栈操作。入栈操作会将整数0到9按顺序压入栈；出栈操作会打印返回值。下面哪种顺序是不可能产生的？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a)  4 3 2 1 0 9 8 7 6 5</span><br><span class="line">(b)  4 6 8 7 5 3 2 9 0 1</span><br><span class="line">(c)  2 5 6 7 4 8 9 3 1 0</span><br><span class="line">(d)  4 3 2 1 0 5 6 7 8 9</span><br><span class="line">(e)  1 2 3 4 5 6 9 8 7 0</span><br><span class="line">(f)  0 4 6 5 3 8 1 7 2 9</span><br><span class="line">(g)  1 4 7 9 8 6 5 3 0 2</span><br><span class="line">(h)  2 1 4 3 6 5 8 7 9 0</span><br></pre></td></tr></table></figure>

<p>分析3个数时的入栈与出栈操作，所有的顺序有3!种。分别为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<p>可以知道只有 3 1 2 这种顺序不可能的，将其推广就可以得到这种的规律:”大 小 中”这种顺序是不能出现的。如上述中(b)中的9 0 1，(f)中的8 1 7，(g)中的3 0 2。所以b, f, g是不能产生的。</p>
<blockquote>
<p>算法1.3.46中给出一个结论。如果有三元组(a,b,c)满足a &lt; b &lt; c，弹出相对顺序为c,a,b(c,a,b之间可以间隔其他整数)。当且仅当不存在这样的三元组的时候栈才可以生成它。</p>
</blockquote>
<blockquote>
<p>解答：反证法。假设c会在a和b之前被弹出，但a和b会在c之前被压入。因此，当c被压入的时候，a和b已经在栈中了，所以a不可能在b之前被弹出。</p>
</blockquote>
<p>①对于出栈序列中的每一个数字，在它后面的、比它小的所有数字，一定是按递减顺序排列的。</p>
<p>比如入栈顺序为：1 2 3 4。</p>
<p>出栈顺序：4 3 2 1是合法的，对于数字 4 而言，比它小的后面的数字是：3 2 1，且这个顺序是递减顺序。同样地，对于数字 3 而言，比它小的后面的数字是： 2 1，且这个顺序是递减的。….</p>
<p>出栈顺序：1 2 3 4 也是合法的，对于数字 1 而言，它后面没有比它更小的数字。同样地，对于数字 2 而言，它后面也没有比它更小的数字。</p>
<p>出栈顺序：3 2 4 1 也是合法的，对于数字 3 而言，它后面比 3 小的数字有： 2 1，这个顺序是递减的；对于数字 2 而言，它后面的比它 小的数字只有 1，也算符合递减顺序；对于数字 4 而言，它后面的比它小的数字也只有1，因此也符合递减顺序。</p>
<p>出栈顺序：3 1 4 2 是不合法的，因为对于数字 3 而言，在3后面的比3小的数字有：1 2，这个顺序是一个递增的顺序(1–&gt;2)。</p>
<p>因此，当给定一个序列时，通过这个规律 可以轻松地判断 哪些序列是合法的，哪些序列是非法的。</p>
<p>②给定一个入栈顺序：1  2  3 …. n，一共有多少种合法的出栈顺序？参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/doc_sgl/article/details/8880468">卡特兰数</a></p>
<p>答案是 卡特兰数。即一共有：h(n)&#x3D;c(2n,n)&#x2F;(n+1) 种合法的出栈顺序。</p>
<p>方法1：模拟入栈和出栈的过程。终止条件是所有元素已经入栈，并且栈为空。对于每一步操作有2种，入栈和出栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getAllSeq</span> = nums =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part, stack</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len &amp;&amp; stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(part);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入栈</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="keyword">let</span> newStack = stack.<span class="title function_">concat</span>(nums[index]);</span><br><span class="line">            <span class="title function_">dfs</span>(index + <span class="number">1</span>, part, newStack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> top = stack[stack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">let</span> newStack = stack.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="title function_">dfs</span>(index, part.<span class="title function_">concat</span>(top), newStack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, [], []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">getAllSeq</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">arr</span> =&gt;</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);</span><br></pre></td></tr></table></figure>

<p>注意上述对栈的操作先进行了<em>保护性复制</em>，不需要对元素进行还原了,另一种比较容易出错的写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part, stack</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === len &amp;&amp; stack.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(part.<span class="title function_">slice</span>()); <span class="comment">// 保护性复制</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; len) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">        <span class="title function_">dfs</span>(index + <span class="number">1</span>, part, stack);</span><br><span class="line">        stack.<span class="title function_">pop</span>(); <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">if</span> (stack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> top = stack.<span class="title function_">pop</span>();</span><br><span class="line">        part.<span class="title function_">push</span>(top);</span><br><span class="line">        <span class="title function_">dfs</span>(index, part, stack);</span><br><span class="line">        stack.<span class="title function_">push</span>(top); <span class="comment">// 还原</span></span><br><span class="line">        part.<span class="title function_">pop</span>(); <span class="comment">// 还原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方案2：对数字进行全排列，验证序列的合法性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列</span></span><br><span class="line"><span class="comment">// 123 =&gt; 123,132,231,213,312,321 一共6个</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">permutation</span> = nums =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 + &#123;2,3&#125;的全排列 2 + &#123;1,3&#125;的全排列 3 + &#123;1,3&#125;的全排列</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">index, part</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(part.<span class="title function_">slice</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将当前索引和index交换</span></span><br><span class="line">            <span class="title function_">swap</span>(part, i, index);</span><br><span class="line">            <span class="title function_">dfs</span>(index + <span class="number">1</span>, part);</span><br><span class="line">            <span class="comment">// 再交换回来</span></span><br><span class="line">            <span class="title function_">swap</span>(part, index, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">checkIsValidSeq</span> = seq =&gt; &#123;</span><br><span class="line">    <span class="comment">// 合法序列：出栈序列中的每一个数字，比它小的数字，一定是按照递减顺序排列的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">check</span> = index =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = seq[index];</span><br><span class="line">        <span class="keyword">const</span> afterLessThan = seq.<span class="title function_">slice</span>(index).<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; afterLessThan.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> c = afterLessThan[i];</span><br><span class="line">            <span class="keyword">let</span> n = afterLessThan[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c &lt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; seq.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">check</span>(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getAllSeq2</span> = nums =&gt; <span class="title function_">permutation</span>(nums).<span class="title function_">filter</span>(<span class="function"><span class="params">seq</span> =&gt;</span> <span class="title function_">checkIsValidSeq</span>(seq));</span><br></pre></td></tr></table></figure>

<p>算法1.3.45.假设我们的栈测试用例会进行一系列的入栈和出栈操作，序列中的整数 0, 1, … , N - 1 （按此先后顺序排列）表示入栈操作，N个减号表示出栈操作。设计一个算法，判定给定的混合序列是否会使数组向下溢出（你使用的空间量与 N 无关，即不能用某种数据结构存储所有整数）。设计一个线性时间算法判定我们的测试用例能否产生某个给定的排列（这取决于出栈操作指令的出现位置）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性时间判断入列出列顺序的合法性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve1</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        cnt += num == <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定指定出栈顺序，求出对应的入栈和出栈操作</span></span><br><span class="line"><span class="comment">// 对于某个整数k，前k次出栈操作会在前k次入栈操作之前完成，否则栈不会向下移除。</span></span><br><span class="line"><span class="comment">// 如果某个排列可以产生，那么产生它的方式一定是唯一的：如果输出排列中的下一个整数在栈顶，则将它弹出，否则将其压入栈中。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve2</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    <span class="keyword">const</span> ops = [];</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    stack.<span class="title function_">push</span>(n);</span><br><span class="line">    ops.<span class="title function_">push</span>(n);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; nums.<span class="property">length</span> &amp;&amp; stack.<span class="title function_">peek</span>() != nums[i]) &#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(n);</span><br><span class="line">            ops.<span class="title function_">push</span>(n);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.<span class="title function_">peek</span>() != nums[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">        ops.<span class="title function_">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve1</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve2</span>([<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solve2</span>([<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>]));</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://ceeji.net/blog/forbidden-triple-for-stack-generability/">合法栈输出顺序的充要条件</a></p>
<blockquote>
<p>不同于 Stack，对于 Queue 来说，如果是执行一系列的入列出列的混合操作，则合法的顺序只有入列的顺序，因为队列的顺序一定是先进先出的。</p>
</blockquote>
<h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><p>n个人围城一个圈，按照1，2，3…n开始报数，报k的被杀掉，下一个从1开始重新报数，如此往复直到剩下一个人，如何确定自己的序号从而不被杀掉。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/josephus-ring.webp" alt="一共5人，数到3被杀，序号为4"></p>
<p>使用队列模拟上述过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> k = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    q.<span class="title function_">enqueue</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = q.<span class="title function_">dequeue</span>();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;kill&#x27;</span>, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.<span class="title function_">enqueue</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位置4就是我们最后不被杀死的位置。可以将上述模型抽象为：</p>
<blockquote>
<p>已知：总共有n个人，数到m的人将被杀死，并重新从1计数；求位置p使得该位置最后被杀死。</p>
</blockquote>
<p>现在考虑一种泛化情形：总共有 n 个人，数到 k 的人被杀掉，其中 n &gt;&#x3D; k。幸存者的位置为 p<sub>n</sub> 。<br>显而易见，初始位置为 k 的人将会第一个被杀掉。此时，经过重新排序之后，问题变成了 n-1 个人的情形。幸存者的位置为 p<sub>n-1</sub> 。如果能够找到从 p<sub>n-1</sub> 到 p<sub>n</sub> 的递推关系，那么问题就解决了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/josephus-ring-solve.png" alt="约瑟夫环的推理求解"></p>
<p>重新排序之后，每个人的位置发生了下面这些变化：</p>
<ul>
<li>1 -&gt; n-k+1</li>
<li>2 -&gt; n-k+2</li>
<li>…</li>
<li>k-1 -&gt; n-1</li>
<li>k 被杀死</li>
<li>k+1 -&gt; 1</li>
<li>…</li>
<li>p<sub>n</sub> -&gt; p<sub>n-1</sub></li>
<li>…</li>
<li>n-1 -&gt; n-k+1</li>
<li>n -&gt; n-k</li>
</ul>
<p>从右边的式子反推左边的式子，可以得到：p<sub>n</sub> &#x3D; (p<sub>n-1</sub> + k) % n。只有一个人的情况则：p<sub>1</sub> &#x3D; 0</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用递推式，求出正确的位置 fn = (fn-1 + k) % n;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve</span> = (<span class="params">n, k</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="title function_">solve</span>(n - <span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">const</span> ret = (a + k) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="title function_">solve</span>(n, m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num = &#x27;</span>, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">solve2</span> = (<span class="params">n, k</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index = (index + k) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wusuopubupt/article/details/18214999">约瑟夫环递推方程的推导</a></li>
</ul>
<h1 id="链表中虚拟头结点的应用"><a href="#链表中虚拟头结点的应用" class="headerlink" title="链表中虚拟头结点的应用"></a>链表中虚拟头结点的应用</h1><ul>
<li>删除第k个节点</li>
</ul>
<h1 id="环形队列和缓冲区"><a href="#环形队列和缓冲区" class="headerlink" title="环形队列和缓冲区"></a>环形队列和缓冲区</h1><p>RingBuffer一种固定尺寸的、头尾相连的缓冲区数据结构，又称为环形队列，拥有读写指针，在进程间异步数据传输或者记录日志文件的时候非常有用。当缓冲区空的时候不能读取数据，在缓冲区满的时候不能写数据.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        capacity += <span class="number">1</span>; <span class="comment">// 多分配一个，最后一个空间不存储数据，这样判断缓冲区满和缓冲区空就很方便了</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>; <span class="comment">// 下一次读的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一次写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> === <span class="variable language_">this</span>.<span class="property">writePos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">isFull</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span> === <span class="variable language_">this</span>.<span class="property">readPos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>] = item;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = (<span class="variable language_">this</span>.<span class="property">readPos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer2</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一个要写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span> = <span class="number">0</span>; <span class="comment">// 有效元素个数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">avaiable</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = (<span class="variable language_">this</span>.<span class="property">writePos</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>] = item;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span>++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">avaiable</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> readPos = <span class="variable language_">this</span>.<span class="property">writePos</span> - <span class="variable language_">this</span>.<span class="property">avaiable</span>;</span><br><span class="line">        <span class="keyword">if</span> (readPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            readPos += <span class="variable language_">this</span>.<span class="property">capacity</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">data</span>[readPos];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">avaiable</span>--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一个flip标记写指针是否到了读指针之前</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RingBuffer3</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>; <span class="comment">// 下一个要写的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>; <span class="comment">// 下一个要读的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">false</span>; <span class="comment">// 写指针是否到了读指针之前 </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">put</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">flipped</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> === <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">writePos</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> &gt;= <span class="variable language_">this</span>.<span class="property">readPos</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>++] = item;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">writePos</span> &gt;= <span class="variable language_">this</span>.<span class="property">readPos</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">writePos</span>++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">take</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">flipped</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> &lt; <span class="variable language_">this</span>.<span class="property">writePos</span> ? <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++] : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readPos</span> === <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">readPos</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">flipped</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">readPos</span> &lt; <span class="variable language_">this</span>.<span class="property">writePos</span> ? <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++] : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>[<span class="variable language_">this</span>.<span class="property">readPos</span>++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/ring-buffer.html">环形队列的实现</a></p>
<h1 id="前移编码、缓存和数据压缩"><a href="#前移编码、缓存和数据压缩" class="headerlink" title="前移编码、缓存和数据压缩"></a>前移编码、缓存和数据压缩</h1><p>问题来源：算法1.3.40。使用链表保存一系列字符并删除重复字符。当你读取了一个从未见过的字符时，将它插入表头。当你读取了一个重复的字符时，将它从链表中删去并再次插入表头。它实现了<em>前移编码策略</em>。这种策略假设最近访问过的元素很可能会再次访问，因此可以用于缓存、数据压缩等许多场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveToFront</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(char, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">const</span> next = cur.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">if</span> (!next) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.<span class="property">value</span> == char) &#123;</span><br><span class="line">                cur.<span class="property">next</span> = next.<span class="property">next</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">data</span>() &#123;</span><br><span class="line">        <span class="keyword">const</span> data = [];</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            data.<span class="title function_">push</span>(cur.<span class="property">value</span>);</span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h1><p>算法1.3.43。第一反应是用DFS来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">listFiles</span> = (<span class="params">dir, depth</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> absolutePath = path.<span class="title function_">resolve</span>(dir);</span><br><span class="line">    <span class="keyword">const</span> stat = fs.<span class="title function_">statSync</span>(absolutePath);</span><br><span class="line">    <span class="keyword">if</span> (stat.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(absolutePath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">            <span class="title function_">listFiles</span>(path.<span class="title function_">join</span>(absolutePath, file), depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-&#x27;</span>.<span class="title function_">repeat</span>(depth), absolutePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题目中说要使用队列来做,怎么感觉还是用的DFS的思想：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">listFiles2</span> = (<span class="params">dir, depth, queue</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> absolutePath = path.<span class="title function_">resolve</span>(dir);</span><br><span class="line">    <span class="keyword">const</span> stat = fs.<span class="title function_">statSync</span>(absolutePath);</span><br><span class="line">    <span class="keyword">if</span> (stat.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">        queue.<span class="title function_">enqueue</span>(&#123; <span class="attr">file</span>: dir, depth &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> files = fs.<span class="title function_">readdirSync</span>(absolutePath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">            <span class="title function_">listFiles2</span>(path.<span class="title function_">join</span>(absolutePath, file), depth + <span class="number">1</span>, queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Queue</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedQueue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"><span class="title function_">listFiles2</span>(<span class="string">&#x27;/Users/yiihua-013/consoles-projects/dsa4js/test&#x27;</span>, <span class="number">0</span>, q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> q) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-&#x27;</span>.<span class="title function_">repeat</span>(item.<span class="property">depth</span>), item.<span class="property">file</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈与文件编辑器的缓冲区"><a href="#栈与文件编辑器的缓冲区" class="headerlink" title="栈与文件编辑器的缓冲区"></a>栈与文件编辑器的缓冲区</h1><p>问题来源算法1.3.44。思路：建立两个栈，一个左栈，一个右栈，输入时将数据压入左栈，其实光标位置就是左栈的栈头，向左向右移动就是其中一个栈pop一些元素给另一个栈来模拟光标移动。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorBuffer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leftStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rightStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在光标位置插入字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">push</span>(char);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除并返回光标位置的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">delete</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将光标左移k个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">left</span>(<span class="params">k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将光标右移k个位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">right</span>(<span class="params">k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="property">size</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲区中的字符数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span> + <span class="variable language_">this</span>.<span class="property">rightStack</span>.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">inspect</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> pos = <span class="variable language_">this</span>.<span class="property">leftStack</span>.<span class="property">size</span>;</span><br><span class="line">        <span class="keyword">const</span> tmpStack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">leftStack</span>) &#123;</span><br><span class="line">            tmpStack.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> left = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> tmpStack) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> right = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">rightStack</span>) &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`pos = <span class="subst">$&#123;pos&#125;</span>,size = <span class="subst">$&#123;<span class="variable language_">this</span>.size()&#125;</span>,left = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(left)&#125;</span>,right = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(right)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">EditorBuffer</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&#x27;sfdssemkf&#x27;</span>) &#123;</span><br><span class="line">    buf.<span class="title function_">insert</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">buf.<span class="title function_">left</span>(<span class="number">4</span>);</span><br><span class="line">buf.<span class="title function_">delete</span>();</span><br><span class="line">buf.<span class="title function_">right</span>(<span class="number">2</span>);</span><br><span class="line">buf.<span class="title function_">insert</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">buf.<span class="title function_">right</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);</span><br></pre></td></tr></table></figure>

<h1 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h1><p>问题来源：算法1.3.49.使用有限个栈模拟队列，保证入队和出队操作在最坏情况下只需要常数时间。</p>
<p>很容易想到使用2个栈模拟队列。入队的时候向enqueStack中push元素，出队的时候从dequeStack中pop元素。dequeStack中的元素来源于dequeStack为空的时候将enqueStack移动到此位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Stack</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../LinkedStack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用2个栈模拟队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue1</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">enqueStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dequeStack</span> = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">enqueStack</span>.<span class="title function_">pop</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dequeStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入队操作为O(1)，出队操作为O(N)，不满足题目要求。使用6个栈均摊复杂度可以保证入队和出队的复杂度为O(1)。</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ikesnowy/p/7157813.html">使用6个栈实现O(1)队列</a></p>
<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p>从n个数中取出3个不同数的组合是C<sub>n</sub><sup>3</sup> &#x3D; <code>n(n-1)(n-2)/6</code>。</p>
<p>所以以下代码中cnt的值为10，而不是<code>5*4*3 = 60</code>!</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定性分析：</p>
<p>i &#x3D; 0,j &#x3D; 1,k &#x3D; 2,3,4 &#x3D;&gt; 3<br>i &#x3D; 0,j &#x3D; 2,k &#x3D; 3,4   &#x3D;&gt; 2<br>i &#x3D; 0,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1</p>
<p>i &#x3D; 1,j &#x3D; 2,k &#x3D; 3,4   &#x3D;&gt; 2<br>i &#x3D; 1,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1</p>
<p>i &#x3D; 2,j &#x3D; 3,k &#x3D; 4     &#x3D;&gt; 1 </p>
<p>总和: (3 + 2 + 1) + (2 + 1) + 1 &#x3D; 10。</p>
<p>5 * 4 * 3之所以错的原因是，没有考虑内循环条件的约束！</p>
<h1 id="幂次法则和倍率实验"><a href="#幂次法则和倍率实验" class="headerlink" title="幂次法则和倍率实验"></a>幂次法则和倍率实验</h1><p>以three-sum为例，该算法的复杂度为O(N^3):</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">count</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">MAX</span> = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(_.<span class="title function_">random</span>(-<span class="variable constant_">MAX</span>, <span class="variable constant_">MAX</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">const</span> cnt = <span class="title function_">count</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cnt,</span><br><span class="line">        <span class="attr">elapsedTime</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() - start</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">let</span> prev = <span class="title function_">test</span>(n);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    n += n;</span><br><span class="line">    <span class="keyword">const</span> cur = <span class="title function_">test</span>(n);</span><br><span class="line">    <span class="keyword">const</span> &#123; cnt, elapsedTime &#125; = cur;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n, cnt, elapsedTime, elapsedTime / prev.<span class="property">elapsedTime</span>);</span><br><span class="line">    prev = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">500 5 33 3.3</span><br><span class="line">1000 63 225 6.818181818181818</span><br><span class="line">2000 490 1709 7.595555555555555</span><br><span class="line">4000 3940 13493 7.895260386190754</span><br><span class="line">8000 31565 107293 7.951752760690728</span><br></pre></td></tr></table></figure>

<p>可以发现：当数据规模翻倍的时候，运行的时间的翻倍数量为8 &#x3D; 2^3。实际上对于大多数程序运行的时间可以写成:T(N) ~ aN^b·lgN，因此T(2N)&#x2F;T(N) ~ 2^b。倍率定理适合于<em>非指数级别的算法</em>，可以用来简单估算程序的运行时间。</p>
<blockquote>
<p>实际上，大多数现代计算机系统会使用缓存技术来组织内存（程序的局部性原理），在这种情况下访问大数组中的若干并不相邻的元素可能会比较长。上面的例子中看似运行时间的比例收敛到了8，但是到了后面数组规模变得很大了之后这个比例可能变成一个很大的值。这也是理论上快排和归并排序时间复杂度一样但是快排更快的原因。</p>
</blockquote>
<h1 id="二项式定理及其证明"><a href="#二项式定理及其证明" class="headerlink" title="二项式定理及其证明"></a>二项式定理及其证明</h1><p>问题来源：练习1.4.1。使用数学归纳法证明从N个数中取3个数的不同组合的总数为 N(N-1)(N-2)&#x2F;6。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(N, 3) = N! / [(N - 3)! × 3!]</span><br><span class="line">        = [(N - 2) * (N - 1) * N] / 3!</span><br><span class="line">        = N(N - 1)(N - 2) / 6</span><br></pre></td></tr></table></figure>

<p>显然N必须大于等于3，当N &#x3D; 3时等式成立，只有一种组合，当N&#x3D;4时等式也成立，4种组合。当拓展到N+1个数的时候可以理解为：<em>前 N 个数中取三个数的所有组合 + 多出的一个数和前 N 个数中的任意取两个数的所有组合</em>。</p>
<p>即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C(N+1,3) = C(N,3) + C(N,2)</span><br><span class="line">        = N(N - 1)(N - 2) / 6 + (N!/[(N-2)! * 2!])</span><br><span class="line">        = N(N - 1)(N - 2) / 6 + N(N - 1) / 2</span><br><span class="line">        = [N(N-1)(N-2) + N(N-1)*3] / 6</span><br><span class="line">        = N(N-1)(N-2+3) / 6</span><br><span class="line">        = (N+1)N(N-1) / 6</span><br></pre></td></tr></table></figure>

<h1 id="二分查找的思想及其应用"><a href="#二分查找的思想及其应用" class="headerlink" title="二分查找的思想及其应用"></a>二分查找的思想及其应用</h1><h2 id="局部最小元素"><a href="#局部最小元素" class="headerlink" title="局部最小元素"></a>局部最小元素</h2><p>二分查找可以使用<code>lgN</code>的复杂度在<strong>有序数组</strong>中找到指定元素。但是普通数组也可以使用二分查找的思想，例如：习题1.4.18</p>
<blockquote>
<p> 数组的局部最小元素。编写一个程序，给定一个含有 N 个不同整数的数组，找到一个局部最小元素：满足 a[i] &lt; a[i-1]，且 a[i] &lt; a[i+1] 的索引 i。程序在最坏情况下所需的比较次数为 ~ 2lgN。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力法 O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">localMin1</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>] &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数组中间值a[N/2]以及它相邻的元素a[N/2-1]和a[N/2+1]。如果a[N/2]是一个局部最小值则算法终止；否则在较小的相邻元素的那一侧查找</span></span><br><span class="line"><span class="comment">// 和二分查找的方式类似，先确认中间的值是否是局部最小，如果不是，则向较小的一侧二分查找。O(lgN)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">localMin2</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> index = <span class="title function_">localMin2</span>(arr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>习题1.4.19。矩阵的局部最小元素。给定一个含有 N ^ 2 个不同整数的 N×N 数组 a[]。设计一个运送时间和 N 成正比的算法来找出一个局部最小元素：满足 a[i][j] &lt; a[i + 1][j]、a[i][j] &lt; a[i][j + 1]、a[i][j] &lt; a[i - 1][j] 以及 a[i][j] &lt; a[i][j - 1] 的索引 i 和 j。程序运行时间在最坏情况下应该和 N 成正比。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(N^2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span> (item &lt; matrix[i + <span class="number">1</span>][j] &amp;&amp; item &lt; matrix[i][j + <span class="number">1</span>] &amp;&amp; item &lt; matrix[i - <span class="number">1</span>][j] &amp;&amp; item &lt; matrix[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂度为O(N)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findMinCol</span> = (<span class="params">matrix, midRow, colStart, colEnd</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">    <span class="keyword">let</span> colPos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = colStart; i &lt; colEnd; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[midRow][i] &lt; min) &#123;</span><br><span class="line">            min = matrix[midRow][i];</span><br><span class="line">            colPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> colPos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lgN</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findLocalmin</span> = (<span class="params">matrix, rowStart, rowEnd, colStart, colEnd</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> midRow = rowStart + <span class="title class_">Math</span>.<span class="title function_">floor</span>((rowEnd - rowStart) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> minColPos = <span class="title function_">findMinCol</span>(matrix, midRow, colStart, colEnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> midRowMin = matrix[midRow][minColPos]; <span class="comment">// 中间行中的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要和 上一行 &amp; 下一行比较就行</span></span><br><span class="line">    <span class="keyword">if</span> (midRowMin &lt; matrix[midRow + <span class="number">1</span>][minColPos] &amp;&amp; midRowMin &lt; matrix[midRow - <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [midRow, minColPos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间一行的最小值大于下一行，则说明下一行中间值比较小，在矩阵的下半部分继续寻找</span></span><br><span class="line">    <span class="keyword">if</span> (midRowMin &gt; matrix[midRow + <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, midRow, rowEnd, colStart, colEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, rowStart, midRow, colStart, colEnd);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix2</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> end = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">findLocalmin</span>(matrix, <span class="number">0</span>, end, <span class="number">0</span>, end);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代解法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">minMatrix3</span> = matrix =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> minRowIndex = <span class="number">0</span>, maxRowIndex = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (minRowIndex &lt;= maxRowIndex) &#123;</span><br><span class="line">        <span class="keyword">const</span> midRowIndex = minRowIndex + <span class="title class_">Math</span>.<span class="title function_">floor</span>((maxRowIndex - minRowIndex) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> min = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line">        <span class="keyword">let</span> minColPos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[midRowIndex][i] &lt; min) &#123;</span><br><span class="line">                min = matrix[midRowIndex][i];</span><br><span class="line">                minColPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> item = matrix[midRowIndex][minColPos];</span><br><span class="line">        <span class="keyword">if</span> (item &lt; matrix[midRowIndex - <span class="number">1</span>][minColPos] &amp;&amp; item &lt; matrix[midRowIndex + <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [midRowIndex, minColPos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item &gt; matrix[midRowIndex - <span class="number">1</span>][minColPos]) &#123;</span><br><span class="line">            maxRowIndex = midRowIndex - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minRowIndex = midRowIndex + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">9</span>, -<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = <span class="title function_">minMatrix2</span>(matrix);</span><br></pre></td></tr></table></figure>

<p>上面的解法2是一种“滚下山”(roll downhill)的方式。首先找到中间行，并在中间行中找到该行的最小值，然后判断它在该列中是不是局部最小值，如果是的话，那就返回这个值，否则向该列的最小一侧方向移动，如此循环往复。这个过程有点像在群山连绵的地方找到一个水池。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18525179/find-local-minimum-in-n-x-n-matrix-in-on-time/24461101#24461101">在O(n)的时间内在n*n的方阵中找到局部最小值</a></p>
<p>习题1.4.20。如果一个数组中的所有元素是先递增后递减的，则称这个数组为双调的。编写一个程序，给定一个含有 N 个不同 int 值的双调数组，判断它是否含有给定的整数。程序在最坏情况下所需的比较次数为 ~3lgN。</p>
<p>很容易想到的是O(N)的算法，仔细观察数组可以发现：双调数组存在一个最大值，我们可以使用1.4.18中的方法在lgN的时间内取得数组最大元素，这样数组左右两侧都是有序数组了，可以使用二分查找分别在左右两个子数组中进行查找。最坏的复杂度为3lgN。注意：二分查找的算法稍有改动，支持自定义的比较器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">localMax</span> = nums =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;检查输入&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>, hi = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在3lgN时间内判断双调数组中是否有指定元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">find</span> = (<span class="params">nums, num</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> binarySearch = <span class="built_in">require</span>(<span class="string">&#x27;../../binarySearch&#x27;</span>).<span class="property">binarySearch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxIndex = <span class="title function_">localMax</span>(nums); <span class="comment">// lgN得到最大元素</span></span><br><span class="line">    <span class="keyword">const</span> max = nums[maxIndex];</span><br><span class="line">    <span class="keyword">if</span> (num &gt; max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num === max) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> left = nums.<span class="title function_">slice</span>(<span class="number">0</span>, maxIndex);</span><br><span class="line">    <span class="keyword">const</span> right = nums.<span class="title function_">slice</span>(maxIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 分别向左和向右进行二分搜索</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">binarySearch</span>(left, num, <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">binarySearch</span>(right, num, <span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a) !== -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">100</span>, <span class="number">89</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> ret = <span class="title function_">find</span>(arr, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>源自算法1.4.22。这种查找的精髓在于<em>采用最接近长度的斐波那契数值来确定拆分点</em>。例如：对于现有长度为9的数组，要对它进行拆分，对应的斐波那契数列（长度先随便取，只要最大数大于9即可）{ 1，1，2，3，5，8，13，21 } ，不难发现，大于9且最接近9的斐波那契数值是f[6] &#x3D; 13，为了满足所谓的黄金分割，所以它的第一个拆分点应该就是f[6]的前一个值f[5] &#x3D; 8，即待查找数组array的第8个数，对应到下标就是array[7]，依次类推。</p>
<p><em>推演到一般情况，假设有待查找数组array[n]和斐波那契数组F[k],并且n满足n&gt;&#x3D;F[k]-1&amp;&amp;n &lt; F[k+1]-1，则它的第一个拆分点middle&#x3D;F[k]-1</em>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F(5) - 1 = 7</span><br><span class="line">F(6) - 1 = 12</span><br><span class="line">9 &gt;= F(5) - 1 &amp;&amp; 9 &lt; F(6) - 1</span><br><span class="line">所以切分点为F(5) - 1 = 7</span><br></pre></td></tr></table></figure>

<p>这里得注意，如果n刚好等于F[k]-1,待查找数组刚好拆成F[k-1]和F[k-2]两部分，那万事大吉你好我好；然而大多数情况并不能尽人意，n会小于F[k]-1,这时候可以拆成完整F[k-1]和残疾的F[k-2]两部分，那怎么办呢？聪明的前辈们早已想好了解决办法，对了，就是补齐，用最大的数来填充F[k-2]的残缺部分，如果查找的位置落到补齐的部分，那就可以确定要找的那个数就是最后一个最大的了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fib-partion.jpg" alt="斐波那契查找-切分"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建最大值刚好&gt;=待查找数组长度的裴波纳契数组  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">makeFibArray</span> = arr =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> a = [first, second];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> current = first + second;</span><br><span class="line">        a.<span class="title function_">push</span>(current);</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= len) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        first = second;</span><br><span class="line">        second = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fibSearch</span> = (<span class="params">nums, num</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fibArr = <span class="title function_">makeFibArray</span>(nums); <span class="comment">// 斐波那契数组</span></span><br><span class="line">    <span class="keyword">const</span> filledLength = fibArr[fibArr.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 填充数组长度</span></span><br><span class="line">    <span class="comment">// 构建填充数组：填充数组长度为大于等于待查找数组长度向上取整的斐波那契数</span></span><br><span class="line">    <span class="comment">// 前一部分为待查找数组，后部分用原数组的最后一个元素填充</span></span><br><span class="line">    <span class="keyword">const</span> filledArray = <span class="keyword">new</span> <span class="title class_">Array</span>(filledLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        filledArray[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> last = nums[nums.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.<span class="property">length</span>; i &lt; filledLength; i++) &#123;</span><br><span class="line">        filledArray[i] = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> k = fibArr.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 用来控制子数组的左右边界</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + fibArr[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; filledArray[mid]) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; filledArray[mid]) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">            k = k - <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid &gt; hi ? hi : mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h2><p>算法1.4.24。假设你面前有一栋 N 层的大楼和许多鸡蛋，假设将鸡蛋从 F 层或者更高的地方扔下鸡蛋才会摔碎，否则则不会。首先，设计一种策略来确定 F 的值，其中扔 <del>lgN 次鸡蛋后摔碎的鸡蛋数量为 ~lgN。然后想办法将成本降低到</del>2lgF。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs</span> = N =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; F) &#123;</span><br><span class="line">            <span class="comment">// 鸡蛋可以碎</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            brokenCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid === F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            hi = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F = &#x27;</span>, hi, <span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次鸡蛋,碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照第 1, 2, 4, 8,…, 2^k 层顺序查找，一直到 2^k &gt; F,随后在 [2^(k - 1), 2^k] 范围中二分查找</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs2</span> = N =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hi &lt; F) &#123;</span><br><span class="line">        lo = hi;</span><br><span class="line">        hi *= <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hi === F) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; F) &#123;</span><br><span class="line">            <span class="comment">// 鸡蛋可以碎</span></span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">            brokenCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid === F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            hi = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;F = &#x27;</span>, hi, <span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次鸡蛋,碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">throwEggs</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="title function_">throwEggs2</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>算法1.4.25。但现在假设你只有两个鸡蛋，而你的成本模型则是扔鸡蛋的次数。设计一种策略，最多扔 2√(N) 次鸡蛋即可判断出 F 的值， 然后想办法把这个成本降低到 ~c√(F) 次。 这和查找命中（鸡蛋完好无损）比未命中（鸡蛋被摔碎）的成本小得多的情形类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throwEggs3</span> = N =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> brokenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个蛋: 第一个蛋按照 √(N), 2√(N), 3√(N), 4√(N),…, √(N) * √(N) 顺序查找直至碎掉。这里扔了 k 次，k &lt;= √(N)。</span></span><br><span class="line">    <span class="keyword">while</span> (hi &lt; F) &#123;</span><br><span class="line">        lo = hi;</span><br><span class="line">        count++;</span><br><span class="line">        hi += <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照斐波那契递增</span></span><br><span class="line">    <span class="comment">// for (let i = 0; hi &lt; F; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     count++;</span></span><br><span class="line">    <span class="comment">//     lo = hi;</span></span><br><span class="line">    <span class="comment">//     hi += i;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    brokenCount++;</span><br><span class="line">    hi = <span class="title class_">Math</span>.<span class="title function_">min</span>(hi, N);</span><br><span class="line">    <span class="keyword">if</span> (hi === F) <span class="keyword">return</span> F;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个蛋：k-1√(N) ~ k√(N) 顺序查找直至碎掉，F 值就找到了。这里最多扔 √(N) 次    </span></span><br><span class="line">    <span class="comment">// 不能用二分查找，找到一个比较小的值，然后向右推进</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= F) &#123;</span><br><span class="line">            brokenCount++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lo++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;一共扔了&#x27;</span>, count, <span class="string">&#x27;次，碎了&#x27;</span>, brokenCount, <span class="string">&#x27;个蛋，找到F= &#x27;</span>, F);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="冷还是热问题"><a href="#冷还是热问题" class="headerlink" title="冷还是热问题"></a>冷还是热问题</h2><p>问题来源：算法1.4.34。你的目标是猜出 1 到 N 之间的一个秘密的整数。每次猜完一个整数后，你会直到你的猜测距离该秘密整数是否相等（如果是则游戏结束）。如果不相等，你会知道你的猜测相比上一次猜测距离秘密整数是比较热（接近），还是比较冷（远离）。设计一个算法在 ~2lgN 之内找到这个秘密整数，然后设计一个算法在 ~1lgN 之内找到这个秘密整数。</p>
<p>方案一：二分查找。先猜测左边界(lo) ，再猜测右边界(hi) ，如果边界值猜中的话直接返回，否则如果右边界比较热，那么左边界向右边界靠，lo &#x3D; mid；否则，右边界向左边界靠，hi &#x3D; mid。其中，mid &#x3D; lo + (hi – lo) &#x2F; 2。每次二分查找的时候需要猜测2次lo和hi，复杂度~2LgN。</p>
<p>方案二:假设上次猜测值为 lastGuess，本次即将要猜测的值为 nowGuess，通过方程：(lastGuess+nowGuess)&#x2F;2&#x3D;(lo+hi)&#x2F;2 可以求得 nowGuess，具体可以查看示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/cold-or-hot.png" alt="冷还是热"></p>
<p>数字是猜测顺序，黑色范围是猜测值的范围（lastGuess 和 nowGuess），绿色的是实际查找的范围（lo 和 hi）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">GUESS_RESULT</span> = &#123;</span><br><span class="line">    <span class="attr">COLD</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;cold&#x27;</span>),</span><br><span class="line">    <span class="attr">HOT</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;hot&#x27;</span>),</span><br><span class="line">    <span class="attr">EQ</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;eq&#x27;</span>),</span><br><span class="line">    <span class="attr">FIRST_GUESS</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;first_guess&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">N</span> = <span class="number">100000</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">MAGIC</span> = <span class="number">33</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastGuess</span> = -<span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">guessCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">guess</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">guessCount</span>++;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="variable language_">this</span>.<span class="property">MAGIC</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lastGuess</span> === -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">lastGuess</span> = n;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable constant_">GUESS_RESULT</span>.<span class="property">FIRST_GUESS</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> lastDiff = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">MAGIC</span> - <span class="variable language_">this</span>.<span class="property">lastGuess</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastGuess</span> = n;</span><br><span class="line">        <span class="keyword">const</span> nowDiff = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">MAGIC</span> - n);</span><br><span class="line">        <span class="keyword">return</span> nowDiff &gt; lastDiff ? <span class="variable constant_">GUESS_RESULT</span>.<span class="property">COLD</span> : <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>, hi = game.<span class="property">N</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">// 无法比较大小，所以需要guess两次，最小边界和最大边界</span></span><br><span class="line">        <span class="keyword">let</span> guessRes = game.<span class="title function_">guess</span>(lo);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        guessRes = game.<span class="title function_">guess</span>(hi);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>) &#123;</span><br><span class="line">            lo = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">task2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> game = <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">    <span class="keyword">let</span> lo = <span class="number">1</span>, hi = game.<span class="property">N</span>;</span><br><span class="line">    <span class="keyword">let</span> isRightSide = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 第一次猜测</span></span><br><span class="line">    <span class="keyword">let</span> guessRes = game.<span class="title function_">guess</span>(lo);</span><br><span class="line">    <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = lo + <span class="title class_">Math</span>.<span class="title function_">floor</span>((hi - lo) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> nowGuess = (lo + hi) - game.<span class="property">lastGuess</span>;</span><br><span class="line">        guessRes = game.<span class="title function_">guess</span>(nowGuess);</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (guessRes === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">HOT</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRightSide) &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRightSide) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isRightSide = !isRightSide;</span><br><span class="line">        <span class="keyword">if</span> (hi - lo &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (game.<span class="title function_">guess</span>(lo) === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (game.<span class="title function_">guess</span>(hi) === <span class="variable constant_">GUESS_RESULT</span>.<span class="property">EQ</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> game.<span class="property">guessCount</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math.log2(100000) ~= 17</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">task1</span>()); <span class="comment">// 35</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">task2</span>()); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7a9ea6ece2af">蓄水池算法</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://consoles.fun">consoles</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://consoles.fun/2018/12/26/awesome-alg/">https://consoles.fun/2018/12/26/awesome-alg/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://consoles.fun" target="_blank">雨碎江南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/">数学归纳法</a><a class="post-meta__tags" href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/">概率论</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2016/06/17/beauty-of-mathematics/" title="数学之美"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-06-17</div><div class="info-item-2">数学之美</div></div><div class="info-2"><div class="info-item-1"> 教育的本质不是将篮子填满，而是将灯点亮。   简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。 —— 蒂姆·博纳斯·李   Virture is like a rich stone,best plain set.(美德如同宝石，在朴素的映衬下最显华丽) —— 培根   爱是一念之差，最幸福的不过是，你曾经的呼唤，而我恰有过应答。 —— 朝小诚《黑白》   技术分为术和道2种。具体的做事方法是术，做事的原理和原则是道。很多具体的技术很快就会从独门绝技到普及，再到落伍，追求术的人一辈子很辛苦，只有掌握了道才能够做到游刃有余。追求“术”的人多半抱有侥幸心理，想走捷径，但真正做好一件事没有捷径，需要一万小时的专业训练和努力，也就是“一万小时定律”。   中国古代的阴阳学说可以看做是二进制的雏形。   数据库索引和布尔代数息息相关。   网络爬虫一般的步骤是“下载-索引-排序”，其中广度优先遍历用得比较多。   完全随机的高斯白噪声是很难消除的。  文字语言 VS...</div></div></div></a><a class="pagination-related" href="/2018/10/21/game-programming/" title="游戏编程算法与技巧"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-21</div><div class="info-item-2">游戏编程算法与技巧</div></div><div class="info-2"><div class="info-item-1">游戏编程概述游戏编程中的3个核心概念：游戏循环、游戏时间管理和游戏对象模型。 游戏循环整个程序的核心流程控制称为游戏循环。之所以是一个循环是因为游戏总在不断执行一系列动作直到玩家退出。每迭代一次游戏循环称为1帧。大部分游戏每秒钟更新30~60帧。60FPS即游戏循环每秒钟执行60次。一个传统的游戏循环分成3部分：处理输入、更新游戏世界、生成输出。 12345while game is running  process inpus  update game world  generate outputsloop    游戏时间管理游戏时间管理使得我们的游戏速度可以在任何机器上得到保证。通过处理时间增量来表示游戏逻辑。如果在8MHz下游戏的FPS为30，则在16MHz下FPS为60。也就是说在30FPS的时候敌人每秒钟移动150px，则在60FPS的时候敌人每秒移动300px。为了解决这个问题，通常需要引入时间增量：从上一帧起流逝的时间。更新逻辑可以写成这样： 1emeny.position.x += 150 *...</div></div></div></a><a class="pagination-related" href="/2022/07/14/programming-pearls/" title="编程珠玑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-14</div><div class="info-item-2">编程珠玑</div></div><div class="info-2"><div class="info-item-1">位图排序 输入：一个包含n个正整数的文件，其中每个正整数都小于n，在这里n &#x3D; 10^7，其中n个整数都是不可重复的。 输出：以升序排列的整数列表 约束：最多1MB内存，无限内存，时间最多几分钟，10s就可认为不需要优化了。  思考：一个整数占用4字节，10^7的整数占用的内存是4*10^7.一次性读取到内存中显然是不可能的。所以我们可以使用10^7&#x2F;2^20 &#x3D; 39趟归并排序，也就需要40次的IO操作，IO无疑是瓶颈。  我们可以使用10位长的字符串表示一个所有元素小于10的非负整数集合（集合3大特性），如：{1,2,3,5,8}可表示为：  10111010010 # 如果对应的位是1表示处于该集合  以上的方法非常巧妙，本来需要4个字节表示的数，仅仅通过一个位就实现了，空间瞬间剩下的几十倍，有不有？ 这样就可以使用10^7个位表示10^7个整数，占用空间为10^7&#x2F;2^20 &#x3D;...</div></div></div></a><a class="pagination-related" href="/2019/09/10/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AE%E5%AD%90%E5%92%8C%E5%B7%A5%E5%85%B7/" title="一些好用的轮子和工具"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-10</div><div class="info-item-2">一些好用的轮子和工具</div></div><div class="info-2"><div class="info-item-1"> 凡是现实的都是合理的，凡是合理的都是现实的。—— 黑格尔  canvas绘图阿里的数据可视化的底层框架g2，无需从头到尾操作原生canvas api了，画线、矩形、圆形、贴图等非常便利。 提高效率的chrome拓展 双向修改CSS的工具livestyle  常见的网关 Openresty：基于 Nginx 的高性能 Web 平台，集成了大量模块，用来处理 HTTP 请求，被许多企业作为内部网关的基础框架 Kong：构建在 OpenResty 上的网关平台，有丰富的插件体系，支持身份认证、限流、日志记录、监控等功能  大模型 从 0 开始写大模型 基于 AI 的浏览器自动化  githubgithub...</div></div></div></a><a class="pagination-related" href="/2020/04/29/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B9%88/" title="你真的会二分查找么"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-29</div><div class="info-item-2">你真的会二分查找么</div></div><div class="info-2"><div class="info-item-1">这几天刷LeetCode中二分查找相关的题目，思想总是没什么问题，总是被各种边界条件折磨地死去活来，提交1次错一次，完全是面向测试编程，好不容易把下标调整对了，可是当下次遇到这个题目的时候还是需要从头再错一边😿。我们先来看一下最朴素的二分查找，看看存在怎样的问题： 12345678910111213141516function binarySearch(arr, target) &#123;  let l = 0, r = arr.length - 1;  while (l &lt;= r) &#123;    const mid = (l + r) &gt;&gt; 1;    const num = arr[mid];    if (target === num) &#123;      return mid;    &#125;    if (target &lt; num) &#123;      r = mid - 1;    &#125; else &#123;      l = mid + 1;    &#125;  &#125;  return...</div></div></div></a><a class="pagination-related" href="/2019/08/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/" title="深入理解 HashMap"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-22</div><div class="info-item-2">深入理解 HashMap</div></div><div class="info-2"><div class="info-item-1">原理HashMap的底层采用的散列算法是拉链法（另一种散列算法是线性探测法）。并且在JDK1.8中使用红黑树对长链表进行优化。 初始容量、负载因子、阈值初始容量比较好理解，阈值指的是当桶的个数超过了这个值后Hash表会进行扩容。 12345678910/*** The next size value at which to resize (capacity * load factor).** @serial*/// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)int...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">consoles</div><div class="author-info-description">野马也，尘埃也，生物之以息相吹也</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/consoles"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/consoles" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:consoles.me@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%88%86%E5%B8%83%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-number">1.</span> <span class="toc-text">二项分布和递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AF%E5%8A%AA%E5%88%A9%E8%AF%95%E9%AA%8C%EF%BC%88%E7%8B%AC%E7%AB%8B%E9%87%8D%E5%A4%8D%E8%AF%95%E9%AA%8C%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">伯努利试验（独立重复试验）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AF%81%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">欧几里得算法及其证明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9B%9E%E7%8E%AF%E5%8F%98%E4%BD%8D"><span class="toc-number">3.</span> <span class="toc-text">字符串的回环变位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%B7%AE%E5%92%8C%E6%A0%87%E5%87%86%E5%B7%AE"><span class="toc-number">4.</span> <span class="toc-text">方差和标准差</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="toc-number">5.</span> <span class="toc-text">洗牌算法的正确性证明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">6.</span> <span class="toc-text">动态数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">出栈顺序和卡塔兰数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF"><span class="toc-number">8.</span> <span class="toc-text">约瑟夫环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">链表中虚拟头结点的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">10.</span> <span class="toc-text">环形队列和缓冲区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%A7%BB%E7%BC%96%E7%A0%81%E3%80%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">11.</span> <span class="toc-text">前移编码、缓存和数据压缩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="toc-number">12.</span> <span class="toc-text">目录遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">13.</span> <span class="toc-text">栈与文件编辑器的缓冲区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">14.</span> <span class="toc-text">使用栈实现队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">排列组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%82%E6%AC%A1%E6%B3%95%E5%88%99%E5%92%8C%E5%80%8D%E7%8E%87%E5%AE%9E%E9%AA%8C"><span class="toc-number">16.</span> <span class="toc-text">幂次法则和倍率实验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E8%AF%81%E6%98%8E"><span class="toc-number">17.</span> <span class="toc-text">二项式定理及其证明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">18.</span> <span class="toc-text">二分查找的思想及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">18.1.</span> <span class="toc-text">局部最小元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">18.2.</span> <span class="toc-text">斐波那契查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98"><span class="toc-number">18.3.</span> <span class="toc-text">扔鸡蛋问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B7%E8%BF%98%E6%98%AF%E7%83%AD%E9%97%AE%E9%A2%98"><span class="toc-number">18.4.</span> <span class="toc-text">冷还是热问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">19.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E7%AE%A1%E7%90%86%E5%AD%A6/" title="管理学">管理学</a><time datetime="2025-07-09T23:24:02.000Z" title="更新于 2025-07-09 23:24:02">2025-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/" title="码农翻身有感">码农翻身有感</a><time datetime="2025-07-04T23:02:12.000Z" title="更新于 2025-07-04 23:02:12">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/" title="面试常用套路">面试常用套路</a><time datetime="2025-07-02T18:34:21.000Z" title="更新于 2025-07-02 18:34:21">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2016/10/18/memcached/" title="memcached 初窥">memcached 初窥</a><time datetime="2025-07-02T11:15:01.000Z" title="更新于 2025-07-02 11:15:01">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/05/09/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6/" title="一些想读的书">一些想读的书</a><time datetime="2025-06-28T22:18:10.000Z" title="更新于 2025-06-28 22:18:10">2025-06-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2025 By consoles</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">日拱一卒，功不唐捐</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>