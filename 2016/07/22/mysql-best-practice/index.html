<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>搭建高可用 MySQL 架构 | 雨碎江南</title><meta name="author" content="consoles"><meta name="copyright" content="consoles"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DBMS的瓶颈在于IO而非CPU。  慎用数据库的一些特性，例如外键（业务量爆炸的时候分库分表将是一个灾难）。虽然不建议使用物理外键，但是相关联的列上一定要建立索引。   在双十一的场景中取消掉计划任务（例如定时备份）。  在大促中什么影响了数据库性能超高的QPS和TPSQPS(Query Per Second)风险：效率低下的SQL。数据库中的性能问题80%就是由慢查询造成的。也就是大多数的数">
<meta property="og:type" content="article">
<meta property="og:title" content="搭建高可用 MySQL 架构">
<meta property="og:url" content="https://consoles.fun/2016/07/22/mysql-best-practice/index.html">
<meta property="og:site_name" content="雨碎江南">
<meta property="og:description" content="DBMS的瓶颈在于IO而非CPU。  慎用数据库的一些特性，例如外键（业务量爆炸的时候分库分表将是一个灾难）。虽然不建议使用物理外键，但是相关联的列上一定要建立索引。   在双十一的场景中取消掉计划任务（例如定时备份）。  在大促中什么影响了数据库性能超高的QPS和TPSQPS(Query Per Second)风险：效率低下的SQL。数据库中的性能问题80%就是由慢查询造成的。也就是大多数的数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://consoles.fun/img/butterfly-icon.png">
<meta property="article:published_time" content="2016-07-22T21:33:27.000Z">
<meta property="article:modified_time" content="2025-04-02T23:00:49.000Z">
<meta property="article:author" content="consoles">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://consoles.fun/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "搭建高可用 MySQL 架构",
  "url": "https://consoles.fun/2016/07/22/mysql-best-practice/",
  "image": "https://consoles.fun/img/butterfly-icon.png",
  "datePublished": "2016-07-22T21:33:27.000Z",
  "dateModified": "2025-04-02T23:00:49.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "consoles",
      "url": "https://consoles.fun/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://consoles.fun/2016/07/22/mysql-best-practice/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '搭建高可用 MySQL 架构',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">雨碎江南</span></a><a class="nav-page-title" href="/"><span class="site-name">搭建高可用 MySQL 架构</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">搭建高可用 MySQL 架构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2016-07-22T21:33:27.000Z" title="发表于 2016-07-22 21:33:27">2016-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-02T23:00:49.000Z" title="更新于 2025-04-02 23:00:49">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-engine.png" alt="mysql存储引擎"></p>
<p>DBMS的瓶颈在于IO而非CPU。</p>
<blockquote>
<p>慎用数据库的一些特性，例如外键（业务量爆炸的时候分库分表将是一个灾难）。虽然不建议使用物理外键，但是相关联的列上一定要建立索引。</p>
</blockquote>
<ul>
<li>在双十一的场景中取消掉计划任务（例如定时备份）。</li>
</ul>
<h1 id="在大促中什么影响了数据库性能"><a href="#在大促中什么影响了数据库性能" class="headerlink" title="在大促中什么影响了数据库性能"></a>在大促中什么影响了数据库性能</h1><h2 id="超高的QPS和TPS"><a href="#超高的QPS和TPS" class="headerlink" title="超高的QPS和TPS"></a>超高的QPS和TPS</h2><p>QPS(Query Per Second)<br>风险：效率低下的SQL。数据库中的性能问题80%就是由慢查询造成的。也就是大多数的数据库问题可以通过对SQL进行优化来解决。</p>
<p>TPS（Transition Per Second）</p>
<h2 id="大量并发和超过的CPU使用率"><a href="#大量并发和超过的CPU使用率" class="headerlink" title="大量并发和超过的CPU使用率"></a>大量并发和超过的CPU使用率</h2><p>高并发可能导致DB连接被占满；超高CPU使用率可能因为CPU资源耗尽而出现宕机。这里并发量指的是同一时刻需要DB服务器处理请求的数量，而连接量往往比并发量大得多，因为现在的系统中每一个前端服务器（例如nginx,tomcat,apache）都会对数据库建立多个连接，而在众多的连接中往往只有几个是在请求数据库处理的，其他的大多数连接都会处于sleep状态。数据库对于允许建立的连接数目是有限的（max_connections默认为100）</p>
<h2 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h2><p>磁盘IO性能突然下降（使用更快的磁盘设备，SSD，fashion IO），其他大量消耗磁盘性能的计划任务（调整计划任务，做好磁盘维护）。例如平时在主库上进行备份的，在大促的时候应该切换到从库上备份。</p>
<h2 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h2><p>大多数网卡是1000mbps (bits) &#x3D; 1000 &#x2F; 8 &#x3D; 100 MB&#x2F;s(byte)</p>
<p>如何避免无法连接数据库的情况：</p>
<ol>
<li>减少从服务器的数量。（从服务器需要从主服务器上进行复制）</li>
<li>进行分级缓存</li>
<li>避免使用<code>SELECT *</code></li>
<li>分离业务网络和服务器网络</li>
</ol>
<h2 id="大表带来的问题"><a href="#大表带来的问题" class="headerlink" title="大表带来的问题"></a>大表带来的问题</h2><p>大表可以从2个维度来进行定义：</p>
<ul>
<li><p>记录数目巨大，单表超过1000W行</p>
</li>
<li><p>表数据文件巨大，超过10G</p>
</li>
<li><p>大表往往意味着慢查询（很难在一定时间内过滤出所需要的数据）的产生，大表往往会降低SQL的效率。</p>
</li>
<li><p>大表对DDL也会产生影响。例如建立索引需要很长时间。5.5版本以下建立索引会锁表，而&gt;&#x3D;5.5的时候虽然不会锁表，但是会引起主从延迟。</p>
</li>
</ul>
<p>对于大表有2种策略：分库分表和历史数据归档</p>
<p>分库分表把大表分成多个小表</p>
<p>难点：</p>
<ul>
<li>分表主键的选择</li>
<li>分表后跨分区数据的查询和统计</li>
</ul>
<p>大表的历史数据归档，可以尽量减少业务前后端的影响。难点在于：</p>
<ul>
<li>归档时间点的选择</li>
<li>如何进行归档操作</li>
</ul>
<h2 id="大事务带来的问题"><a href="#大事务带来的问题" class="headerlink" title="大事务带来的问题"></a>大事务带来的问题</h2><p>事务的隔离性（ISOLATION），SQL标准中定义了4种隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%iso%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>未提交读（READ UNCOMMITED）</li>
<li>已提交读 (READ COMMITED)</li>
<li>可重复读 (REPEATABLE READ)，InnoDB默认级别。</li>
<li>可串行化（SERIALIZABLE）,最高</li>
</ul>
<p>验证事务的隔离级别我们可以分别连接到两个mysql shell，在一个shell中进行插入操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-isolation-pepeatable-read.png" alt="MySQL默认隔离级别-可重复读"></p>
<p>大事务的运行时间比较长，操作的数据比较多的事务。可能造成锁定太多数据，造成大量的阻塞和锁超时。回滚的时间较长，并且在回滚的过程中数据也是被锁定的。执行时间长可能造成主从延迟。</p>
<p>处理大事务一般有以下的策略：</p>
<ol>
<li>避免一次性处理太多数据，可以进行分批处理；</li>
<li>查询操作（SELECT）可以从事务中移除，事务中只保留必要的写操作。</li>
</ol>
<h1 id="影响MySQL性能的几个因素"><a href="#影响MySQL性能的几个因素" class="headerlink" title="影响MySQL性能的几个因素"></a>影响MySQL性能的几个因素</h1><h2 id="CPU数量和主频的权衡"><a href="#CPU数量和主频的权衡" class="headerlink" title="CPU数量和主频的权衡"></a>CPU数量和主频的权衡</h2><p>如果我们的应用是计算密集型的就应该选择更高主频的U，因为现在的MySQL不支持对同一SQL进行并发处理，但是对于高并发的应用，CPU的数量越多越好。</p>
<p>在MyISAM中会将索引缓存在内存中，而数据通过OS进行缓存；InnoDB会同时在内存中缓存数据和索引。</p>
<p>缓存系统不但对读操作影响深远，对写操作也是有好处的。例如商品浏览次数，如果我们每次浏览都对数据库进行更新操作，必将导致大量IO，我们可以在每次浏览的时候修改缓存中的计数器，当计数器达到某一个值（例如100）的时候进行写库操作，这样就将100次的更新操作合并成了一次更新。缓存能够延缓DB的更新频次。</p>
<h1 id="CentOS系统参数优化"><a href="#CentOS系统参数优化" class="headerlink" title="CentOS系统参数优化"></a>CentOS系统参数优化</h1><p>对于一个处于监听状态的端口都会有自己的监听队列</p>
<p>内核相关参数(<code>/etc/sysctl.conf</code>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 4294967295 <span class="comment"># 单个共享内存段的最大值，应足够大，以便能够在一个内存段中容纳下整个InnoDB缓冲池的大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>增加资源限制（<code>/etc/security/limits.conf</code>）</p>
<p>该文件实际上是Linux PAM也就是插入式认证模块的配置文件。打开文件数目的限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535 <span class="comment"># * 表示对所有用户有效，soft，当前系统生效的设置</span></span><br><span class="line">* hard nofile 65535  <span class="comment"># hard 系统所能设置的最大值，nofile 所限制的资源是打开文件的最大数目 65535 限制数量</span></span><br></pre></td></tr></table></figure>

<p>磁盘调度策略（<code>/sys/block/devname/queue/scheduler</code>），例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/block/sda/queue/scheduler</span><br><span class="line">noop anticipatory deadline [cfq]</span><br></pre></td></tr></table></figure>

<p>以上的默认磁盘调度策略是cfq，除此之外还存在noop(电梯式调度策略)，deadline（截止时间调度策略，数据库最好选择），anticipatory（预料IO调度策略）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> deadline &gt; /sys/block/sda/queue/scheduler</span><br></pre></td></tr></table></figure>

<h2 id="文件系统对性能的影响"><a href="#文件系统对性能的影响" class="headerlink" title="文件系统对性能的影响"></a>文件系统对性能的影响</h2><p>ext3&#x2F;4系统挂载参数<code>/etc/fstab</code></p>
<h1 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h1><p>MySQL的插入式存储引擎将数据的处理和数据存储相分离。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-arch2.png" alt="MySQL体系结构"></p>
<p>SQL语句如何从文件中获得我们所需要查询的数据，这个的具体实现方式则是下一层存储引擎层进行实现。存储是针对于表而不是针对于库的。在一个库中可以使用不同的存储引擎建立不同的表</p>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/mysql-storage-engine.png" alt="MySQL存储引擎"></p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>5.5版本之前的默认存储引擎，也是系统表和临时表（在排序、分组等操作中，当数量超过一定大小之后，由查询优化器建立的临时表）使用的存储引擎。。由MYD和MYI组成。该引擎使用表级锁，对表中的数据进行修改时会锁表，在对表中的数据进行读取时需要加共享锁。表损坏修复可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; check table t_username; </span><br><span class="line">mysql&gt; repair table t_username;</span><br></pre></td></tr></table></figure>

<p>还可以使用<code>myisamchk</code>命令行工具</p>
<p>测试MyISAM存储引擎</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t_test(<span class="built_in">id</span> INT,name VARCHAR(20)) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>查看mysql数据文件的位置可以使用<code>show variables where Variable_name =&#39;datadir&#39;;</code>命令，我们进入数据库数据文件所在目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# <span class="built_in">pwd</span>                                  </span><br><span class="line">/data/mysqld/data/db_test                                                 </span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll                                   </span><br><span class="line">total 10                                                                  </span><br><span class="line">-rw-r----- 1 mysql mysql   65 Jul 23 11:25 db.opt                         </span><br><span class="line">-rw-r----- 1 mysql mysql 8586 Jul 23 11:25 t_test.frm  <span class="comment"># 表结构信息</span></span><br><span class="line">-rw-r----- 1 mysql mysql    20 Jul 23 11:25 t_test.MYD <span class="comment"># 表数据            </span></span><br><span class="line">-rw-r----- 1 mysql mysql 1024 Jul 23 11:25 t_test.MYI  <span class="comment"># 索引信息              </span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# myisampack -b -f t_test.MYI  <span class="comment"># 压缩表</span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll                                   </span><br><span class="line">total 11                                                                  </span><br><span class="line">-rw-r----- 1 mysql mysql   65 Jul 23 11:25 db.opt                         </span><br><span class="line">-rw-r----- 1 mysql mysql 8586 Jul 23 11:25 t_test.frm                     </span><br><span class="line">-rw-rw-rw- 1 mysql mysql   54 Jul 23 11:32 t_test.MYD <span class="comment"># 由于数据较小，压缩后的尺寸更大了                    </span></span><br><span class="line">-rw-r----- 1 mysql mysql 1024 Jul 23 11:36 t_test.MYI                     </span><br><span class="line">-rw-rw-rw- 1 mysql mysql   20 Jul 23 11:32 t_test.OLD <span class="comment"># 压缩前文件的备份</span></span><br></pre></td></tr></table></figure>

<p>支持全文索引，支持压缩（<code>myisampack</code>)，压缩之后进行插入操作报错，提示该表是只读的。</p>
<p><em>限制：</em></p>
<p>&lt;5.0版本默认表大小为4G，如果需要存储大表需要修改<code>MAX_Rows</code>和<code>AVG_ROW_LENGTH</code>,5.0版本之后默认支持256TB。</p>
<p><em>使用场景：</em></p>
<ul>
<li>非事务型应用</li>
<li>只读类应用（例如报表类）</li>
<li>空间类应用</li>
</ul>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>MySQL5.5之后的默认存储引擎。使用表空间进行数据存储。具有由<code>innodb_file_per_table</code>这个参数决定，如果该参数为ON,则表示独立的表空间<code>tablename.idb</code>，如果该参数为OFF则表示系统表空间：<code>ibdataX</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br><span class="line">mysql&gt; CREATE TABLE t_innodb(<span class="built_in">id</span> int,name varchar(20)) ENGINE=<span class="string">&#x27;innodb&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接下来我们进入数据文件目录查看下该种存储引擎对应的数据文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# <span class="built_in">pwd</span>                                  </span><br><span class="line">/data/mysqld/data/db_test                                                 </span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# ll t_innodb*                         </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 12:54 t_innodb.frm                  </span><br><span class="line">-rw-r----- 1 mysql mysql 98304 Jul 23 12:54 t_innodb.ibd  <span class="comment"># 每一个表一个单独的表空间              </span></span><br><span class="line">[root@muke-49-468585-v52l3 db_test]# </span><br></pre></td></tr></table></figure>

<p>接下来通过mysql shell修改<code>innodb_file_per_table</code>全局变量为OFF</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET global innodb_file_per_table=off; </span><br><span class="line">mysql&gt; CREATE TABLE t_innodb_g(<span class="built_in">id</span> int,name varchar(20)) ENGINE=<span class="string">&#x27;innodb&#x27;</span>; <span class="comment"># 创建新表</span></span><br></pre></td></tr></table></figure>

<p>再次查看数据库的数据目录发现只存在frm文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@muke-49-468585-v52l3 db_test]# ll t_innodb*                         </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 12:54 t_innodb.frm                  </span><br><span class="line">-rw-r----- 1 mysql mysql  8586 Jul 23 13:01 t_innodb_g.frm <span class="comment"># 存储在共享表空间，即上一级目录的ibdata1中                </span></span><br><span class="line">-rw-r----- 1 mysql mysql 98304 Jul 23 12:54 t_innodb.ibd </span><br></pre></td></tr></table></figure>

<h4 id="系统表空间和独立表空间之间如何选择"><a href="#系统表空间和独立表空间之间如何选择" class="headerlink" title="系统表空间和独立表空间之间如何选择"></a>系统表空间和独立表空间之间如何选择</h4><ul>
<li>系统表空间无法简单收缩文件的大小，删除数据后表空间的大小并不会缩小；会产生IO瓶颈</li>
<li>独立表空间可以通过optimize table命令收缩系统文件；独立表空间可以同时向多个文件刷新数据。</li>
</ul>
<p>强烈建议使用独立表空间。</p>
<h4 id="InnoDB是如何做到事务的ACID特性的？"><a href="#InnoDB是如何做到事务的ACID特性的？" class="headerlink" title="InnoDB是如何做到事务的ACID特性的？"></a>InnoDB是如何做到事务的ACID特性的？</h4><ul>
<li>Redo Log，重做日志，实现持久性，重做日志缓冲区（<code>show variables like &#39;innodb_log_buffer_size&#39;;</code>），和重做日志文件(数据目录下的<code>ib_logfile0</code>和<code>ib_logfile1</code>，这里有两个log file文件和<code>show variables like &#39;innodb_log_files_in_group&#39;;</code>相对应) </li>
<li>Undo Log，回滚日志，未提交的事务进行回滚和实现MVC（多版本并发控制）。</li>
</ul>
<p>Redo Log是顺序写入的，而Undo Log则是随机读写的。</p>
<p>InnoDB支持行级锁，可以最大程度支持并发。锁的主要作用是实现并发控制和事务的隔离性。我们可以在一个mysql shell中执行<code>lock table t_innodb write;</code>,然后在另一个shell中对该表进行读或者写操作都被阻塞，因为我们对t_innodb这张表加了表级排它锁。直到我们在第一个shell中执行<code>unlock tables;</code>，第二个shell才会有数据返回。</p>
<p>锁的粒度和资源的开销是负相关的。锁的粒度越小（行锁），资源占用越多，并发越大。</p>
<p>InnoDB状态检查可以使用<code>show engine innodb status</code></p>
<h1 id="其他存储引擎"><a href="#其他存储引擎" class="headerlink" title="其他存储引擎"></a>其他存储引擎</h1><p>查看支持的存储引擎可以使用<code>show engines;</code>命令</p>
<p>CSV存储引擎直接将表中的数据保存成CSV文件（因此每一列都不允许为空），我们可以使用vim直接查看或者编辑表中的数据（记得<code>flush tables;</code>），不支持索引，每次查询都会进行全表扫描，不适合大表和在线处理。该引擎可以作为数据交换的中间表（可以直接将excel导出为csv复制到mysql数据目录下）。</p>
<p>Archive存储引擎会使用zlib对表数据进行塔索，节省磁盘IO，数据文件的后缀为arz。只支持insert和select操作，只支持在自增id列上增加索引。使用场景是日志或者数据采集类的应用。</p>
<blockquote>
<p>tips:等值查找使用hash索引，而范围查找使用Btree索引。</p>
</blockquote>
<p>Memory存储引擎，也称为HEAP存储引擎，将数据保存在内存中。支持hash索引（默认）和Btree索引，索引字段都为固定长度，例如：<code>varchar(20) = char(20)</code>。不支持BLOB和TEXT等大字段。使用表级锁，所以尽管数据保存在内存中，并发性不见得比InnoDB高，表的大小由<code>max_heap_table_size</code>决定（默认16M）。该种存储引擎的应用场景是：用于查找或者映射表，例如邮编和地区的对应表和保存数据分析过程中的临时表。用于周期性聚合数据的结果表。由于Memory存储引擎的数据易丢失，所以要求数据是可以再生的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_c1 on t_memory(c1);  <span class="comment"># 在c1列上建立hash索引</span></span><br><span class="line">mysql&gt; create index idx_c2 using btree on t_memory(c2); <span class="comment"># 在c2列上建立BTree索引</span></span><br><span class="line">mysql&gt; show index from t_memory; <span class="comment"># 查看索引</span></span><br></pre></td></tr></table></figure>

<p>Federated存储引擎提供了访问远程MySQL服务器上表的方法，本地不存储数据，数据全部放在远程服务器上。本地需要保存表的结构和远程服务器的信息。默认禁止，我们可以在启动时增加federated参数,适合偶尔的统计分析或者手工查询。</p>
<p>不要在同一个数据库中使用多个存储引擎，这样可能导致潜在的bug,例如：事务失败回滚之后只有InnoDB上进行了回滚而myisam表的中的数据并没有进行回滚，出现的数据不一致的问题。</p>
<h1 id="MySQL服务器参数"><a href="#MySQL服务器参数" class="headerlink" title="MySQL服务器参数"></a>MySQL服务器参数</h1><p>mysql配置文件的加载顺序可以使用<code>mysqld --help --verbose | grep -A 1 &#39;Default options&#39;</code>命令进行查看</p>
<p>全局参数：<code>set global 参数名=参数值</code><br>会话参数：<code>set session 参数名=参数值</code></p>
<h2 id="内存参数"><a href="#内存参数" class="headerlink" title="内存参数"></a>内存参数</h2><p>要配置内存参数首先要弄清楚下面的几个问题：</p>
<ol>
<li>确定可以使用的内存上限</li>
<li>确定每个连接使用的内存（我们很容易犯的错误就是给每个连接分配的内存过大），主要有以下的几个参数：sort_buffer_size,join_buffer_size,read_buffer_size,read_rnd_buffer_size</li>
</ol>
<h2 id="IO配置参数"><a href="#IO配置参数" class="headerlink" title="IO配置参数"></a>IO配置参数</h2><h3 id="InnoDB-1"><a href="#InnoDB-1" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>innodb_log_file_size（单个事务日志的大小）和innodb_log_files_in_group（事务日志文件的个数）决定了InnoDB事务日志（Redo log的大小和数量），事务日志的总大小等于前两者的积。为了减少提交事务时产生的IO开销，InnoDB采用了预写日志的方式——也就是说在事务提交的时候会先写入到事务日志中，而不是每次都将修改后的数据文件刷新到磁盘中，因为事务的修改通常会将数据和索引映射到表空间的随机位置，所以刷新数据到文件将产生大量的随机IO，而记录日志所需要的则是顺序IO。所以相比于刷新脏数据到数据文件，记录日志的方式要快得多，一旦事务日志安全写入到磁盘中，事务就算是持久化了，因为即使是变更还没有写入到数据文件，如果这时候发生了服务器宕机，我们还是可以通过事务日志来恢复数据。</p>
<p>Innodb_flush_log_at_trx_commit:</p>
<p>0：每秒进行一次log写入到cache，并flush log到磁盘；<br>1：默认，每次事务提交的时候执行log写入cache并flush log到磁盘；<br>2：推荐，每次事务提交执行log写入cache，每秒执行一次flush log到磁盘。</p>
<p>Innodb_flush_method&#x3D;O_DIRECT<br>Innodb_file_per_table&#x3D;1<br>Innodb_doublewrite&#x3D;1,启用双写缓存，增加安全性</p>
<h4 id="MyISAM-1"><a href="#MyISAM-1" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>delay_key_write，有3个值：<br>OFF：每次写操作后刷新键缓冲中的脏块到磁盘<br>ON：只对建表时制定了delay_key_write选项的表使用延迟刷新<br>ALL：对所有MyISAM表都使用延迟键写入。</p>
<h2 id="安全配置参数"><a href="#安全配置参数" class="headerlink" title="安全配置参数"></a>安全配置参数</h2><p>expire_logs_days，自用清理binlog的天数<br>max_allowed_packet，控制MySQL可以接收的包的大小<br>skip_name_resolve,禁用dns查找<br>sysdate_is_now,确保sysdate()返回正确的日期，主从复制相关<br>read_only,禁止非super选线的用户的写权限，建议在从复制中启用，可以保证主从复制的一致性。<br>skip_slave_start,禁用slave自动恢复</p>
<h1 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h1><p><em>基准测试</em>是一种测量和评估软件性能指标的活动，用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新基准测试以评估变化对性能的影响。是一种针对系统设置的压力测试，应该尽量直接、简单、易于比较，用于评估服务器的处理能力（压力测试是对真实的业务数据进行测试，获得真实系统所承受的压力，基准测试可能并不关心业务逻辑，所使用的查询和业务的真实性可以和业务环境没关系）</p>
<p>mysql 5.7自带了基准测试工具mysqlslap，可以模拟服务器负载并输出相关的统计信息。我们可以使用它的–help来查看参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqlslap --concurrency=1,50,100,200 --iterations=3 --number-int-cols=5 --number-char-cols=5 --auto-generate-sql --auto-generate-sql-add-autoincrement --engine=myisam,innodb --number-of-queries=10 --create-schema=benchmark_test</span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>--print-only</code>参数来查看生成的sql脚本，如果出现快速滚屏的问题可以用管道：<code>cat bidfile.txt | less</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/akopytov/sysbench">sysbench</a>是一款非常常用的测试工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench --<span class="built_in">test</span>=cpu --cpu-max-prime=10000 run <span class="comment"># 测试CPU</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=fileio --file-total-size=10G prepare <span class="comment"># 文件IO测试，生成测试文件</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=fileio --number-thread=8 --init-rng=on --file-total-size=1G --file-test-mode=rndrw --report-interval=1 run <span class="comment"># 文件IO测试</span></span><br><span class="line">$ <span class="comment"># 使用该工具对数据库进行基准测试的时候需要建立对应的数据库</span></span><br><span class="line">mysql&gt; create database db_benchmark_test;</span><br><span class="line">mysql&gt; grant all privileges on *.* to benchmark_test@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>

<p>以上的准备工作已经做好，接下来进入到sysbench源码的<code>sysbench/tests/db</code>目录下（该目录下有现成的lua脚本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysbench --<span class="built_in">test</span>=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=db_benchmark_test --mysql-user=benchmark_test --mysql-password=123456 --oltp-tables-count=10 --mysql-socket=/tmp/mysql.sock prepare <span class="comment"># 生成测试数据</span></span><br><span class="line">$ sysbench --<span class="built_in">test</span>=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=db_benchmark_test --mysql-user=benchmark_test --mysql-password=123456 --oltp-tables-count=10 --mysql-socket=/tmp/mysql.sock run <span class="comment"># 测试</span></span><br></pre></td></tr></table></figure>

<h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><p>点击<a target="_blank" rel="noopener" href="http://consoles.github.io/2016/07/22/mysql-best-practice/code/select-course.sql">这里</a>下载建表语句。数据库结构优化一方面是减少数据冗余，另一方面是尽量减少数据维护中出现的更新、插入和删除异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+                                                              </span><br><span class="line">| Field        | Type        | Null | Key | Default           | Extra                       |                                                              </span><br><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+                                                              </span><br><span class="line">| stu_no       | int(11)     | NO   | PRI | NULL              |                             |                                                              </span><br><span class="line">| stu_name     | varchar(10) | NO   |     | NULL              |                             |                                                              </span><br><span class="line">| birthday     | timestamp   | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |                                                              </span><br><span class="line">| course_name  | varchar(10) | NO   | PRI | NULL              |                             |                                                              </span><br><span class="line">| score        | int(11)     | YES  |     | NULL              |                             |                                                              </span><br><span class="line">| course_point | int(11)     | YES  |     | NULL              |                             |                                                              </span><br><span class="line">+--------------+-------------+------+-----+-------------------+-----------------------------+   </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+                                                                           </span><br><span class="line">| stu_no | stu_name | birthday            | course_name | score | course_point |                                                                           </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+                                                                           </span><br><span class="line">|      1 | a        | 1993-07-07 00:00:00 | englisg     |  NULL |            9 |                                                                           </span><br><span class="line">|      1 | a        | 1993-07-07 00:00:00 | math        |  NULL |           10 |                                                                           </span><br><span class="line">|      2 | b        | 1983-07-17 00:00:00 | englisg     |  NULL |            9 |                                                                           </span><br><span class="line">|      2 | b        | 1983-07-17 00:00:00 | math        |  NULL |           10 |                                                                           </span><br><span class="line">+--------+----------+---------------------+-------------+-------+--------------+ </span><br></pre></td></tr></table></figure>

<p>首先以上的表中多次出现了冗余信息，姓名、课程、生日、学分都是冗余的</p>
<ul>
<li>插入异常：表中的某个实体随着另一个实体的存在而存在，如果缺少了某个实体就无法表示另一个实体。如果我们想要新加入一门语文课，学分是10分，但是没有任何学生选择这门课程。我们此时无法插入（因为学号是主键，但是没有默认值）</li>
<li>更新异常：更改表中某个实体的单独属性，需要对多行进行更新。如果我们将数学学分更新为15个学分，需要更新2行数据。——选课的学生越多，需要更新的数据越多</li>
<li>删除异常：删除表中的某个实体会导致其他实体消失。如果我们删除了所有选择数学的这门课的选课记录，数学这门课就不存在了。</li>
</ul>
<p>解决以上的三个异常的解决之道就是对数据库进行<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366">范式化设计</a>。</p>
<p>1NF:列不可拆分<br>2NF：其他列完全依赖于主键列<br>3NF：消除传递依赖</p>
<blockquote>
<p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；<br>通俗的理解是，字段还可以再分吗？如过不能，则是符合1NF的设计。</p>
</blockquote>
<blockquote>
<p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；<br>简单的解释，比如你和一个女生约会建立一张表，不用每条约会记录都记录她的身高、体重，将身高体重单独的存在一张表中供查询即可。</p>
</blockquote>
<blockquote>
<p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。<br>打个比方，比如评论表，如果你将用户ID，用户头像都放在这留言表中，就是不合适的了。用户头像是依赖于用户ID，而不依赖该评论。</p>
</blockquote>
<p>范式化设计能够有效降低数据冗余，但是有时候一个简单的查询可能需要关联多张表，影响SQL的性能，我们可以通过<em>反范式化</em>设计以空间换时间。</p>
<p>范式化设计有较少的数据冗余，更行快速，但是缺点也是显而易见的：需要对多张表进行关联，很难进行索引优化。</p>
<blockquote>
<p>反范式化设计将所要查询的数据集中存储在一张表中，拥有较高的查询性能，因为在InnoDB存储引擎中，进行全表扫描的效率高于表之间的关联操作，因为全表扫描是顺序IO，而表关联是随机IO。如果我们需要查询的数据都在一张表中就可以使用覆盖索引进行性能优化。</p>
</blockquote>
<p>所以在实际的应用中，我们要结合范式化设计和反范式化设计。</p>
<h2 id="数据库物理设计"><a href="#数据库物理设计" class="headerlink" title="数据库物理设计"></a>数据库物理设计</h2><blockquote>
<p><em>为表中的字段选择合适的数据类型</em>：当一个列可以有选择多种数据类型的时候，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型，因为在数据库中数据处理是以页为单位的，每个页能够存储的数据是有限的（InnoDB中为16K）,越小代表每个页中能够容纳的数据越多，加载同样的数据时，使用宽度较小的数据类型比宽度大的数据类型加载的数据页少，减少磁盘IO。</p>
</blockquote>
<p><strong>有2点需要纠正<code>int</code>和<code>int(10)</code>之间没有任何区别。和大多数编程语言一样MySQL中的<code>float</code>和<code>double</code>数据类型通常是精确的，如果需要精确表示数字可以使用<code>decimal</code>类型</strong></p>
<p>decimal类型每4字节存储9个数字，小数点占用1个字节。<code>DECIMAL(18,9)</code>需要9个字节来存储，整数和小数部分各4个字节，小数部分1个字节。</p>
<p>VARCHAR和CHAR类型的存储与存储引擎有很大关系，其占用的空间是以字符计数，根据编码的不同占用不同的存储空间。前者是变长字符串，只占用必要的存储空间，例如：UTF8编码的字符串长度为10，则定义为<code>VARCHAR(10)</code>即可，列最大长度小于255则只占用一个额外的字节存储字符串长度，否则占用2个字节存储字符串长度。</p>
<p>VARCHAR的使用场景：字符串列的最大长度比平均长度大得多；字符串列很少被更新（字符串长度发生变化导致存储页的分页从而导致存储碎片）；使用了多字节字符集存储字符串（例如utf8字符串）。</p>
<p>字符串存储在<code>CHAR</code>类型的列中会删除末尾的空格，最大宽度为255.使用场景为：字符串长度近似（例如MD5,身份账号）；短字符串（例如：性别<code>CHAR(1)</code>和<code>VARCHAR(1)</code>后者将占用额外的1个字节存储字符串长度）；经常被更新的字符串（一次分配足够的内存空间，不会导致分页）</p>
<p><code>DATETIME</code>类型和时区无关，占用8byte存储空间，时间范围<code>1000-01-01 00:00:00</code>到<code>9999-12-31 23:59:59</code>,多数场景<br><code>TIMESTAMP</code>unix时间戳(格林尼治)，占用4byte，<code>1970-01-01</code>到<code>2038-01-19</code>，在行的数据修改的时候可以自动修改<code>TIMESTAMP</code>列的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(d1 DATETIME,d2 TIMESTAMP);</span><br><span class="line">mysql&gt; INSERT t VALUES(NOW(),NOW());</span><br><span class="line">mysql&gt; SET TIME_ZONE=<span class="string">&#x27;+10:00&#x27;</span>;</span><br><span class="line">mysql&gt; SELECT * FROM t;</span><br></pre></td></tr></table></figure>

<h2 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h2><p>主键应该尽量小（索引占用空间），顺序增长（顺序IO），业务主键和数据库主键可以不同。数据库主键可以使用自增id，业务主键在数据库中可以使用唯一索引。</p>
<h1 id="表的拆分"><a href="#表的拆分" class="headerlink" title="表的拆分"></a>表的拆分</h1><ul>
<li>垂直拆分是将列拆分到不同的表。有2个原则：1.经常一起查询的列放在一起；2. text、blob等大字段拆分到附加表中。</li>
<li>水平拆分可以采用主键hash的方式，例如对uid对100进行mod操作。</li>
</ul>
<h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><p>给 MySQL 大表加字段的思路如下：</p>
<ol>
<li>创建一个临时的新表，首先复制旧表的结构（包含索引）<code>create table new_table like old_table</code>;</li>
<li>给新表加上新增的字段</li>
<li>把旧表的数据复制过来 <code>insert into new_table(filed1,filed2…) select filed1,filed2,… from old_table</code></li>
<li>删除旧表，重命名新表的名字为旧表的名字</li>
</ol>
<p>需要注意下，执行第三步的时候，可能这个过程也需要时间，这个时候有新的数据进来，所以原来的表如果有字段记录了数据的写入时间就最好了，可以找到执行这一步操作之后的数据，并重复导入到新表，直到数据差异很小。不过还是会可能损失极少量的数据。所以，如果表的数据特别大，同时又要保证数据完整，最好停机操作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://consoles.fun">consoles</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://consoles.fun/2016/07/22/mysql-best-practice/">https://consoles.fun/2016/07/22/mysql-best-practice/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://consoles.fun" target="_blank">雨碎江南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/09/13/MySQL%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/" title="MySQL 优化总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-13</div><div class="info-item-2">MySQL 优化总结</div></div><div class="info-2"><div class="info-item-1">思路 第一步要做的是确定问题的症结，而不是一上来就看表结构和查询语句。 开启profiling MySQL默认会开启缓存池，本地调试的时候清除缓存的命令是：reset query cache。  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950MariaDB [(none)]&gt; show variables like &#x27;%profi%&#x27;;  +------------------------+-------+| Variable_name          | Value |+------------------------+-------+| have_profiling         | YES   || profiling              | OFF   || profiling_history_size | 15    |+------------------------+-------+3 rows...</div></div></div></a><a class="pagination-related" href="/2016/08/02/high-availability-mysql/" title="高可用 MySQL 架构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-08-02</div><div class="info-item-2">高可用 MySQL 架构</div></div><div class="info-2"><div class="info-item-1"> There are one hundred ways to fix a problem. However, the ultimate solution is, don’t give it any chance to happen. (纠正一个错误的方法有很多，而解决一个错误的终极方法 就是不给它任何发生的机会。)知之为知之，不知为不知，是知也。也许是天赋不足、也许是智商捉急，更可能是懒惰和拖延作祟。但是既然开始了，就不愿意停下来。我本微末凡尘，却也心向天空。—— 我吃西红柿·《莽荒纪》我在起点与终点之间两全其美,却无法禅定于一夜琴声。直至悠悠的琴声被暗香淹没，我才刚刚赶到岸边，片刻之间，已被一缕清风绣在水面。...</div></div></div></a><a class="pagination-related" href="/2016/06/21/learn-mysql/" title="MySQL 初探"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-06-21</div><div class="info-item-2">MySQL 初探</div></div><div class="info-2"><div class="info-item-1"> 信息的价值会随时间锐减，尤其在事故处理过程中。  外键约束 父表和子表（有外键的表称为子表）必须使用相同的存储引擎，且存储引擎必须为InnoDB.外键列和被参照列的数据类型要相同，外键约束将自动创建索引。 查看建表语句可以使用SHOW CREATE TABLE t_users; 查看索引SHOW INDEXES FROM t_users\G;   在实际的开发中我们很少使用物理的外键约束，因为只有InnoDB这种引擎支持。所谓逻辑上的外键约束是在定义表的时候按照某种结构进行定义而不去使用foreign key这个关键字。业务爆炸的时候DB外键的约束可能对分库分表不友好。  mysql中的索引默认是BTree索引。 参见外键约束 表结构的修改参见修改表 无限分类的表的设计例如：天猫的商品：图书下面有小说、文学，在文学下面有四大名著、戏曲等。无限分类的表一般采用如下形式： 12345CREATE TABLE tdb_goods_types(	type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,	type_name...</div></div></div></a><a class="pagination-related" href="/2016/07/29/mysql-index-optimize/" title="MySQL 索引优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-07-29</div><div class="info-item-2">MySQL 索引优化</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2016/08/02/mysql-query-optimize/" title="MySQL 查询优化和数据库监控"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-08-02</div><div class="info-item-2">MySQL 查询优化和数据库监控</div></div><div class="info-2"><div class="info-item-1">如何确定查询处理的各个阶段所消耗的时间使用profile1234567mysql&gt; set profiling=1; -- 启用profile，这是一个session级别的配置mysql&gt; select count(*) from film; -- 执行任意SQLmysql&gt; show profiles; -- 查看profile，可以看到query id，duration和具体的sqlmysql&gt; show profile for query 5; -- 查看某个query id的各个阶段的消耗时间mysql&gt; show profile cpu for query 5; -- 查看CPU信息-- 以上的查询中我们可以看到都有一个警告信息mysql&gt; show warnings; -- 查看警告信息,发现警告信息是show profile已经被废弃了，官方建议使用Performance Schema 使用performance_schema...</div></div></div></a><a class="pagination-related" href="/2020/08/01/%E9%9D%A2%E8%AF%95%E5%A5%97%E8%B7%AF-%E6%95%B0%E6%8D%AE%E5%BA%93/" title="面试套路 - 数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-01</div><div class="info-item-2">面试套路 - 数据库</div></div><div class="info-2"><div class="info-item-1"> 辩证唯物主义告诉我们，事物发展轨迹是波浪式前进，螺旋式上升，有的时候似乎重新回到过去，但是却有了本质的区别和进步。   索引为啥索引能加快查询速度 索引其实也是一种空间换时间的思路。  数据库索引使用 B+ 树，B+ 树是一种 N 叉排序树，树的每个节点包含 N 个数据，这些数据按顺序排好，两个数据之间是一个指向子节点的指针，而子节点的数据则在这两个数据大小之间。  如上图所示：B+ 树的节点存储在磁盘上，每个节点存储 1000 多个数据，这样树的深度最多只要 4 层就可以存储数亿的数据。如果将树的根节点缓存在内存中，则最多只需要三次磁盘访问就可检索到需要的索引数据。  B 树和 B+ 树的区别：B 树的每个节点存储了记录的索引信息，而 B+ 树存储的是索引，只有在叶子节点存储的是全量的信息。并且 B+ 树在叶子节点有一个链表的结构，在范围查找的时候横向遍历会非常方便（不需要回溯到父节点再拓展向下）。  B+...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">consoles</div><div class="author-info-description">野马也，尘埃也，生物之以息相吹也</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/consoles"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/consoles" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:consoles.me@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E5%A4%A7%E4%BF%83%E4%B8%AD%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D%E4%BA%86%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">在大促中什么影响了数据库性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E9%AB%98%E7%9A%84QPS%E5%92%8CTPS"><span class="toc-number">1.1.</span> <span class="toc-text">超高的QPS和TPS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E5%92%8C%E8%B6%85%E8%BF%87%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87"><span class="toc-number">1.2.</span> <span class="toc-text">大量并发和超过的CPU使用率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98IO"><span class="toc-number">1.3.</span> <span class="toc-text">磁盘IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%8D%A1%E6%B5%81%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">网卡流量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">大表带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">大事务带来的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%B1%E5%93%8DMySQL%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%A0%E7%B4%A0"><span class="toc-number">2.</span> <span class="toc-text">影响MySQL性能的几个因素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%95%B0%E9%87%8F%E5%92%8C%E4%B8%BB%E9%A2%91%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">CPU数量和主频的权衡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CentOS%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">CentOS系统参数优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.1.</span> <span class="toc-text">文件系统对性能的影响</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">MySQL体系结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">MySQL存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM"><span class="toc-number">5.1.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB"><span class="toc-number">5.2.</span> <span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">系统表空间和独立表空间之间如何选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">InnoDB是如何做到事务的ACID特性的？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">6.</span> <span class="toc-text">其他存储引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">MySQL服务器参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">内存参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">IO配置参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-1"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">MyISAM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">安全配置参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">MySQL基准测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">数据库结构优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.1.</span> <span class="toc-text">数据库物理设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">9.2.</span> <span class="toc-text">主键的选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E6%8B%86%E5%88%86"><span class="toc-number">10.</span> <span class="toc-text">表的拆分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">11.</span> <span class="toc-text">一些小技巧</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E7%AE%A1%E7%90%86%E5%AD%A6/" title="管理学">管理学</a><time datetime="2025-07-09T23:24:02.000Z" title="更新于 2025-07-09 23:24:02">2025-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/" title="码农翻身有感">码农翻身有感</a><time datetime="2025-07-04T23:02:12.000Z" title="更新于 2025-07-04 23:02:12">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/" title="面试常用套路">面试常用套路</a><time datetime="2025-07-02T18:34:21.000Z" title="更新于 2025-07-02 18:34:21">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2016/10/18/memcached/" title="memcached 初窥">memcached 初窥</a><time datetime="2025-07-02T11:15:01.000Z" title="更新于 2025-07-02 11:15:01">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/05/09/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6/" title="一些想读的书">一些想读的书</a><time datetime="2025-06-28T22:18:10.000Z" title="更新于 2025-06-28 22:18:10">2025-06-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2025 By consoles</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">日拱一卒，功不唐捐</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>