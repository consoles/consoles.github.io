<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试常用套路 | 雨碎江南</title><meta name="author" content="consoles"><meta name="copyright" content="consoles"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="墨菲定理：任何事情都没有表面看起来那么简单；所有的事情都会比你预估的时间长；会出错的事情总会出错；你总是担心的事情，它总会发生的。  如何规范写日志日志要有分隔符大多数时候使用|作为分隔符。分析数据的时候直接用分隔符拆分对应的字段和属性。 123456# 正确例子类名|方法名|输入参数|输出参数# 错误例子1（不用分隔符）类名方法名输入参数输出参数# 错误例子2（用多种分隔符）类名#方法名 输入">
<meta property="og:type" content="article">
<meta property="og:title" content="面试常用套路">
<meta property="og:url" content="https://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/index.html">
<meta property="og:site_name" content="雨碎江南">
<meta property="og:description" content="墨菲定理：任何事情都没有表面看起来那么简单；所有的事情都会比你预估的时间长；会出错的事情总会出错；你总是担心的事情，它总会发生的。  如何规范写日志日志要有分隔符大多数时候使用|作为分隔符。分析数据的时候直接用分隔符拆分对应的字段和属性。 123456# 正确例子类名|方法名|输入参数|输出参数# 错误例子1（不用分隔符）类名方法名输入参数输出参数# 错误例子2（用多种分隔符）类名#方法名 输入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://consoles.fun/img/butterfly-icon.png">
<meta property="article:published_time" content="2019-08-22T17:51:44.000Z">
<meta property="article:modified_time" content="2025-07-02T18:34:21.000Z">
<meta property="article:author" content="consoles">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="软件工程">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://consoles.fun/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试常用套路",
  "url": "https://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/",
  "image": "https://consoles.fun/img/butterfly-icon.png",
  "datePublished": "2019-08-22T17:51:44.000Z",
  "dateModified": "2025-07-02T18:34:21.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "consoles",
      "url": "https://consoles.fun/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试常用套路',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">雨碎江南</span></a><a class="nav-page-title" href="/"><span class="site-name">面试常用套路</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试常用套路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-08-22T17:51:44.000Z" title="发表于 2019-08-22 17:51:44">2019-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-02T18:34:21.000Z" title="更新于 2025-07-02 18:34:21">2025-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><blockquote>
<p>墨菲定理：任何事情都没有表面看起来那么简单；所有的事情都会比你预估的时间长；会出错的事情总会出错；你总是担心的事情，它总会发生的。</p>
</blockquote>
<h1 id="如何规范写日志"><a href="#如何规范写日志" class="headerlink" title="如何规范写日志"></a>如何规范写日志</h1><h2 id="日志要有分隔符"><a href="#日志要有分隔符" class="headerlink" title="日志要有分隔符"></a>日志要有分隔符</h2><p>大多数时候使用<code>|</code>作为分隔符。分析数据的时候直接用分隔符拆分对应的字段和属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 正确例子</span><br><span class="line">类名|方法名|输入参数|输出参数</span><br><span class="line"># 错误例子1（不用分隔符）</span><br><span class="line">类名方法名输入参数输出参数</span><br><span class="line"># 错误例子2（用多种分隔符）</span><br><span class="line">类名#方法名 输入参数|输出参数</span><br></pre></td></tr></table></figure>

<h2 id="通过UUID编号来保证日志的连贯性"><a href="#通过UUID编号来保证日志的连贯性" class="headerlink" title="通过UUID编号来保证日志的连贯性"></a>通过UUID编号来保证日志的连贯性</h2><p>每次请求都应该有一个唯一编号，每记录一次日志还应该有一个唯一编号。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api.ERROR: 79a8ea37dceff105|0|responseObj is error:&#123;&quot;return_code&quot;:&quot;SUCCESS&quot;,&quot;return_msg&quot;:&quot;OK&quot;&#125;</span><br><span class="line">api.ERROR: 79a8ea37dceff105|1|App\Request|&#123;&quot;subject&quot;:&quot;201906179ae&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><code>79a8ea37dceff105</code>是本次请求的全局uuid，0,1表示记录的顺序编号。这样能保证一次请求的所有日志都<em>可追踪</em>，可查看<em>链路信息</em>。下面是一个简单的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">uuid</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">log</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.uuid&#125;</span>|<span class="subst">$&#123;<span class="variable language_">this</span>.id++&#125;</span>|<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志的时候会自动添加请求编号实现日志链路的追踪。</p>
<h2 id="对于数组、对象类型统一用JSON格式"><a href="#对于数组、对象类型统一用JSON格式" class="headerlink" title="对于数组、对象类型统一用JSON格式"></a>对于数组、对象类型统一用JSON格式</h2><p>比较通用，方便解析。特别是添加字段的时候节省大量的维护成本。</p>
<h2 id="重要日志要脱敏"><a href="#重要日志要脱敏" class="headerlink" title="重要日志要脱敏"></a>重要日志要脱敏</h2><p>用户绑定手机号或者邮箱时，会把手机号和邮箱作为参数传到服务端，我们在记录日志时应该把用户手机号和邮箱做脱敏处理，比如中间几位用*号代替。还有密码，身份证等敏感信息更要脱敏。日志是最容易泄露的数据，很难去保护，如果哪天大量用户的手机号等信息泄露可能就是日志未脱敏惹的祸，这个严重的大锅只能自己背。</p>
<h1 id="怎么限制文件上传大小？原理是什么"><a href="#怎么限制文件上传大小？原理是什么" class="headerlink" title="怎么限制文件上传大小？原理是什么"></a>怎么限制文件上传大小？原理是什么</h1><p>express中使用的是<a target="_blank" rel="noopener" href="https://github.com/expressjs/multer">multer</a>处理文件上传(multipart&#x2F;form-data)，用户上传大文件不仅会占用大量的内存资源，也会浪费带宽和磁盘。multer内部依赖的是busboy，这是一个解析stream为HTML的模块，代码比较简单：Busboy继承了可写流，并重写了<code>_write</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Busboy</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Busboy</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Busboy</span>(opts);</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">highWaterMark</span> !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="title class_">WritableStream</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, &#123; <span class="attr">highWaterMark</span>: opts.<span class="property">highWaterMark</span> &#125;);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="title class_">WritableStream</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_done</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_finished</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">opts</span> = opts;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">headers</span> &amp;&amp; <span class="keyword">typeof</span> opts.<span class="property">headers</span>[<span class="string">&#x27;content-type&#x27;</span>] === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">parseHeaders</span>(opts.<span class="property">headers</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing Content-Type&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inherits</span>(<span class="title class_">Busboy</span>, <span class="title class_">WritableStream</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Busboy</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_write</span> = <span class="keyword">function</span>(<span class="params">chunk, encoding, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_parser</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">cb</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Not ready to parse. Missing Content-Type?&#x27;</span>));</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span>.<span class="title function_">write</span>(chunk, cb);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在parseHeaders方法中根绝HTTP的header选择合适的parser:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Busboy</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">parseHeaders</span> = <span class="keyword">function</span>(<span class="params">headers</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (headers[<span class="string">&#x27;content-type&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> parsed = <span class="title function_">parseParams</span>(headers[<span class="string">&#x27;content-type&#x27;</span>]),</span><br><span class="line">        matched, type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable constant_">TYPES</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      type = <span class="variable constant_">TYPES</span>[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> type.<span class="property">detect</span> === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">        matched = type.<span class="title function_">detect</span>(parsed);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        matched = type.<span class="property">detect</span>.<span class="title function_">test</span>(parsed[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (matched)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">      <span class="keyword">var</span> cfg = &#123;</span><br><span class="line">        <span class="attr">limits</span>: <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">limits</span>,</span><br><span class="line">        <span class="attr">headers</span>: headers,</span><br><span class="line">        <span class="attr">parsedConType</span>: parsed,</span><br><span class="line">        <span class="attr">highWaterMark</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">fileHwm</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">defCharset</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">preservePath</span>: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">highWaterMark</span>)</span><br><span class="line">        cfg.<span class="property">highWaterMark</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">highWaterMark</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">fileHwm</span>)</span><br><span class="line">        cfg.<span class="property">fileHwm</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">fileHwm</span>;</span><br><span class="line">      cfg.<span class="property">defCharset</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">defCharset</span>;</span><br><span class="line">      cfg.<span class="property">preservePath</span> = <span class="variable language_">this</span>.<span class="property">opts</span>.<span class="property">preservePath</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_parser</span> = <span class="title function_">type</span>(<span class="variable language_">this</span>, cfg);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unsupported content type: &#x27;</span> + headers[<span class="string">&#x27;content-type&#x27;</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般上传文件的content-type是multipart，所以调用的是Multipart，先看下这个类的初始化，中间有一个计算文件限制大小的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileSizeLimit = (limits &amp;&amp; <span class="keyword">typeof</span> limits.<span class="property">fileSize</span> === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">                       ? limits.<span class="property">fileSize</span></span><br><span class="line">                       : <span class="title class_">Infinity</span>)</span><br></pre></td></tr></table></figure>

<p>上面计算的这个文件大小阈值会在onData回调函数中用到:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onData = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((nsize += data.<span class="property">length</span>) &gt; fileSizeLimit) &#123;</span><br><span class="line">        <span class="keyword">var</span> extralen = (fileSizeLimit - (nsize - data.<span class="property">length</span>));</span><br><span class="line">        <span class="keyword">if</span> (extralen &gt; <span class="number">0</span>)</span><br><span class="line">            file.<span class="title function_">push</span>(data.<span class="title function_">slice</span>(<span class="number">0</span>, extralen));</span><br><span class="line">        file.<span class="title function_">emit</span>(<span class="string">&#x27;limit&#x27;</span>);</span><br><span class="line">        file.<span class="property">truncated</span> = <span class="literal">true</span>;</span><br><span class="line">        part.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!file.<span class="title function_">push</span>(data))</span><br><span class="line">        self.<span class="property">_pause</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出当文件大小超过限制的时候<em>移除了data的事件监听</em>，从而后续不会触发data事件了，并且触发了limit，事件，这个事件在multer层接收，并返回错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileStream.<span class="title function_">on</span>(<span class="string">&#x27;limit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    aborting = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">abortWithCode</span>(<span class="string">&#x27;LIMIT_FILE_SIZE&#x27;</span>, fieldname)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将错误回调到express中返回给前端。原理就是流式读取，当发现读取的字节数超过限制的时候立即结束，关闭流，并且报错。</p>
<h1 id="如何理解-NIO-中的-Selector"><a href="#如何理解-NIO-中的-Selector" class="headerlink" title="如何理解 NIO 中的 Selector"></a>如何理解 NIO 中的 Selector</h1><p>selector是多路复用器，是NIO中的核心。</p>
<h1 id="API-网关有什么用"><a href="#API-网关有什么用" class="headerlink" title="API 网关有什么用"></a>API 网关有什么用</h1><p>SpringCloud中的API网关可以实现认证登陆、授权、限流、日志、监控。常见的组件有：</p>
<ul>
<li>基于nginx的二次开发：KONG,API Umbrella</li>
<li>Zuul:netflix提供的，包括Zuul1,Zuul2</li>
<li>Spring Cloud Gateway</li>
<li>Linkerd</li>
</ul>
<h1 id="如何进行接口的鉴权"><a href="#如何进行接口的鉴权" class="headerlink" title="如何进行接口的鉴权"></a>如何进行接口的鉴权</h1><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>由于HTTP的无状态性，客户端需要携带凭证来调用接口。传统web依赖cookie和session。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/027661b0-d1d6-11e9-9676-959a1e7188dd.png" alt="image.png"></p>
<p>而原生app不是基于浏览器的，常用的解决方案是<a target="_blank" rel="noopener" href="https://jwt.io/">JWT</a>。它的原理是服务端认证完成后生成一个JSON对象，返回给用用户，后续客户端的所有请求都会带上这个JSON对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/ea98cdc0-d1d6-11e9-9676-959a1e7188dd.png" alt="image.png"></p>
<p>如上图所示，一个JWT分为3个部分：Header,Payload,Signature。左边的字符串以<code>.</code>分割后解码（Base64）可以得到右边的部分。其中最关键的是Signature：编码后的header和编码后的payload以及一个秘钥使用header中指定的签名算法进行签名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signature = <span class="title class_">HMACSHA256</span>(<span class="title function_">base64Encode</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64Encode</span>(payload),secert)</span><br></pre></td></tr></table></figure>

<p>因为秘钥secert保存在服务器，即使别人拿到之后篡改了token中的数据，整个字符串就发生了变化，服务端就会鉴权失败，这样就可以保证安全性。一个基于Koa的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;sdfihu83u84283&amp;^$#43243#@@&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义ApiError，业务中直接throw，经过koa的错误处理中间件统一处理，不用再controller中手动构造JSON返回了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123;code, message, httpStatus&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">code</span> = code;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">httpStatus</span> = httpStatus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ERRORS</span> = &#123;</span><br><span class="line">  <span class="attr">AUTH_FAILURE</span>: &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">101</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;认证失败，非法token&#x27;</span>,</span><br><span class="line">    <span class="attr">httpStatus</span>: <span class="number">401</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查用户权限的中间件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">userAuth</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = ctx.<span class="property">query</span>.<span class="property">token</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, privateKey);</span><br><span class="line">    ctx.<span class="property">state</span>.<span class="property">uid</span> = <span class="built_in">parseInt</span>(decoded.<span class="property">uid</span>);</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApiError</span>(<span class="variable constant_">ERRORS</span>.<span class="property">AUTH_FAILURE</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>([<span class="string">&#x27;/users&#x27;</span>, <span class="string">&#x27;/admin&#x27;</span>], userAuth);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;uid, password&#125; = ctx.<span class="property">query</span>;</span><br><span class="line">  <span class="comment">// 验证uid和密码，通过后下发token，客户端拿到token后可以放到自己的本地缓存中，以后请求的时候每次带上这个token即可</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123;uid&#125;, privateKey, &#123;<span class="attr">expiresIn</span>: <span class="string">&#x27;2h&#x27;</span>&#125;);</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用户授权中间件通过后执行下面的逻辑</span></span><br><span class="line">  <span class="keyword">const</span> uid = ctx.<span class="property">state</span>.<span class="property">uid</span>;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    uid,</span><br><span class="line">    <span class="attr">uname</span>: <span class="string">&#x27;公孙龙&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">32</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title function_">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;code, message, httpStatus&#125; = err;</span><br><span class="line">      httpStatus = httpStatus || <span class="number">500</span>;</span><br><span class="line">      ctx.<span class="property">body</span> = &#123;code, message&#125;;</span><br><span class="line">      ctx.<span class="property">status</span> = httpStatus;</span><br><span class="line">      <span class="comment">// 做一些定制化处理</span></span><br><span class="line">      <span class="comment">// if (err instanceof ApiError) &#123;</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>())</span><br><span class="line">  .<span class="title function_">listen</span>(<span class="number">9999</span>);</span><br></pre></td></tr></table></figure>

<p>进行统一错误处理的时候其实遇到了一个坑：原先采用的不是错误处理中间件而是使用监听koa的全局onerror事件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>,<span class="function">(<span class="params">err,ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;这句话会执行，error occur&#x27;</span>,err);</span><br><span class="line">    ctx.<span class="property">body</span> = &#123;<span class="attr">message</span>:<span class="string">&#x27;这两句话不会执行&#x27;</span>&#125;;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">200</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是在路由中抛出错误的时候捕获到了错误，但是前端还是得到的字符串是<code>Internal Server Error</code>，状态码也是500，仔细查看源码发现<strong>koa对于每个请求中的错误调用的是其Context上的onerror</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Handle request in callback.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">handleRequest</span>(<span class="params">ctx, fnMiddleware</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.<span class="property">res</span>;</span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onerror</span> = err =&gt; ctx.<span class="title function_">onerror</span>(err);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleResponse</span> = (<span class="params"></span>) =&gt; <span class="title function_">respond</span>(ctx);</span><br><span class="line">    <span class="title function_">onFinished</span>(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fnMiddleware</span>(ctx).<span class="title function_">then</span>(handleResponse).<span class="title function_">catch</span>(onerror);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Default error handling.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;<span class="type">Error</span>&#125; <span class="variable">err</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@api</span> <span class="variable">private</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">onerror</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t do anything if there is no error.</span></span><br><span class="line">    <span class="comment">// this allows you to pass `this.onerror`</span></span><br><span class="line">    <span class="comment">// to node-style callbacks.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> <span class="title class_">Error</span>)) err = <span class="keyword">new</span> <span class="title class_">Error</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;non-error thrown: %j&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> headerSent = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">headerSent</span> || !<span class="variable language_">this</span>.<span class="property">writable</span>) &#123;</span><br><span class="line">        headerSent = err.<span class="property">headerSent</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, err, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nothing we can do here other</span></span><br><span class="line">    <span class="comment">// than delegate to the app-level</span></span><br><span class="line">    <span class="comment">// handler and log.</span></span><br><span class="line">    <span class="keyword">if</span> (headerSent) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; res &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first unset all headers</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> res.<span class="property">getHeaderNames</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        res.<span class="title function_">getHeaderNames</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> res.<span class="title function_">removeHeader</span>(name));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="property">_headers</span> = &#123;&#125;; <span class="comment">// Node &lt; 7.7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then set those specified</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">set</span>(err.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// force text/plain</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ENOENT support</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;ENOENT&#x27;</span> == err.<span class="property">code</span>) err.<span class="property">status</span> = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default to 500</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;number&#x27;</span> != <span class="keyword">typeof</span> err.<span class="property">status</span> || !statuses[err.<span class="property">status</span>]) err.<span class="property">status</span> = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// respond</span></span><br><span class="line">    <span class="keyword">const</span> code = statuses[err.<span class="property">status</span>];</span><br><span class="line">    <span class="keyword">const</span> msg = err.<span class="property">expose</span> ? err.<span class="property">message</span> : code;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = err.<span class="property">status</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(msg);</span><br><span class="line">    res.<span class="title function_">end</span>(msg);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>ctx中的onerror事件通过<code>this.app.emit(&#39;error&#39;, err, this);</code>将错误委托给application，接下来移除了httpHeaders，设置http状态码，最后最关键的一句话是<code>res.end(msg)</code>，这句话关闭http的输入流，所以即使我们后面自己设置ctx.body也不会响应任何信息给前端了，而msg默认就是<strong>Internal Server Error</strong>。所以这里使用application的的onerror事件处理错误其实是有坑的，而对于ctx的onerror方法这是个私有api官方并没有提供重写的方法。所以错误处理还是尽量选用中间件吧。</p>
<h1 id="系统调优"><a href="#系统调优" class="headerlink" title="系统调优"></a>系统调优</h1><ul>
<li>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。说明：操作系统默认 240s 后才会关闭 time_wait 状态的连接。在高并发访问下，服务器端会因为处于 time_wait 的连接数过多，而无法建立新的连接，所以需要在服务器上调小此等待值。</li>
<li>给 JVM 设置 <code>-XX:+HeapDumpOnOutOfMemoryError</code> 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。说明：OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。</li>
<li>在线上生产环境，JVM 的 Xms 和 Xms 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</li>
</ul>
<h1 id="为什么-DNS-服务器要采用分层结构"><a href="#为什么-DNS-服务器要采用分层结构" class="headerlink" title="为什么 DNS 服务器要采用分层结构"></a>为什么 DNS 服务器要采用分层结构</h1><p>互联网的规模太大，域名数量更是不胜枚举。一台DNS Server存储是不现实的。因此DNS在设计的时候就是分层架构，每一部分存储下一级的相关信息。</p>
<p>举个例子，我们想知道 <a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 的 IP 地址是什么，将这个请求发送给了我们的 DNS Server。</p>
<p>DNS Server 需要先问根域名服务器，谁负责管理 .com？然后再问 .com 域名服务器，谁负责管理 example.com？最后，再问 example.com 域名服务器，<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 的 IP 地址是什么，从而获得答案返回给我们。</p>
<p>以上就是域名的分级架构，域名查询需要从根开始，一级一级向下，直到找到答案。当然，因为域名查询是一个高频词的动作，无时无刻都在发生，如果每次都是这样一层一层获取，效率将十分低下，因此，DNS 系统中<em><strong>大量使用缓存</strong></em>，每一个中间环节都会缓存相关结果来节省时间提高效率。在不考虑缓存的情况下，我们每次都需要询问根域名服务器，那么DNS服务器是如何知道根域名服务器的地址呢？它其实采用了一个非常简单的做法——使用配置文件写死。全世界一共13组根域名服务器：<code>[a-m].root-servers.net</code>。IINA提供的<a target="_blank" rel="noopener" href="http://www.internic.net/domain/named.root">配置文件</a>。下载下来之后配置相关的DNS软件即可。</p>
<h2 id="DNS-域名解析的流程"><a href="#DNS-域名解析的流程" class="headerlink" title="DNS 域名解析的流程"></a>DNS 域名解析的流程</h2><ol>
<li>检查浏览器缓存</li>
<li>检查 OS 缓存</li>
<li>检查 hosts 文件</li>
<li>请求本地 DNS 服务器</li>
<li>请求根域名服务器</li>
</ol>
<p>DNS 查询的方式可以分为迭代查询和递归查询。</p>
<ul>
<li>迭代查询：向 DNS 服务器查询的时候如果对方无法给出答案，会返回<strong>下一级服务器的地址</strong>，由解析器自行继续查询</li>
<li>递归查询：客户端向 DNS 服务器（例如 ISP 的 DNS）发起请求后，<strong>必须返回最终答案</strong>。期间解析器会代替客户端完成所有层级的查询。</li>
</ul>
<p>为什么需要 2 种查询？</p>
<ul>
<li>递归查询：简化客户端逻辑，适合终端用户</li>
<li>迭代查询：分散 DNS 层级压力，避免根&#x2F;TLD 服务器过载。</li>
</ul>
<h1 id="CDN-的原理以及如何更新缓存"><a href="#CDN-的原理以及如何更新缓存" class="headerlink" title="CDN 的原理以及如何更新缓存"></a>CDN 的原理以及如何更新缓存</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113037678">CDN原理简介</a></p>
<p>更新缓存本质上回源操作，一般的CDN控制台都有这个功能。</p>
<h1 id="谈谈-TCP-中的状态机"><a href="#谈谈-TCP-中的状态机" class="headerlink" title="谈谈 TCP 中的状态机"></a>谈谈 TCP 中的状态机</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3b1b1020-df5e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LISTEN</td>
<td>等待来自远程TCP应用程序的请求</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td>
</tr>
<tr>
<td>SYN-RECEIVED</td>
<td>该端点已经接收到连接请求并发送确认。该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td>
</tr>
<tr>
<td>FIN_WAIT_1</td>
<td>等待来自远程TCP的终止连接请求或终止请求的确认</td>
</tr>
<tr>
<td>FIN_WAIT_2</td>
<td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td>
</tr>
<tr>
<td>CLOSE_WAIT</td>
<td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td>
</tr>
<tr>
<td>CLOSING</td>
<td>等待来自远程TCP的连接终止请求确认</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>等待先前发送到远程TCP的连接终止请求的确认</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td>
</tr>
</tbody></table>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><ul>
<li>第一次握手：客户端发送 SYN 包（SYN &#x3D; J）,并进入 SYN_SENT 状态，等待服务器确认。</li>
<li>第二次握手：服务端收到 SYN 包，确认客户端的 SYN（ACK &#x3D; J + 1），同时发送自己的 SYN 包(SYN &#x3D; k)，即服务器发送 SYN + ACK 包，此时服务器进入 SYN_RCVD 状态。</li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 包,向服务器发送确认包(ACK &#x3D; K + 1)。此包发送完毕后客户端和服务器进入 ESTABLISHED 状态，握手完成。</li>
</ul>
<p>下图显示了 TCP 三次握手的过程，以及客户端和服务端状态的变化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/e5993bb0-df60-11e9-8e7b-996bccbf78ea.png" alt="三次握手"></p>
<blockquote>
<p>如果在握手的过程中，某个阶段莫名中断，TCP 会再次以相同的顺序发送相同的数据包。</p>
</blockquote>
<h2 id="半连接队列是什么"><a href="#半连接队列是什么" class="headerlink" title="半连接队列是什么"></a>半连接队列是什么</h2><p>服务器第一次收到客户端的SYN之后就会进入到SYN_RCVD状态，此时双方还没有完全建立连接，服务器会把这种状态下的请求放入到一个队列中，这种队列就是<strong>半连接队列</strong>。与此对应，全连接队列指的就是已经完成3次握手，建立起连接的请求。<strong>如果队列满了（backlog）就可能出现丢包</strong>。</p>
<blockquote>
<p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过<strong>系统规定的最大重传次数</strong>，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, ….</p>
</blockquote>
<p>正因为TCP设计的有这些缺陷，有一种针对半连接的攻击叫做SYN攻击，大量构造三次握手中的第一次握手包SYN包浪费服务器CPU和内存资源，造成半连接队列溢出从而正常客户端发送的请求直接被服务器丢了，这样对于正常客户端服务就不可用了，检测SYN攻击也非常简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。</p>
<h3 id="为什么需要3次握手"><a href="#为什么需要3次握手" class="headerlink" title="为什么需要3次握手"></a>为什么需要3次握手</h3><p>为什么要三次握手，我握两次不行吗？我觉得我说发，你说好，不就完了吗，非要矫情一下，握第三次手的意义是什么？</p>
<p>首先我们先来理解一下为什么需要握手？</p>
<p>客户端和服务器端通信前需要连接，而”握手“作用就是为了证明，客户端的发送能力和服务器端的接受能力都是正常的，这是”握手“来达到的目的。</p>
<p>第一次握手:客户端发送网络包，服务器端收到了，这样服务器端就能证明：客户端的发送能力、以及服务器端的接收能力都是正常的。</p>
<p>第二次握手:服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 <strong>第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</strong></p>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/7748f470-896a-11ea-b9d1-b352894464ae.png" alt="image.png"></p>
<ul>
<li>第一次挥手：客户端主动关闭方发送一个FIN（此报文中指定一个序列号），此时客户端处于 FIN_WAIT1 状态。用来关闭客户端到服务器端的数据传送，也就是客户端告诉服务器端：我已经不会再给你发数据了， (当然，在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 确认报文，客户端依然会重发这些数据)，但是，<strong>此时客户端还可以接受数据</strong>。</li>
<li>第二次挥手:服务端收到 FIN 包后，发送一个 ACK 给客户端，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）.此时服务器处于 CLOSE_WAIT 状态。</li>
<li>第三次挥手：服务器端发送一个 FIN，用来关闭服务器端到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发送数据了！！！这一次其实就和客户端第一次挥手一样发送 FIN 报文携带序列号，发送完毕后服务器处于 LAST_ACK 状态。</li>
<li>第四次挥手：客户端收到 FIN 后，发送一个 ACK 给服务端，确认序号为收到序号 +1，至此，完成四次挥手。此时客户端处于 TIME_WAIT 阶段。需要过一阵子确保服务器收到自己的 ACK 报文之后才会进入到 CLOSED 状态.</li>
<li>服务器收到 ACK 之后就关闭连接了，处于 CLOSED 状态。</li>
</ul>
<p>这里特别需要主要的就是 TIME_WAIT 这个状态了，这个是面试的高频考点，就是要理解，<strong>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭</strong>。这其中的原因就是，*要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，*客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>至于 <strong>TIME_WAIT 持续的时间至少是一个报文的来回时间</strong>。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<p>注意：上述描述中的客户端和服务器的角色是对等的，以主动断开连接的一方作为客户端。</p>
<p>关于 3 次握手和 4 次挥手的网络抓包如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c459fcb0-e009-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p>
<p>以上的客户端和服务器在同一台机器上。但是我们仅在客户端抓包可能会出现如下的情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/bcb233b0-e00e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p>
<h2 id="为什么建立连接时-3-次握手，而关闭连接时-4-次挥手"><a href="#为什么建立连接时-3-次握手，而关闭连接时-4-次挥手" class="headerlink" title="为什么建立连接时 3 次握手，而关闭连接时 4 次挥手"></a>为什么建立连接时 3 次握手，而关闭连接时 4 次挥手</h2><p>这是因为服务器在 LISTEN 状态下，收到<strong>建立连接请求</strong>的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定。因此，一般 ACK 和 FIN 一般都会分开发送。</p>
<h2 id="为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态"><a href="#为什么-TIME-WAIT-状态还需要等-2MSL-后才能返回到-CLOSED-状态" class="headerlink" title="为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态"></a>为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态</h2><p>两个存在的理由：</p>
<ol>
<li>无法保证最后发送的 ACK 报文会一定被对方收到，所以需要重发可能丢失的 ACK 报文。</li>
<li>当关闭当前的 TCP 连接时，最后发送出去的数据报可能被路由器的转发队列缓存，如果立马切换到 CLOSED 状态，可能使用相同窗口的新的 TCP 连接收到的数据报还是前一个 TCP 连接缓存在路由器中的数据。2MSL 足以让分组最多存活MSL 秒被丢弃。</li>
</ol>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><ul>
<li>TCP: 面向连接，可靠，面向字节流</li>
<li>UDP: 面向非连接，不可靠，面向报文, 限制报文大小为 64k</li>
</ul>
<h1 id="如何设计一个高并发系统"><a href="#如何设计一个高并发系统" class="headerlink" title="如何设计一个高并发系统"></a>如何设计一个高并发系统</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/c0b29530-e29e-11e9-8e7b-996bccbf78ea.png" alt="image.png"></p>
<h2 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h2><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>大部分的高并发场景，都是读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p>
<h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的。</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。<strong>读流量太多的时候，还可以加更多的从库</strong>。</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p>
<p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验才是难能可贵的。</p>
<h2 id="为什么-Protocol-Buffer-的效率是最高的"><a href="#为什么-Protocol-Buffer-的效率是最高的" class="headerlink" title="为什么 Protocol Buffer 的效率是最高的"></a>为什么 Protocol Buffer 的效率是最高的</h2><ul>
<li>使用proto编译器，自动进行序列化和反序列化，速度非常快，比XML和JSON快20-100倍</li>
<li>数据压缩效果非常好，序列化后的数据量非常小，传输起来占用更少的带宽</li>
</ul>
<h2 id="ZK的使用场景有哪些"><a href="#ZK的使用场景有哪些" class="headerlink" title="ZK的使用场景有哪些"></a>ZK的使用场景有哪些</h2><p>统一命名服务（Name Service）、配置管理（Configuration Management）、集群管理（Group Membership）、共享锁（Locks）、队列管理。</p>
<ul>
<li>Zookeeper是一个类似linux、hdfs的树形文件结构，zookeeper可以用来保证数据在(Zookeeper)集群之间的数据的事务性一致性，zookeeper也是我们常说的CAP理论中的CP（强一致性）。</li>
<li>Zookeeper有一个概念叫watch（也称之为事件），是一次性触发的，当watch监视的数据发生变化时，通知设置了该watch的client端，即watcher实例对象（用于改变节点的变化而做出相应的行为）</li>
<li>Zookeeper有三个角色：Leader，Follower，Observer</li>
<li>Leader：数据总控节点，用于接收客户端连接请求，分发给所有的Follower节点后，各个Follower节点进行更新数据操作并返回给Leader节点，如果满足半数以上（所以Zookeeper集群一般是奇数个节点）更新成功则此次操作成功；</li>
<li>Follower：相当于跟随者的角色，Zookeeper的Leader宕机（挂掉）时，所有的Follower角色内部会产生选举机制，选举出新的Leader用于总控；</li>
<li>Observer：顾名思义，就是我们的客户端，用于观察Zookeeper集群的数据发送变化，如果产生变化则zookeeper会主动推送watch事件给Observer（客户端），用于对数据变化的后续处理；当然Observer（客户端）也可以发送数据变更请求；</li>
</ul>
<h3 id="分布式协调"><a href="#分布式协调" class="headerlink" title="分布式协调"></a>分布式协调</h3><p>简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/3711e6d0-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>举个栗子。对某一个数据连续发出两个修改操作，两台机器同时收到了请求，但是只能一台机器先执行完另外一个机器再执行。那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/5c06cf00-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<p>某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/twitter/commons/blob/master/src/java/com/twitter/common/zookeeper/DistributedLockImpl.java">Twitter的分布式锁的实现</a></p>
<p>与redis分布式锁的对比：</p>
<ul>
<li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li>
<li>zk分布式锁，获取不到锁，注册个监听器即可，不需要主动尝试获取锁，性能开销小。</li>
</ul>
<p>另外一点就是，如果是 redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。redis分布式锁好麻烦:遍历上锁，计算时间等等……zk 的分布式锁语义清晰实现简单。综上所述zk的分布式锁比redis的分布式锁牢靠，而且模型简单易用。</p>
<h3 id="元数据-配置信息管理"><a href="#元数据-配置信息管理" class="headerlink" title="元数据&#x2F;配置信息管理"></a>元数据&#x2F;配置信息管理</h3><p>zookeeper可以用作很多系统的配置信息的管理，比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理，包括 dubbo 注册中心不也支持zookeeper么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/aeabbae0-e336-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<h3 id="HA高可用"><a href="#HA高可用" class="headerlink" title="HA高可用"></a>HA高可用</h3><p>比如 hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，就是一个<strong>重要进程一般会做主备</strong>两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/07289f80-e337-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><blockquote>
<p>好的架构不是设计出来的，而是进化出来的。过早将一个系统划分为微服务的代价是非常高的（尤其是面对一个全新的领域时）。很多时候将一个已有的单体架构划分成微服务比从头开始构建微服务要简单得多！</p>
</blockquote>
<p>微服务的一大特点就是<strong>异构</strong>，不同的服务可以采用不同的语言，不同的 DB。</p>
<h2 id="不适用的场景"><a href="#不适用的场景" class="headerlink" title="不适用的场景"></a>不适用的场景</h2><ol>
<li>强事务</li>
<li>业务相对稳定、迭代周期长，几个月都不会更新 1 次</li>
<li>访问压力不大，可用性要求不高，例如中小型公司的内部系统</li>
</ol>
<h1 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h1><h2 id="电商网站详情页系统架构"><a href="#电商网站详情页系统架构" class="headerlink" title="电商网站详情页系统架构"></a>电商网站详情页系统架构</h2><p>小型电商网站的页面展示采用页面全量静态化的思想。数据库中存放了所有的商品信息，页面静态化系统，将数据填充进静态模板中，形成静态化页面，推入 Nginx 服务器。用户浏览网站页面时，取用一个已经静态化好的 html 页面，直接返回回去，不涉及任何的业务逻辑处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/80ec7620-e350-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<p>这样做，好处在于，用户每次浏览一个页面，不需要进行任何的跟数据库的交互逻辑，也不需要执行任何的代码，直接返回一个 html 页面就可以了，速度和性能非常高。对于小网站，页面很少，很实用，非常简单，Java 中可以使用 velocity、freemarker、thymeleaf 等等，然后做个 cms 页面内容管理系统，模板变更的时候，点击按钮或者系统自动化重新进行全量渲染。坏处在于，仅仅适用于一些小型的网站，比如页面的规模在几十到几万不等。对于一些大型的电商网站，亿级数量的页面，你说你每次页面模板修改了，都需要将这么多页面全量静态化，靠谱吗？每次渲染花个好几天时间，那你整个网站就废掉了。</p>
<p>大型电商网站商品详情页的系统设计中，当商品数据发生变更时，会将变更消息压入 MQ 消息队列中。缓存服务从消息队列中消费这条消息时，感知到有数据发生变更，便通过调用数据服务接口，获取变更后的数据，然后将整合好的数据推送至 redis 中。Nginx 本地缓存的数据是有一定的时间期限的，比如说 10 分钟，当数据过期之后，它就会从 redis 获取到最新的缓存数据，并且缓存到自己本地。</p>
<p>用户浏览网页时，动态将 Nginx 本地数据渲染到本地 html 模板并返回给用户。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/a768c1a0-e350-11e9-91c0-5ff5ef5e8f10.png" alt="image.png"></p>
<p>虽然没有直接返回 html 页面那么快，但是因为数据在本地缓存，所以也很快，其实耗费的也就是动态渲染一个 html 页面的性能。如果 html 模板发生了变更，不需要将所有的页面重新静态化，也不需要发送请求，没有网络请求的开销，直接将数据渲染进最新的 html 页面模板后响应即可。</p>
<p>在这种架构下，我们需要保证系统的高可用性。如果系统访问量很高，Nginx 本地缓存过期失效了，redis 中的缓存也被 LRU 算法给清理掉了，那么会有较高的访问量，从缓存服务调用商品服务。但如果此时商品服务的接口发生故障，调用出现了延时，缓存服务全部的线程都被这个调用商品服务接口给耗尽了，每个线程去调用商品服务接口的时候，都会卡住很长时间，后面大量的请求过来都会卡在那儿，此时缓存服务没有足够的线程去调用其它一些服务的接口，从而导致整个大量的商品详情页无法正常显示。这其实就是一个商品接口服务故障导致缓存服务资源耗尽的现象。</p>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="设计实现一个-LRU"><a href="#设计实现一个-LRU" class="headerlink" title="设计实现一个 LRU"></a>设计实现一个 LRU</h2><p>该结构支持2个操作：访问和删除。访问操作会将不存在于数据结构中的元素插入（或者数据结构中存在该元素，则该元素放在头部），删除操作会返回最近最少访问的元素。</p>
<p>思考：取得最近访问元素就像是FIFO，可以想到栈，但是删除最老的数据就需要遍历整个栈了。我们需要一种快速访问容器头部并快速移除尾部元素的结构，自然而然可以想到队列，但是LRU还有一个特性：如果容器中已经有元素，需要将元素移动到头部，队列对于这样的操作需要从头遍历到指定元素，删除元素，再在 对头插入。显然是低效的。联想到双端链表删除元素只需要O(1)，（单链表删除元素为O(N),因为要遍历链表）。因此LRU的底层可以采用双向链表存储。快速根据key找到node节点就需要使用hash表了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value, prev, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = prev;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">insertFirst</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deleteLast</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">tail</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ret = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newTail = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!newTail) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newTail.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把节点移动到头部</span></span><br><span class="line">  <span class="title function_">moveToFront</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node || node === <span class="variable language_">this</span>.<span class="property">head</span>) <span class="keyword">return</span>; <span class="comment">// 已经在头部了</span></span><br><span class="line">    <span class="keyword">const</span> &#123;prev, next&#125; = node;</span><br><span class="line">    <span class="comment">// 这个判断其实没有必要，因为前面已经判断过不是头结点了，前驱节点一定存在,写这个的目的是</span></span><br><span class="line">    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">      prev.<span class="property">next</span> = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next) &#123;</span><br><span class="line">      next.<span class="property">prev</span> = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prev</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// key =&gt; 元素 ；value，双向链表中的节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将不存在数据结构中的元素插入</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">access</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      node = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">insertFirst</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(value, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">moveToFront</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除并返回最近最少访问的元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">delete</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">deleteLast</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">const</span> values = [];</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      values.<span class="title function_">push</span>(cur.<span class="property">value</span>);</span><br><span class="line">      cur = cur.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values.<span class="title function_">join</span>(<span class="string">&#x27; -&gt; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考:<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></p>
<h1 id="如何回退代码到指定版本"><a href="#如何回退代码到指定版本" class="headerlink" title="如何回退代码到指定版本"></a>如何回退代码到指定版本</h1><p>方式一：可以新建一个分支，然后选择你想回退到到那个版本，切换到新分支之后，代码就是那个版本了，可以对那个版本进行操作，修改等，如果想回到之前最新版本，直接切换分支到原来到分支即可，这杨相互不影响，Reset master to this commit 只有是hard的时候，项目里代码内容才是你想切到的版本内容，不过这样会把你新改的代码丢失了.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/a1a074a0-52bf-11ea-99cb-bf4e2c176816.png" alt="image.png"></p>
<p>方式二：git reset</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/bebba0a0-52bf-11ea-99cb-bf4e2c176816.png" alt="image.png"></p>
<p>注意如果需要保留后面commit的更改就选mixed，不然选hard。</p>
<p>注意：从这个reset 之后，再push服务器，会<strong>提示落后xx个版本</strong>，这个时候需要强制push。<code>git push --force</code>。</p>
<h1 id="一个-TCP-连接能发几个-HTTP-请求"><a href="#一个-TCP-连接能发几个-HTTP-请求" class="headerlink" title="一个 TCP 连接能发几个 HTTP 请求"></a>一个 TCP 连接能发几个 HTTP 请求</h1><p>如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 和 Keep-Alive 首部，在请求头带上 Connection: Keep-Alive，并且可以通过 Keep-Alive 通用首部中指定的，用逗号分隔的选项调节 keep-alive 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。<br>而如果是 HTTP 1.1 版本协议，支持了长连接，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限；<br>同样，如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送</p>
<h1 id="HTTP2-HTTP3"><a href="#HTTP2-HTTP3" class="headerlink" title="HTTP2&#x2F;HTTP3"></a>HTTP2&#x2F;HTTP3</h1><h2 id="什么是-TCP-的队头阻塞"><a href="#什么是-TCP-的队头阻塞" class="headerlink" title="什么是 TCP 的队头阻塞"></a>什么是 TCP 的队头阻塞</h2><p>TCP 协议中的一个<em>性能问题</em>。当一个 TCP 连接中的某个数据包丢失或延迟时，后续的数据包即使已经到达接收端，也无法被处理，必须等待丢失或者延迟的数据包重传并到达。这种现象会导致整个连接的吞吐量下降和延迟增加。</p>
<p>原因：</p>
<ol>
<li>TCP 的可靠性机制：TCP 是可靠协议，要求数据按照顺序到达接收端。如果某个数据包丢失或者乱序，接收端会将其缓存，直到丢失的数据包到达。</li>
<li>单一路径传输：TCP 连接中的所有数据包通过<em>同一条路径</em>传输，某个包丢失会导致整个连接的性能受影响。</li>
<li>滑动窗口机制：使用这种机制来进行流控。某个数据包丢失，发送端的窗口会被阻塞，直到丢失的数据包被确认。</li>
</ol>
<p>解决方案：</p>
<ol>
<li>使用多路复用协议：在应用层使用多路复用协议（如 HTTP2）可以在同一个 TCP 连接上同时传输多个请求和响应，但是 HTTP2 仍然受限于 TCP 的队头阻塞</li>
<li>使用 QUIC：基于 UDP 不存在 TCP 层面的队头阻塞，支持多路复用，每个数据流是独立的，丢失的数据包只会影响当前数据流不会阻塞其他数据流。</li>
<li>使用多个 TCP 连接：可以减少单个连接中队头阻塞的影响，但是这种方法会增加连接管理的复杂性和资源开销。</li>
<li>前向纠错(Forward Error Correction, FEC)：发送端可以附加冗余数据，接收端可以通过冗余数据恢复丢失的数据包，减少重传请求。</li>
</ol>
<h2 id="HTTP2-特点"><a href="#HTTP2-特点" class="headerlink" title="HTTP2 特点"></a>HTTP2 特点</h2><ol>
<li>二进制分帧(Binary Framing)：将数据转为二进制格式（而非 HTTP 1.1 的文本格式），分为更小的帧(Frame) 传输。解析高效，错误率低，支持多路复用。</li>
<li>多路复用(Multiplexing)：在单个 TCP 连接上并行传输多个请求和响应，避免 HTTP 1.1 的队头阻塞。显著提升页面加载速度，减少连接数（无需维护多个 TCP 连接）。</li>
<li>头部压缩(HPACK)：使用 HPACK 算法压缩 http header，减少数据冗余。降低带宽，尤其对小文件（如 API 请求）性能提升明显。</li>
<li>服务器推送(Server Push)：主动向客户端推送资源（例如 js，css），无需客户端请求。减少 RTT(往返延迟)，提前加载关键资源</li>
<li>流优先级(Stream Prioritization)：允许客户端为请求分配优先级（如优先加载 HTML 而非图片）。优化资源加载顺序，提升用户体验。</li>
<li>默认加密(基于 HTTPS)：虽不强制，但主流浏览器（如 Chrome、Firefox）仅支持 HTTP&#x2F;2 over TLS（HTTPS）。推动全站加密，增强安全性。</li>
<li>改进的流量控制：基于流的流量控制（而非 TCP 层的全局控制），防止单个流占用过多资源。更精细的带宽管理。</li>
</ol>
<h1 id="WebSocket-和-HTTP-之间有什么关系"><a href="#WebSocket-和-HTTP-之间有什么关系" class="headerlink" title="WebSocket 和 HTTP 之间有什么关系"></a>WebSocket 和 HTTP 之间有什么关系</h1><p>WebSocket 是一个独立的基于 TCP 的协议，它与 HTTP 之间的唯一关系就是它的握手请求可以作为一个升级请求（Upgrade request）经由 HTTP 服务器解释（也就是可以使用 Nginx 反向代理一个WebSocket）。 </p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="HTTP-重定向负载均衡"><a href="#HTTP-重定向负载均衡" class="headerlink" title="HTTP 重定向负载均衡"></a>HTTP 重定向负载均衡</h2><p>来自用户的 HTTP 请求到达负载均衡服务器以后，负载均衡服务器根据某种负载均衡算法计算得到一个应用服务器的地址，通过 HTTP 状态码 302 重定向响应，将新的 IP 地址发送给用户浏览器，用户浏览器收到重定向响应以后，重新发送请求到真正的应用服务器，以此来实现负载均衡。</p>
<p>实现起来非常简单，但是缺点也非常明显：</p>
<ol>
<li>客户端完成一次访问需要 2 次请求（请求负载均衡服务器+应用服务器），处理性能会受到影响</li>
<li>因为客户端需要连接应用服务器，所以需要<strong>将真实 IP 暴露给客户端</strong>，可能会带来安全问题</li>
</ol>
<p>这种方案在实际开发中几乎不会使用。</p>
<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>当用户从浏览器发起 HTTP 请求的时候，首先要到 DNS 域名服务器进行域名解析，解析得到 IP 地址以后，用户才能够根据IP地址建立 HTTP 连接，访问真正的数据中心的应用服务器，这时候就可以在 DNS 解析的时候进行负载均衡，也就是说，<em>不同的用户进行域名解析的时候，返回不同的 IP 地址</em>，从而实现负载均衡。</p>
<p>DNS 负载均衡和 HTTP 重定向负载均衡非常像，但是不会有性能问题：因为 DNS 解析之后 IP 地址就被客户端缓存了。但是会不会有安全问题呢？大型互联网应用通常并不直接通过 DNS 解析得到应用服务器 IP 地址，而是解析得到负载均衡服务器的 IP 地址。也就是说，大型网互联网应用需要<em>两次负载均衡</em>，一次通过<em>DNS负载均衡</em>，用户请求访问数据中心负载均衡服务器集群的某台机器，然后这台负载均衡服务器再进行一次负载均衡，将用户请求分发到应用服务器集群的某台服务器上。通过这种方式，应用服务器不需要用公网IP将自己暴露给外部访问者，避免了安全性问题。</p>
<p>DNS 域名解析是域名服务商提供的一项基本服务，<em>几乎所有的域名服务商都支持域名解析负载均衡</em>，只需要在域名服务商的服务控制台进行一下配置，不需要开发代码进行部署，就可以拥有 DNS 负载均衡服务了。目前大型的互联网应用，淘宝、百度、Google 等全部使用 DNS 负载均衡。比如用不同的电脑<code>ping www.baidu.com</code>就可以看到，不同电脑得到的 IP 地址是不同的。</p>
<h2 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h2><p>常用的 web 服务器 NGINX 就有这个功能。反向代理服务器是工作在 HTTP 协议层之上的，因此这一层的代理负载均衡也叫做<em>应用层负载均衡</em>。所以它代理的也是 HTTP 的请求和响应。作为互联网应用层的一个协议，HTTP 协议相对说来比较重，效率比较低，所以<em>反向代理负载均衡通常用在小规模的互联网系统上，只有几台或者十几台服务器的规模。</em></p>
<h2 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h2><p>工作在 TCP&#x2F;IP 的 IP 层，所以有时候也叫做<em>网络层负载均衡</em>。工作原理：当用户的请求到达负载均衡服务器以后，负载均衡服务器会对网络层的数据包的 IP 地址进行转换，将其修改为应用服务器的 IP 地址，然后把数据包重新发送出去，请求数据就会到达应用服务器。</p>
<p>在操作系统内核直接修改 IP 数据包的地址，效率比应用层的反向代理负载均衡高得多。但是它依然有一个缺陷，不管是请求还是响应的数据包，都要通过负载均衡服务器进行 IP 地址转换，才能够正确地把请求数据分发到应用服务器，或者正确地将响应数据包发送到用户端程序。请求的数据通常比较小，一个 URL 或者是一个简单的表单，但是响应的数据不管是 HTML 还是图片，或者是 JS、CSS这样的资源文件通常都会比较大，因此<em>负载均衡服务器会成为响应数据的流量瓶颈</em>。</p>
<h2 id="数据链路层负载均衡"><a href="#数据链路层负载均衡" class="headerlink" title="数据链路层负载均衡"></a>数据链路层负载均衡</h2><p>可以解决响应数据量大而导致的负载均衡服务器输出带宽不足的问题，像淘宝这种规模的应用，通常使用 Linux 内核支持的链路层负载均衡。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/fadc872a-c54b-4b9c-933a-bb21d7c4ce2a.png" alt="image.png"></p>
<p>这种负载均衡模式也叫<strong>直接路由模式</strong>，在负载均衡服务器的 Linux 操作系统内核拿到数据包后，直接修改数据帧中的 mac 地址，将其修改为应用服务器集群中某个服务器的 mac 地址，然后将数据重新发送回服务器集群所在的局域网，这个数据帧就会被某个真实的应用服务器接收到。</p>
<p>负载均衡服务器和集群内的应用服务器配置相同的虚拟 IP 地址，也就是说，在网络通信的 IP 层面，负载均衡服务器变更 mac 地址的操作是透明的，不影响 TCP&#x2F;IP 的通信连接。所以真实的应用服务器处理完应用请求，发送应答响应的时候，就会直接发送回请求的客户端，不会再经过负载均衡服务器。</p>
<blockquote>
<p>Linux上实现IP负载均衡和链路层负载均衡的技术是 LVS，目前 LVS 功能已经集成到 Linux 中了，可以直接配置实现这两种负载均衡。</p>
</blockquote>
<h1 id="如何改善数据的存储能力"><a href="#如何改善数据的存储能力" class="headerlink" title="如何改善数据的存储能力"></a>如何改善数据的存储能力</h1><p>在整个互联网系统架构中，承受着最大处理压力，最难以被伸缩的，就是数据存储部分。原因主要有两方面：</p>
<ol>
<li>数据存储需要使用硬盘，而硬盘的处理速度要比其他几种计算资源，比如 CPU、内存、网卡都要慢一些；</li>
<li>另一方面，数据是公司最重要的资产，公司需要保证数据的高可用以及一致性，非功能性约束更多一些。</li>
</ol>
<p>因此数据存储通常都是互联网应用的瓶颈。在高并发的情况下，最容易出现性能问题的就是数据存储。目前用来改善数据存储能力的主要手段包括：数据库主从复制、数据库分片和 NoSQL 数据库。</p>
<h1 id="实现高可用常用的手段有哪些"><a href="#实现高可用常用的手段有哪些" class="headerlink" title="实现高可用常用的手段有哪些"></a>实现高可用常用的手段有哪些</h1><h2 id="冗余备份"><a href="#冗余备份" class="headerlink" title="冗余备份"></a>冗余备份</h2><p>提供同一服务的服务器要存在冗余，即任何服务都不能只有一台服务器，服务器之间要互相进行备份，任何一台服务器出现故障的时候，请求可以发送到备份的服务器去处理。这样，即使某台服务器失效，在用户看来，系统依然是可用的。</p>
<h2 id="失败隔离"><a href="#失败隔离" class="headerlink" title="失败隔离"></a>失败隔离</h2><p><em>将失败限制在一个较小的范围之内</em>，使故障影响范围不扩大。具体实现失败隔离的主要架构技术是消息队列。</p>
<p>一方面，消息的生产者和消费者通过消息队列进行隔离。如果消费者出现故障的时候，生产者可以继续向消息队列发送消息，而不会感知到消费者的故障，等消费者恢复正常以后再去从消息队列中消费消息，所以从用户处理的视角看，系统一直是可用的。</p>
<p>发送邮件消费者出现故障，不会影响生产者应用的运行，也不会影响发送短信等其他消费者正常的运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-cdn-bmnleumcou.cn-shenzhen.fcapp.run/?a=images/f5134b9e-f481-4f9b-8626-f18cea210d95.png" alt="image.png"></p>
<p>另一方面，由于分布式消息队列具有削峰填谷的作用，所以在高并发的时候，消息的生产者可以将消息缓冲在分布式消息队列中，消费者可以慢慢地从消息队列中去处理，而不会将瞬时的高并发负载压力直接施加到整个系统上，导致系统崩溃。也就是<strong>将压力隔离开来</strong>，使消息生产者的访问压力不会直接传递到消息的消费者，这样可以提高数据库等对压力比较敏感的服务的可用性。</p>
<p>同时，<em>消息队列还使得程序解耦，将程序的调用和依赖隔离开来</em>，我们知道，低耦合的程序更加易于维护，也可以减少程序出现 Bug的几率。</p>
<h2 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h2><p>保护系统高可用的一种手段。比如说在电商系统中有确认收货这个功能，即便我们不去确认收货，系统也会超时自动确认收货。但际上确认收货这个操作是一个非常重的操作，因为它会对数据库产生很大的压力：它要进行更改订单状态，完成支付确认，并进行评价等一系列操作。如果在系统高并发的时候去完成这些操作，那么会对系统雪上加霜，使系统的处理能力更加恶化。</p>
<p>解决办法就是在系统高并发的时候，比如说像淘宝双 11 的时候，当天可能整天系统都处于一种极限的高并发访问压力之下，这时候就可以将确认收货、评价这些非核心的功能关闭，将宝贵的系统资源留下来，给正在购物的人，让他们去完成交易。</p>
<h2 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h2><p>主要是解决整个数据中心不可用问题的。将数据中心分布在多个不同地点的机房里，这些机房都可以对外提供服务，用户可以连接任何一个机房进行访问，这样每个机房都可以提供完整的系统服务，即使某一个机房不可使用，系统也不会宕机，依然保持可用。</p>
<p>异地多活的架构考虑的重点就是，用户请求如何分发到不同的机房去。这个主要可以在域名解析的时候完成，也就是用户进行域名解析的时候，会根据就近原则或者其他一些策略，完成用户请求的分发。另一个至关重要的技术点是，因为是多个机房都可以独立对外提供服务，所以也就意味着每个机房都要有完整的数据记录。用户在任何一个机房完成的数据操作，都必须同步传输给其他的机房，进行数据实时同步。</p>
<p>数据库实时同步最需要关注的就是数据冲突问题。同一条数据，同时在两个数据中心被修改了，该如何解决？为了解决这种数据冲突的问题，某些容易引起数据冲突的服务采用类似MySQL 的主主模式，也就是说多个机房在某个时刻是有一个主机房的，某些请求只能到达主机房才能被处理，其他的机房不处理这一类请求，以此来避免关键数据的冲突。</p>
<p>除了上述的高可用架构方案，还有一些高可用的运维方案：通过自动化测试减少系统的bug，通过自动化监控尽早发现系统的故障，通过预发布验证发现测试环境无法发现的bug，灰度发布降低软件错误带来的影响以及评估软件版本升级带来的业务影响等等。</p>
<h1 id="如何实现电子邮件的已读回执"><a href="#如何实现电子邮件的已读回执" class="headerlink" title="如何实现电子邮件的已读回执"></a>如何实现电子邮件的已读回执</h1><p>参考<a target="_blank" rel="noopener" href="http://www.getnotify.com/%EF%BC%8C%E5%9C%A8%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%80%E5%BC%A01px%E7%9A%84%E7%A9%BA%E7%99%BD%E5%9B%BE%E7%89%87%EF%BC%8C%E6%A3%80%E6%B5%8B%E8%AF%A5%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0%E3%80%82">http://www.getnotify.com/，在邮件列表插入一个随机生成的一张1px的空白图片，检测该图片链接的访问次数。</a></p>
<p>基于nginx_http_empty_gif借助access.log打点性能开销最小。nginx 1 px 像素gif的妙用：<a target="_blank" rel="noopener" href="http://www.ttlsa.com/nginx/nginx-modules-empty_gif/">http://www.ttlsa.com/nginx/nginx-modules-empty_gif/</a> ，常用于统计打点，这种请求一般只需要单向上报数据，尽可能少返回数据。</p>
<h1 id="说一说你的缺点"><a href="#说一说你的缺点" class="headerlink" title="说一说你的缺点"></a>说一说你的缺点</h1><p>只需要说一说自己现在正在学的东西即可，不要傻乎乎说自己这个不行，那个不行。</p>
<h1 id="你有什么想要问的"><a href="#你有什么想要问的" class="headerlink" title="你有什么想要问的"></a>你有什么想要问的</h1><p>这个岗位具体会做哪些事情，会与哪些人合作？<br>进一步对工作岗位进行深入了解，以及对将来的合作伙伴有更多提前认知，同时给面试官一些尽情表达的机会，显得你是非常关心这个工作机会。</p>
<p>咱们团队目前面对的最大挑战&#x2F;困难是什么?<br>抓住机会深入了解团队目前的困难、痛点，利用入职前的空档期，提前做好预习与准备，以便顺利入职之后快速产出。</p>
<p>总之，**问太肤浅的问题，会让你显得格局小。**太细节、太琐碎的，比如作息制度、报销制度，是否管午饭，是否经常加班，团队有几个女生，有没有健身房……等等类似太具体的问题，还是留在该公司将offer发给你之后、入职已经胜券在握的时候再去问HR吧。</p>
<blockquote>
<p>太上无败，其次败而有以成，此之谓用民。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://consoles.fun">consoles</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/">https://consoles.fun/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://consoles.fun" target="_blank">雨碎江南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/08/26/%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="短地址服务的设计与实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-26</div><div class="info-item-2">短地址服务的设计与实现</div></div><div class="info-2"><div class="info-item-1">有不少网站可以提供长链转短链的服务,例如新浪短地址服务、bitly。背后的原理其实是将长链和短链进行一一映射。换而言之，各家短链服务商的短链和长链是一一对应的。其中的关键点在于如何根据长链生成短链，以及当用户访问短链后怎么处理。 如何生成短地址比较直观想到的解法是使用哈希函数，但是无论怎样构造哈希函数，都存在哈希碰撞的问题。再次想到碰撞之后可以在 hash 字符串后面补充其他字符串来实现，但是需要补充多少位呢？这种方案显然不是那么方便。联想到全局唯一，以及数据存储我们很容易想到数据库的自增 id，其实这样也是可以的，这里为了实现简单(主要是天然的过期时间)，采用了 redis 来存储数据，其 key 设计如下： globalId:全局自增 id，用于保证短链的唯一性shortToLong:短地址到长地址的映射,key...</div></div></div></a><a class="pagination-related" href="/2016/12/28/awesome-java/" title="java 中的一些惯用法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-12-28</div><div class="info-item-2">java 中的一些惯用法</div></div><div class="info-2"><div class="info-item-1"> 鸟宿池边树，僧敲月下门。  java7中的try-resource语法语义自动关闭InputStream和JDBC Connection，就不需要在finally中close了。 java中的锁是如何实现的在java里锁是通过cas把当前线程id刷新到对象的头信息里，在获取锁时会去头信息里拿这个信息，如果没有则会cas刷新进去，刷新成功就获取到锁；刷新失败就表明有别的线程也在尝试刷新这个信息。 在操作系统层面有pv操作保证原子性，而pv操作也是利用cpu中原语指令，在获取锁时保证不会被别的指令打断（或被重排序）。 白名单问题 java中1&#x2F;0抛出算术异常，而1&#x2F;0.0结果为无穷大。  一家信用卡公司中的账号是成千上万的，我们将用户账号保存在一个文件中，这个文件就是白名单。认为给定一个账户，我们需要检查该账号是否在白名单中。一个程序可用往往是不够的，如果没有二分查找或者归并排序这样的高效算法解决此类问题是不可能的。 关于除法运算无论正负，a / b的商会向0取整。而余数满足这个公式：(a/b) * b + a % b == a。例如-14 &#x2F; 3...</div></div></div></a><a class="pagination-related" href="/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/" title="码农翻身有感"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-05</div><div class="info-item-2">码农翻身有感</div></div><div class="info-2"><div class="info-item-1"> 青青翠竹尽是法身，郁郁黄花无非般若。教育小孩和做团队 leader 有相通之处。  做技术切记“本末倒置”，我非常痛恨那些采用 bottom-up 方式来讲解技术的资料和文章，一上来就是技术细节、安装步骤、配置丰富，让初学者晕头转向，不知所云，看完以后也不知道为什么要有这个东西、解决了什么问题、它有什么来龙去脉。换句话说，这些资料和文章习惯于讲解 How，而不是 Why，但是在我看来，Why 有时候比 How 更重要。 当你改变不了别人的时候，抱怨也没有用，还是要先改变一下自己。 程序的局部性原理可以从时空两个维度来进行解释。 时间局部性：如果程序中某条指令开始执行，则不久之后该指令可能被再次执行；如果某数据被访问，则不久之后该数据可能被再次访问。空间局部性：一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被再次访问。 GSM 技术的核心是时分多址(TCDMA),将每个无线电频率按照时间均匀分给 8 (或者 16) 个用户，每个用户交互占用 1&#x2F;8...</div></div></div></a><a class="pagination-related" href="/2016/06/17/beauty-of-mathematics/" title="数学之美"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2016-06-17</div><div class="info-item-2">数学之美</div></div><div class="info-2"><div class="info-item-1"> 教育的本质不是将篮子填满，而是将灯点亮。   简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。 —— 蒂姆·博纳斯·李   Virture is like a rich stone,best plain set.(美德如同宝石，在朴素的映衬下最显华丽) —— 培根   爱是一念之差，最幸福的不过是，你曾经的呼唤，而我恰有过应答。 —— 朝小诚《黑白》   技术分为术和道2种。具体的做事方法是术，做事的原理和原则是道。很多具体的技术很快就会从独门绝技到普及，再到落伍，追求术的人一辈子很辛苦，只有掌握了道才能够做到游刃有余。追求“术”的人多半抱有侥幸心理，想走捷径，但真正做好一件事没有捷径，需要一万小时的专业训练和努力，也就是“一万小时定律”。   中国古代的阴阳学说可以看做是二进制的雏形。   数据库索引和布尔代数息息相关。   网络爬虫一般的步骤是“下载-索引-排序”，其中广度优先遍历用得比较多。   完全随机的高斯白噪声是很难消除的。  文字语言 VS...</div></div></div></a><a class="pagination-related" href="/2020/03/25/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Promise/" title="如何实现 Promise"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-25</div><div class="info-item-2">如何实现 Promise</div></div><div class="info-2"><div class="info-item-1">先来看下 Promise 的常见应用：  观察者模式观察上面的这个例子，我们来分析 Promise 的调用流程：  构造方法接受一个 executor 函数，在 new Promise 的时候这个 executor 立即执行 executor 内部的异步任务被放入微任务队列等待执行 then 被执行，收集成功&#x2F;失败回调，放入成功&#x2F;失败队列 executor 的异步任务被执行，触发resolve&#x2F;reject，从成功&#x2F;失败队列中取出回调依次执行  由上面的分析得知这是一种典型的观察者模式。这是典型的“收集依赖-&gt;触发依赖-&gt;取出依赖执行”的方式，在 Promise 中执行顺序是 “then收集依赖-&gt;异步触发resolve-&gt;resolve执行依赖”。由此我们可以勾勒出 Promise 的大致形状： 123456789101112131415161718192021222324252627282930class Promise&#123;    constructor(executor)&#123;       ...</div></div></div></a><a class="pagination-related" href="/2020/03/26/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0async-await/" title="如何实现 async&#x2F;await"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-26</div><div class="info-item-2">如何实现 async&#x2F;await</div></div><div class="info-2"><div class="info-item-1">基于 Promise 的异步处理虽然解决了基于 callback 的过多嵌套的问题，但是可读性也并没有强多少，流程控制也不是特别方便，所以 ES7 提出了 async 函数完美解决了上述问题。async&#x2F;await实际上是对Generator 的封装，是生成器函数的语法糖。 async函数是AsyncFunction构造函数的实例，并且在函数体中允许使用 await 关键字。await 操作符用于等待 Promise 兑现并获取它兑现之后的值，智能在 async 函数或者顶层模块中使用。async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 Promise  ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流程挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。   yield 表达式本身没有返回值（或者总是返回 undefined），next 方法可以带一个参数，该参数就会被当作上一个 yield...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">consoles</div><div class="author-info-description">野马也，尘埃也，生物之以息相吹也</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/consoles"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/consoles" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:consoles.me@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%E5%86%99%E6%97%A5%E5%BF%97"><span class="toc-number">1.</span> <span class="toc-text">如何规范写日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%A6%81%E6%9C%89%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">日志要有分隔符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87UUID%E7%BC%96%E5%8F%B7%E6%9D%A5%E4%BF%9D%E8%AF%81%E6%97%A5%E5%BF%97%E7%9A%84%E8%BF%9E%E8%B4%AF%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">通过UUID编号来保证日志的连贯性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E7%94%A8JSON%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">对于数组、对象类型统一用JSON格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%97%A5%E5%BF%97%E8%A6%81%E8%84%B1%E6%95%8F"><span class="toc-number">1.4.</span> <span class="toc-text">重要日志要脱敏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E5%B0%8F%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">怎么限制文件上传大小？原理是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-NIO-%E4%B8%AD%E7%9A%84-Selector"><span class="toc-number">3.</span> <span class="toc-text">如何理解 NIO 中的 Selector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API-%E7%BD%91%E5%85%B3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">API 网关有什么用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%89%B4%E6%9D%83"><span class="toc-number">5.</span> <span class="toc-text">如何进行接口的鉴权</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT"><span class="toc-number">5.1.</span> <span class="toc-text">JWT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98"><span class="toc-number">6.</span> <span class="toc-text">系统调优</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A6%81%E9%87%87%E7%94%A8%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">为什么 DNS 服务器要采用分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">DNS 域名解析的流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CDN-%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">CDN 的原理以及如何更新缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-TCP-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">9.</span> <span class="toc-text">谈谈 TCP 中的状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">9.1.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.2.</span> <span class="toc-text">半连接队列是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%813%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">为什么需要3次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">9.3.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%97%B6-3-%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E6%97%B6-4-%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">9.4.</span> <span class="toc-text">为什么建立连接时 3 次握手，而关闭连接时 4 次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TIME-WAIT-%E7%8A%B6%E6%80%81%E8%BF%98%E9%9C%80%E8%A6%81%E7%AD%89-2MSL-%E5%90%8E%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0-CLOSED-%E7%8A%B6%E6%80%81"><span class="toc-number">9.5.</span> <span class="toc-text">为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP"><span class="toc-number">9.6.</span> <span class="toc-text">TCP 和 UDP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">如何设计一个高并发系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8B%86%E5%88%86"><span class="toc-number">10.1.</span> <span class="toc-text">系统拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">10.2.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ"><span class="toc-number">10.3.</span> <span class="toc-text">MQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">10.4.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">10.5.</span> <span class="toc-text">读写分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">10.6.</span> <span class="toc-text">ElasticSearch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Protocol-Buffer-%E7%9A%84%E6%95%88%E7%8E%87%E6%98%AF%E6%9C%80%E9%AB%98%E7%9A%84"><span class="toc-number">10.7.</span> <span class="toc-text">为什么 Protocol Buffer 的效率是最高的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZK%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">10.8.</span> <span class="toc-text">ZK的使用场景有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83"><span class="toc-number">10.8.1.</span> <span class="toc-text">分布式协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">10.8.2.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE-%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86"><span class="toc-number">10.8.3.</span> <span class="toc-text">元数据&#x2F;配置信息管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HA%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">10.8.4.</span> <span class="toc-text">HA高可用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">11.1.</span> <span class="toc-text">不适用的场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">高可用架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E8%AF%A6%E6%83%85%E9%A1%B5%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">12.1.</span> <span class="toc-text">电商网站详情页系统架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">数据结构和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-LRU"><span class="toc-number">13.1.</span> <span class="toc-text">设计实现一个 LRU</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E9%80%80%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC"><span class="toc-number">14.</span> <span class="toc-text">如何回退代码到指定版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%E8%83%BD%E5%8F%91%E5%87%A0%E4%B8%AA-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">15.</span> <span class="toc-text">一个 TCP 连接能发几个 HTTP 请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP2-HTTP3"><span class="toc-number">16.</span> <span class="toc-text">HTTP2&#x2F;HTTP3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">16.1.</span> <span class="toc-text">什么是 TCP 的队头阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP2-%E7%89%B9%E7%82%B9"><span class="toc-number">16.2.</span> <span class="toc-text">HTTP2 特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebSocket-%E5%92%8C-HTTP-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">17.</span> <span class="toc-text">WebSocket 和 HTTP 之间有什么关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E9%87%8D%E5%AE%9A%E5%90%91%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.1.</span> <span class="toc-text">HTTP 重定向负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.2.</span> <span class="toc-text">DNS负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.3.</span> <span class="toc-text">反向代理负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.4.</span> <span class="toc-text">IP 负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">18.5.</span> <span class="toc-text">数据链路层负载均衡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%B9%E5%96%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E8%83%BD%E5%8A%9B"><span class="toc-number">19.</span> <span class="toc-text">如何改善数据的存储能力</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">20.</span> <span class="toc-text">实现高可用常用的手段有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E5%A4%87%E4%BB%BD"><span class="toc-number">20.1.</span> <span class="toc-text">冗余备份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E9%9A%94%E7%A6%BB"><span class="toc-number">20.2.</span> <span class="toc-text">失败隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E9%99%8D%E7%BA%A7"><span class="toc-number">20.3.</span> <span class="toc-text">限流降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%9C%B0%E5%A4%9A%E6%B4%BB"><span class="toc-number">20.4.</span> <span class="toc-text">异地多活</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%B7%B2%E8%AF%BB%E5%9B%9E%E6%89%A7"><span class="toc-number">21.</span> <span class="toc-text">如何实现电子邮件的已读回执</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">22.</span> <span class="toc-text">说一说你的缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E6%83%B3%E8%A6%81%E9%97%AE%E7%9A%84"><span class="toc-number">23.</span> <span class="toc-text">你有什么想要问的</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/30/%E7%AE%A1%E7%90%86%E5%AD%A6/" title="管理学">管理学</a><time datetime="2025-07-09T23:24:02.000Z" title="更新于 2025-07-09 23:24:02">2025-07-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/11/05/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB%E6%9C%89%E6%84%9F/" title="码农翻身有感">码农翻身有感</a><time datetime="2025-07-04T23:02:12.000Z" title="更新于 2025-07-04 23:02:12">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2019/08/22/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF/" title="面试常用套路">面试常用套路</a><time datetime="2025-07-02T18:34:21.000Z" title="更新于 2025-07-02 18:34:21">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2016/10/18/memcached/" title="memcached 初窥">memcached 初窥</a><time datetime="2025-07-02T11:15:01.000Z" title="更新于 2025-07-02 11:15:01">2025-07-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2020/05/09/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%BB%E7%9A%84%E4%B9%A6/" title="一些想读的书">一些想读的书</a><time datetime="2025-06-28T22:18:10.000Z" title="更新于 2025-06-28 22:18:10">2025-06-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2025 By consoles</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">日拱一卒，功不唐捐</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="false"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>